package tasks

// Code generated by go-ipld-prime gengo.  DO NOT EDIT.

import (
	ipld "github.com/ipld/go-ipld-prime"
	"github.com/ipld/go-ipld-prime/node/mixins"
	"github.com/ipld/go-ipld-prime/schema"
)

func (n _Any) AsInterface() _Any__iface {
	return n.x
}
type _Any__Maybe struct {
	m schema.Maybe
	v Any
}
type MaybeAny = *_Any__Maybe

func (m MaybeAny) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeAny) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeAny) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeAny) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeAny) Must() Any {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
	memberName__Any_Bool = _String{"Bool"}
	memberName__Any_Int = _String{"Int"}
	memberName__Any_Float = _String{"Float"}
	memberName__Any_String = _String{"String"}
	memberName__Any_Bytes = _String{"Bytes"}
	memberName__Any_Map = _String{"Map"}
	memberName__Any_List = _String{"List"}
	memberName__Any_Link = _String{"Link"}
)
var _ ipld.Node = (Any)(&_Any{})
var _ schema.TypedNode = (Any)(&_Any{})
func (Any) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n Any) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Bool":
		if n2, ok := n.x.(Bool); ok {
			return n2, nil
		} else {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
	case "Int":
		if n2, ok := n.x.(Int); ok {
			return n2, nil
		} else {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
	case "Float":
		if n2, ok := n.x.(Float); ok {
			return n2, nil
		} else {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
	case "String":
		if n2, ok := n.x.(String); ok {
			return n2, nil
		} else {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
	case "Bytes":
		if n2, ok := n.x.(Bytes); ok {
			return n2, nil
		} else {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
	case "Map":
		if n2, ok := n.x.(Map); ok {
			return n2, nil
		} else {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
	case "List":
		if n2, ok := n.x.(List); ok {
			return n2, nil
		} else {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
	case "Link":
		if n2, ok := n.x.(Link); ok {
			return n2, nil
		} else {
			return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n Any) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (Any) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"tasks.Any"}.LookupByIndex(0)
}
func (n Any) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n Any) MapIterator() ipld.MapIterator {
	return &_Any__MapItr{n, false}
}

type _Any__MapItr struct {
	n Any
	done bool
}

func (itr *_Any__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.done {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch n2 := itr.n.x.(type) {
	case Bool:
		k, v = &memberName__Any_Bool, n2
	case Int:
		k, v = &memberName__Any_Int, n2
	case Float:
		k, v = &memberName__Any_Float, n2
	case String:
		k, v = &memberName__Any_String, n2
	case Bytes:
		k, v = &memberName__Any_Bytes, n2
	case Map:
		k, v = &memberName__Any_Map, n2
	case List:
		k, v = &memberName__Any_List, n2
	case Link:
		k, v = &memberName__Any_Link, n2
	default:
		panic("unreachable")
	}
	itr.done = true
	return
}
func (itr *_Any__MapItr) Done() bool {
	return itr.done
}

func (Any) ListIterator() ipld.ListIterator {
	return nil
}
func (Any) Length() int64 {
	return 1
}
func (Any) IsAbsent() bool {
	return false
}
func (Any) IsNull() bool {
	return false
}
func (Any) AsBool() (bool, error) {
	return mixins.Map{"tasks.Any"}.AsBool()
}
func (Any) AsInt() (int64, error) {
	return mixins.Map{"tasks.Any"}.AsInt()
}
func (Any) AsFloat() (float64, error) {
	return mixins.Map{"tasks.Any"}.AsFloat()
}
func (Any) AsString() (string, error) {
	return mixins.Map{"tasks.Any"}.AsString()
}
func (Any) AsBytes() ([]byte, error) {
	return mixins.Map{"tasks.Any"}.AsBytes()
}
func (Any) AsLink() (ipld.Link, error) {
	return mixins.Map{"tasks.Any"}.AsLink()
}
func (Any) Prototype() ipld.NodePrototype {
	return _Any__Prototype{}
}
type _Any__Prototype struct{}

func (_Any__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Any__Builder
	nb.Reset()
	return &nb
}
type _Any__Builder struct {
	_Any__Assembler
}
func (nb *_Any__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Any__Builder) Reset() {
	var w _Any
	var m schema.Maybe
	*nb = _Any__Builder{_Any__Assembler{w: &w, m: &m}}
}
type _Any__Assembler struct {
	w *_Any
	m *schema.Maybe
	state maState

	cm schema.Maybe
	ca1 *_Bool__Assembler
	
	ca2 *_Int__Assembler
	
	ca3 *_Float__Assembler
	
	ca4 *_String__Assembler
	
	ca5 *_Bytes__Assembler
	
	ca6 *_Map__Assembler
	
	ca7 *_List__Assembler
	
	ca8 *_Link__Assembler
	ca uint
}
func (na *_Any__Assembler) reset() {
	na.state = maState_initial
	switch na.ca {
	case 0:
		return
	case 1:
		na.ca1.reset()
	
	case 2:
		na.ca2.reset()
	
	case 3:
		na.ca3.reset()
	
	case 4:
		na.ca4.reset()
	
	case 5:
		na.ca5.reset()
	
	case 6:
		na.ca6.reset()
	
	case 7:
		na.ca7.reset()
	
	case 8:
		na.ca8.reset()
	default:
		panic("unreachable")
	}
	na.ca = 0
	na.cm = schema.Maybe_Absent
}
func (na *_Any__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Any{}
	}
	return na, nil
}
func (_Any__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"tasks.Any"}.BeginList(0)
}
func (na *_Any__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"tasks.Any"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Any__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"tasks.Any"}.AssignBool(false)
}
func (_Any__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"tasks.Any"}.AssignInt(0)
}
func (_Any__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"tasks.Any"}.AssignFloat(0)
}
func (_Any__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"tasks.Any"}.AssignString("")
}
func (_Any__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"tasks.Any"}.AssignBytes(nil)
}
func (_Any__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"tasks.Any"}.AssignLink(nil)
}
func (na *_Any__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Any); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "tasks.Any", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Any__Assembler) Prototype() ipld.NodePrototype {
	return _Any__Prototype{}
}
func (ma *_Any__Assembler) valueFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:ma.state = maState_initial
		return true
	default:
		return false
	}
}
func (ma *_Any__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly.
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	if ma.ca != 0 {
		return nil, schema.ErrNotUnionStructure{TypeName:"tasks.Any", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "Bool":
		ma.state = maState_midValue
		ma.ca = 1
		x := &_Bool{}
		ma.w.x = x
		if ma.ca1 == nil {
			ma.ca1 = &_Bool__Assembler{}
		}
		ma.ca1.w = x
		ma.ca1.m = &ma.cm
		return ma.ca1, nil
	case "Int":
		ma.state = maState_midValue
		ma.ca = 2
		x := &_Int{}
		ma.w.x = x
		if ma.ca2 == nil {
			ma.ca2 = &_Int__Assembler{}
		}
		ma.ca2.w = x
		ma.ca2.m = &ma.cm
		return ma.ca2, nil
	case "Float":
		ma.state = maState_midValue
		ma.ca = 3
		x := &_Float{}
		ma.w.x = x
		if ma.ca3 == nil {
			ma.ca3 = &_Float__Assembler{}
		}
		ma.ca3.w = x
		ma.ca3.m = &ma.cm
		return ma.ca3, nil
	case "String":
		ma.state = maState_midValue
		ma.ca = 4
		x := &_String{}
		ma.w.x = x
		if ma.ca4 == nil {
			ma.ca4 = &_String__Assembler{}
		}
		ma.ca4.w = x
		ma.ca4.m = &ma.cm
		return ma.ca4, nil
	case "Bytes":
		ma.state = maState_midValue
		ma.ca = 5
		x := &_Bytes{}
		ma.w.x = x
		if ma.ca5 == nil {
			ma.ca5 = &_Bytes__Assembler{}
		}
		ma.ca5.w = x
		ma.ca5.m = &ma.cm
		return ma.ca5, nil
	case "Map":
		ma.state = maState_midValue
		ma.ca = 6
		x := &_Map{}
		ma.w.x = x
		if ma.ca6 == nil {
			ma.ca6 = &_Map__Assembler{}
		}
		ma.ca6.w = x
		ma.ca6.m = &ma.cm
		return ma.ca6, nil
	case "List":
		ma.state = maState_midValue
		ma.ca = 7
		x := &_List{}
		ma.w.x = x
		if ma.ca7 == nil {
			ma.ca7 = &_List__Assembler{}
		}
		ma.ca7.w = x
		ma.ca7.m = &ma.cm
		return ma.ca7, nil
	case "Link":
		ma.state = maState_midValue
		ma.ca = 8
		x := &_Link{}
		ma.w.x = x
		if ma.ca8 == nil {
			ma.ca8 = &_Link__Assembler{}
		}
		ma.ca8.w = x
		ma.ca8.m = &ma.cm
		return ma.ca8, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"tasks.Any", Key:&_String{k}}
	}
}
func (ma *_Any__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on for the moment, but we'll still be erroring shortly... or rather, the keyassembler will be.
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Any__KeyAssembler)(ma)
}
func (ma *_Any__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.ca {
	case 0:
		x := &_Bool{}
		ma.w.x = x
		if ma.ca1 == nil {
			ma.ca1 = &_Bool__Assembler{}
		}
		ma.ca1.w = x
		ma.ca1.m = &ma.cm
		return ma.ca1
	case 1:
		x := &_Int{}
		ma.w.x = x
		if ma.ca2 == nil {
			ma.ca2 = &_Int__Assembler{}
		}
		ma.ca2.w = x
		ma.ca2.m = &ma.cm
		return ma.ca2
	case 2:
		x := &_Float{}
		ma.w.x = x
		if ma.ca3 == nil {
			ma.ca3 = &_Float__Assembler{}
		}
		ma.ca3.w = x
		ma.ca3.m = &ma.cm
		return ma.ca3
	case 3:
		x := &_String{}
		ma.w.x = x
		if ma.ca4 == nil {
			ma.ca4 = &_String__Assembler{}
		}
		ma.ca4.w = x
		ma.ca4.m = &ma.cm
		return ma.ca4
	case 4:
		x := &_Bytes{}
		ma.w.x = x
		if ma.ca5 == nil {
			ma.ca5 = &_Bytes__Assembler{}
		}
		ma.ca5.w = x
		ma.ca5.m = &ma.cm
		return ma.ca5
	case 5:
		x := &_Map{}
		ma.w.x = x
		if ma.ca6 == nil {
			ma.ca6 = &_Map__Assembler{}
		}
		ma.ca6.w = x
		ma.ca6.m = &ma.cm
		return ma.ca6
	case 6:
		x := &_List{}
		ma.w.x = x
		if ma.ca7 == nil {
			ma.ca7 = &_List__Assembler{}
		}
		ma.ca7.w = x
		ma.ca7.m = &ma.cm
		return ma.ca7
	case 7:
		x := &_Link{}
		ma.w.x = x
		if ma.ca8 == nil {
			ma.ca8 = &_Link__Assembler{}
		}
		ma.ca8.w = x
		ma.ca8.m = &ma.cm
		return ma.ca8
	default:
		panic("unreachable")
	}
}
func (ma *_Any__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.ca == 0 {
		return schema.ErrNotUnionStructure{TypeName:"tasks.Any", Detail: "a union must have exactly one entry (not none)!"}
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Any__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Any__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	switch k {
	case "Bool":
		return _Bool__Prototype{}
	case "Int":
		return _Int__Prototype{}
	case "Float":
		return _Float__Prototype{}
	case "String":
		return _String__Prototype{}
	case "Bytes":
		return _Bytes__Prototype{}
	case "Map":
		return _Map__Prototype{}
	case "List":
		return _List__Prototype{}
	case "Link":
		return _Link__Prototype{}
	default:
		return nil
	}
}
type _Any__KeyAssembler _Any__Assembler
func (_Any__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"tasks.Any.KeyAssembler"}.BeginMap(0)
}
func (_Any__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"tasks.Any.KeyAssembler"}.BeginList(0)
}
func (na *_Any__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"tasks.Any.KeyAssembler"}.AssignNull()
}
func (_Any__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"tasks.Any.KeyAssembler"}.AssignBool(false)
}
func (_Any__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"tasks.Any.KeyAssembler"}.AssignInt(0)
}
func (_Any__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"tasks.Any.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Any__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	if ka.ca != 0 {
		return schema.ErrNotUnionStructure{TypeName:"tasks.Any", Detail: "cannot add another entry -- a union can only contain one thing!"}
	}
	switch k {
	case "Bool":
		ka.ca = 1
		ka.state = maState_expectValue
		return nil
	case "Int":
		ka.ca = 2
		ka.state = maState_expectValue
		return nil
	case "Float":
		ka.ca = 3
		ka.state = maState_expectValue
		return nil
	case "String":
		ka.ca = 4
		ka.state = maState_expectValue
		return nil
	case "Bytes":
		ka.ca = 5
		ka.state = maState_expectValue
		return nil
	case "Map":
		ka.ca = 6
		ka.state = maState_expectValue
		return nil
	case "List":
		ka.ca = 7
		ka.state = maState_expectValue
		return nil
	case "Link":
		ka.ca = 8
		ka.state = maState_expectValue
		return nil
	default:
		return ipld.ErrInvalidKey{TypeName:"tasks.Any", Key:&_String{k}} // TODO: error quality: ErrInvalidUnionDiscriminant ?
	}
	return nil
}
func (_Any__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"tasks.Any.KeyAssembler"}.AssignBytes(nil)
}
func (_Any__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"tasks.Any.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Any__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Any__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (Any) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Any) Representation() ipld.Node {
	return (*_Any__Repr)(n)
}
type _Any__Repr _Any
var _ ipld.Node = &_Any__Repr{}
func (n *_Any__Repr) Kind() ipld.Kind {
	switch n.x.(type) {
	case Bool:
		return ipld.Kind_Bool
	case Int:
		return ipld.Kind_Int
	case Float:
		return ipld.Kind_Float
	case String:
		return ipld.Kind_String
	case Bytes:
		return ipld.Kind_Bytes
	case Map:
		return ipld.Kind_Map
	case List:
		return ipld.Kind_List
	case Link:
		return ipld.Kind_Link
	default:
		panic("unreachable")
	}
}
func (n *_Any__Repr) LookupByString(key string) (ipld.Node, error) {
	switch n2 := n.x.(type) {
	case Map:
		return n2.Representation().LookupByString(key)
	default:
		return nil, ipld.ErrWrongKind{TypeName: "tasks.Any.Repr", MethodName: "LookupByString", AppropriateKind: ipld.KindSet_JustMap, ActualKind: n.Kind()}
	}
}
func (n *_Any__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	switch n2 := n.x.(type) {
	case Map:
		return n2.Representation().LookupByNode(key)
	case List:
		return n2.Representation().LookupByNode(key)
	default:
		return nil, ipld.ErrWrongKind{TypeName: "tasks.Any.Repr", MethodName: "LookupByNode", AppropriateKind: ipld.KindSet_Recursive, ActualKind: n.Kind()}
	}
}
func (n *_Any__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	switch n2 := n.x.(type) {
	case List:
		return n2.Representation().LookupByIndex(idx)
	default:
		return nil, ipld.ErrWrongKind{TypeName: "tasks.Any.Repr", MethodName: "LookupByIndex", AppropriateKind: ipld.KindSet_JustList, ActualKind: n.Kind()}
	}
}
func (n *_Any__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	switch n2 := n.x.(type) {
	case Map:
		return n2.Representation().LookupBySegment(seg)
	case List:
		return n2.Representation().LookupBySegment(seg)
	default:
		return nil, ipld.ErrWrongKind{TypeName: "tasks.Any.Repr", MethodName: "LookupBySegment", AppropriateKind: ipld.KindSet_Recursive, ActualKind: n.Kind()}
	}
}
func (n *_Any__Repr) MapIterator() ipld.MapIterator {
	switch n2 := n.x.(type) {
	case Map:
		return n2.Representation().MapIterator()
	default:
		return nil
	}
}
func (n *_Any__Repr) ListIterator() ipld.ListIterator {
	switch n2 := n.x.(type) {
	case List:
		return n2.Representation().ListIterator()
	default:
		return nil
	}
}
func (n *_Any__Repr) Length() int64 {
	switch n2 := n.x.(type) {
	case Map:
		return n2.Representation().Length()
	case List:
		return n2.Representation().Length()
	default:
		return -1
	}
}
func (n *_Any__Repr) IsAbsent() bool {
	return false
}
func (n *_Any__Repr) IsNull() bool {
	return false
}
func (n *_Any__Repr) AsBool() (bool, error) {
	switch n2 := n.x.(type) {
	case Bool:
		return n2.Representation().AsBool()
	default:
		return false, ipld.ErrWrongKind{TypeName: "tasks.Any.Repr", MethodName: "AsBool", AppropriateKind: ipld.KindSet_JustBool, ActualKind: n.Kind()}
	}
}
func (n *_Any__Repr) AsInt() (int64, error) {
	switch n2 := n.x.(type) {
	case Int:
		return n2.Representation().AsInt()
	default:
		return 0, ipld.ErrWrongKind{TypeName: "tasks.Any.Repr", MethodName: "AsInt", AppropriateKind: ipld.KindSet_JustInt, ActualKind: n.Kind()}
	}
}
func (n *_Any__Repr) AsFloat() (float64, error) {
	switch n2 := n.x.(type) {
	case Float:
		return n2.Representation().AsFloat()
	default:
		return 0, ipld.ErrWrongKind{TypeName: "tasks.Any.Repr", MethodName: "AsFloat", AppropriateKind: ipld.KindSet_JustFloat, ActualKind: n.Kind()}
	}
}
func (n *_Any__Repr) AsString() (string, error) {
	switch n2 := n.x.(type) {
	case String:
		return n2.Representation().AsString()
	default:
		return "", ipld.ErrWrongKind{TypeName: "tasks.Any.Repr", MethodName: "AsString", AppropriateKind: ipld.KindSet_JustString, ActualKind: n.Kind()}
	}
}
func (n *_Any__Repr) AsBytes() ([]byte, error) {
	switch n2 := n.x.(type) {
	case Bytes:
		return n2.Representation().AsBytes()
	default:
		return nil, ipld.ErrWrongKind{TypeName: "tasks.Any.Repr", MethodName: "AsBytes", AppropriateKind: ipld.KindSet_JustBytes, ActualKind: n.Kind()}
	}
}
func (n *_Any__Repr) AsLink() (ipld.Link, error) {
	switch n2 := n.x.(type) {
	case Link:
		return n2.Representation().AsLink()
	default:
		return nil, ipld.ErrWrongKind{TypeName: "tasks.Any.Repr", MethodName: "AsLink", AppropriateKind: ipld.KindSet_JustLink, ActualKind: n.Kind()}
	}
}
func (_Any__Repr) Prototype() ipld.NodePrototype {
	return _Any__ReprPrototype{}
}
type _Any__ReprPrototype struct{}

func (_Any__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Any__ReprBuilder
	nb.Reset()
	return &nb
}
type _Any__ReprBuilder struct {
	_Any__ReprAssembler
}
func (nb *_Any__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Any__ReprBuilder) Reset() {
	var w _Any
	var m schema.Maybe
	*nb = _Any__ReprBuilder{_Any__ReprAssembler{w: &w, m: &m}}
}
type _Any__ReprAssembler struct {
	w *_Any
	m *schema.Maybe
	ca1 *_Bool__ReprAssembler
	ca2 *_Int__ReprAssembler
	ca3 *_Float__ReprAssembler
	ca4 *_String__ReprAssembler
	ca5 *_Bytes__ReprAssembler
	ca6 *_Map__ReprAssembler
	ca7 *_List__ReprAssembler
	ca8 *_Link__ReprAssembler
	ca uint
}
func (na *_Any__ReprAssembler) reset() {
	switch na.ca {
	case 0:
		return
	case 1:
		na.ca1.reset()
	case 2:
		na.ca2.reset()
	case 3:
		na.ca3.reset()
	case 4:
		na.ca4.reset()
	case 5:
		na.ca5.reset()
	case 6:
		na.ca6.reset()
	case 7:
		na.ca7.reset()
	case 8:
		na.ca8.reset()
	default:
		panic("unreachable")
	}
	na.ca = 0
}
func (na *_Any__ReprAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign into assembler that's already working on a larger structure!")
	}
	if na.w == nil {
		na.w = &_Any{}
	}
	na.ca = 6
	x := &_Map{}
	na.w.x = x
	if na.ca6 == nil {
		na.ca6 = &_Map__ReprAssembler{}
	}
	na.ca6.w = x
	na.ca6.m = na.m
	return na.ca6.BeginMap(sizeHint)
	return nil, schema.ErrNotUnionStructure{TypeName: "tasks.Any.Repr", Detail: "BeginMap called but is not valid for any of the kinds that are valid members of this union"}
}
func (na *_Any__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign into assembler that's already working on a larger structure!")
	}
	if na.w == nil {
		na.w = &_Any{}
	}
	na.ca = 7
	x := &_List{}
	na.w.x = x
	if na.ca7 == nil {
		na.ca7 = &_List__ReprAssembler{}
	}
	na.ca7.w = x
	na.ca7.m = na.m
	return na.ca7.BeginList(sizeHint)
	return nil, schema.ErrNotUnionStructure{TypeName: "tasks.Any.Repr", Detail: "BeginList called but is not valid for any of the kinds that are valid members of this union"}
}
func (na *_Any__ReprAssembler) AssignNull() error  {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign into assembler that's already working on a larger structure!")
	}
	return  schema.ErrNotUnionStructure{TypeName: "tasks.Any.Repr", Detail: "AssignNull called but is not valid for any of the kinds that are valid members of this union"}
}
func (na *_Any__ReprAssembler) AssignBool(v bool) error  {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign into assembler that's already working on a larger structure!")
	}
	if na.w == nil {
		na.w = &_Any{}
	}
	na.ca = 1
	x := &_Bool{}
	na.w.x = x
	if na.ca1 == nil {
		na.ca1 = &_Bool__ReprAssembler{}
	}
	na.ca1.w = x
	na.ca1.m = na.m
	return na.ca1.AssignBool(v)
	return  schema.ErrNotUnionStructure{TypeName: "tasks.Any.Repr", Detail: "AssignBool called but is not valid for any of the kinds that are valid members of this union"}
}
func (na *_Any__ReprAssembler) AssignInt(v int64) error  {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign into assembler that's already working on a larger structure!")
	}
	if na.w == nil {
		na.w = &_Any{}
	}
	na.ca = 2
	x := &_Int{}
	na.w.x = x
	if na.ca2 == nil {
		na.ca2 = &_Int__ReprAssembler{}
	}
	na.ca2.w = x
	na.ca2.m = na.m
	return na.ca2.AssignInt(v)
	return  schema.ErrNotUnionStructure{TypeName: "tasks.Any.Repr", Detail: "AssignInt called but is not valid for any of the kinds that are valid members of this union"}
}
func (na *_Any__ReprAssembler) AssignFloat(v float64) error  {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign into assembler that's already working on a larger structure!")
	}
	if na.w == nil {
		na.w = &_Any{}
	}
	na.ca = 3
	x := &_Float{}
	na.w.x = x
	if na.ca3 == nil {
		na.ca3 = &_Float__ReprAssembler{}
	}
	na.ca3.w = x
	na.ca3.m = na.m
	return na.ca3.AssignFloat(v)
	return  schema.ErrNotUnionStructure{TypeName: "tasks.Any.Repr", Detail: "AssignFloat called but is not valid for any of the kinds that are valid members of this union"}
}
func (na *_Any__ReprAssembler) AssignString(v string) error  {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign into assembler that's already working on a larger structure!")
	}
	if na.w == nil {
		na.w = &_Any{}
	}
	na.ca = 4
	x := &_String{}
	na.w.x = x
	if na.ca4 == nil {
		na.ca4 = &_String__ReprAssembler{}
	}
	na.ca4.w = x
	na.ca4.m = na.m
	return na.ca4.AssignString(v)
	return  schema.ErrNotUnionStructure{TypeName: "tasks.Any.Repr", Detail: "AssignString called but is not valid for any of the kinds that are valid members of this union"}
}
func (na *_Any__ReprAssembler) AssignBytes(v []byte) error  {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign into assembler that's already working on a larger structure!")
	}
	if na.w == nil {
		na.w = &_Any{}
	}
	na.ca = 5
	x := &_Bytes{}
	na.w.x = x
	if na.ca5 == nil {
		na.ca5 = &_Bytes__ReprAssembler{}
	}
	na.ca5.w = x
	na.ca5.m = na.m
	return na.ca5.AssignBytes(v)
	return  schema.ErrNotUnionStructure{TypeName: "tasks.Any.Repr", Detail: "AssignBytes called but is not valid for any of the kinds that are valid members of this union"}
}
func (na *_Any__ReprAssembler) AssignLink(v ipld.Link) error  {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign into assembler that's already working on a larger structure!")
	}
	if na.w == nil {
		na.w = &_Any{}
	}
	na.ca = 8
	x := &_Link{}
	na.w.x = x
	if na.ca8 == nil {
		na.ca8 = &_Link__ReprAssembler{}
	}
	na.ca8.w = x
	na.ca8.m = na.m
	return na.ca8.AssignLink(v)
	return  schema.ErrNotUnionStructure{TypeName: "tasks.Any.Repr", Detail: "AssignLink called but is not valid for any of the kinds that are valid members of this union"}
}
func (na *_Any__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Any); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	switch v.Kind() {
	case ipld.Kind_Bool:
		v2, _ := v.AsBool()
		return na.AssignBool(v2)
	case ipld.Kind_Int:
		v2, _ := v.AsInt()
		return na.AssignInt(v2)
	case ipld.Kind_Float:
		v2, _ := v.AsFloat()
		return na.AssignFloat(v2)
	case ipld.Kind_String:
		v2, _ := v.AsString()
		return na.AssignString(v2)
	case ipld.Kind_Bytes:
		v2, _ := v.AsBytes()
		return na.AssignBytes(v2)
	case ipld.Kind_Map:
		na, err := na.BeginMap(v.Length())
		if err != nil {
			return err
		}
		itr := v.MapIterator()
		for !itr.Done() {
			k, v, err := itr.Next()
			if err != nil {
				return err
			}
			if err := na.AssembleKey().AssignNode(k); err != nil {
				return err
			}
			if err := na.AssembleValue().AssignNode(v); err != nil {
				return err
			}
		}
		return na.Finish()
	case ipld.Kind_List:
		na, err := na.BeginList(v.Length())
		if err != nil {
			return err
		}
		itr := v.ListIterator()
		for !itr.Done() {
			_, v, err := itr.Next()
			if err != nil {
				return err
			}
			if err := na.AssembleValue().AssignNode(v); err != nil {
				return err
			}
		}
		return na.Finish()
	case ipld.Kind_Link:
		v2, _ := v.AsLink()
		return na.AssignLink(v2)
	default:
		panic("unreachable")
	}
}
func (na *_Any__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Any__ReprPrototype{}
}


func (n _AuthenticatedRecord) FieldRecord() Link_FinishedTask {
	return &n.Record
}
func (n _AuthenticatedRecord) FieldSignature() Bytes {
	return &n.Signature
}
type _AuthenticatedRecord__Maybe struct {
	m schema.Maybe
	v AuthenticatedRecord
}
type MaybeAuthenticatedRecord = *_AuthenticatedRecord__Maybe

func (m MaybeAuthenticatedRecord) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeAuthenticatedRecord) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeAuthenticatedRecord) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeAuthenticatedRecord) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeAuthenticatedRecord) Must() AuthenticatedRecord {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
	fieldName__AuthenticatedRecord_Record = _String{"Record"}
	fieldName__AuthenticatedRecord_Signature = _String{"Signature"}
)
var _ ipld.Node = (AuthenticatedRecord)(&_AuthenticatedRecord{})
var _ schema.TypedNode = (AuthenticatedRecord)(&_AuthenticatedRecord{})
func (AuthenticatedRecord) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n AuthenticatedRecord) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Record":
		return &n.Record, nil
	case "Signature":
		return &n.Signature, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n AuthenticatedRecord) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (AuthenticatedRecord) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"tasks.AuthenticatedRecord"}.LookupByIndex(0)
}
func (n AuthenticatedRecord) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n AuthenticatedRecord) MapIterator() ipld.MapIterator {
	return &_AuthenticatedRecord__MapItr{n, 0}
}

type _AuthenticatedRecord__MapItr struct {
	n AuthenticatedRecord
	idx  int
}

func (itr *_AuthenticatedRecord__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__AuthenticatedRecord_Record
		v = &itr.n.Record
	case 1:
		k = &fieldName__AuthenticatedRecord_Signature
		v = &itr.n.Signature
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_AuthenticatedRecord__MapItr) Done() bool {
	return itr.idx >= 2
}

func (AuthenticatedRecord) ListIterator() ipld.ListIterator {
	return nil
}
func (AuthenticatedRecord) Length() int64 {
	return 2
}
func (AuthenticatedRecord) IsAbsent() bool {
	return false
}
func (AuthenticatedRecord) IsNull() bool {
	return false
}
func (AuthenticatedRecord) AsBool() (bool, error) {
	return mixins.Map{"tasks.AuthenticatedRecord"}.AsBool()
}
func (AuthenticatedRecord) AsInt() (int64, error) {
	return mixins.Map{"tasks.AuthenticatedRecord"}.AsInt()
}
func (AuthenticatedRecord) AsFloat() (float64, error) {
	return mixins.Map{"tasks.AuthenticatedRecord"}.AsFloat()
}
func (AuthenticatedRecord) AsString() (string, error) {
	return mixins.Map{"tasks.AuthenticatedRecord"}.AsString()
}
func (AuthenticatedRecord) AsBytes() ([]byte, error) {
	return mixins.Map{"tasks.AuthenticatedRecord"}.AsBytes()
}
func (AuthenticatedRecord) AsLink() (ipld.Link, error) {
	return mixins.Map{"tasks.AuthenticatedRecord"}.AsLink()
}
func (AuthenticatedRecord) Prototype() ipld.NodePrototype {
	return _AuthenticatedRecord__Prototype{}
}
type _AuthenticatedRecord__Prototype struct{}

func (_AuthenticatedRecord__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _AuthenticatedRecord__Builder
	nb.Reset()
	return &nb
}
type _AuthenticatedRecord__Builder struct {
	_AuthenticatedRecord__Assembler
}
func (nb *_AuthenticatedRecord__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_AuthenticatedRecord__Builder) Reset() {
	var w _AuthenticatedRecord
	var m schema.Maybe
	*nb = _AuthenticatedRecord__Builder{_AuthenticatedRecord__Assembler{w: &w, m: &m}}
}
type _AuthenticatedRecord__Assembler struct {
	w *_AuthenticatedRecord
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_Record _Link_FinishedTask__Assembler
	ca_Signature _Bytes__Assembler
	}

func (na *_AuthenticatedRecord__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Record.reset()
	na.ca_Signature.reset()
}

var (
	fieldBit__AuthenticatedRecord_Record = 1 << 0
	fieldBit__AuthenticatedRecord_Signature = 1 << 1
	fieldBits__AuthenticatedRecord_sufficient = 0 + 1 << 0 + 1 << 1
)
func (na *_AuthenticatedRecord__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_AuthenticatedRecord{}
	}
	return na, nil
}
func (_AuthenticatedRecord__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"tasks.AuthenticatedRecord"}.BeginList(0)
}
func (na *_AuthenticatedRecord__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"tasks.AuthenticatedRecord"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_AuthenticatedRecord__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"tasks.AuthenticatedRecord"}.AssignBool(false)
}
func (_AuthenticatedRecord__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"tasks.AuthenticatedRecord"}.AssignInt(0)
}
func (_AuthenticatedRecord__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"tasks.AuthenticatedRecord"}.AssignFloat(0)
}
func (_AuthenticatedRecord__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"tasks.AuthenticatedRecord"}.AssignString("")
}
func (_AuthenticatedRecord__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"tasks.AuthenticatedRecord"}.AssignBytes(nil)
}
func (_AuthenticatedRecord__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"tasks.AuthenticatedRecord"}.AssignLink(nil)
}
func (na *_AuthenticatedRecord__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_AuthenticatedRecord); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "tasks.AuthenticatedRecord", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_AuthenticatedRecord__Assembler) Prototype() ipld.NodePrototype {
	return _AuthenticatedRecord__Prototype{}
}
func (ma *_AuthenticatedRecord__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Record.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Signature.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_AuthenticatedRecord__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Record":
		if ma.s & fieldBit__AuthenticatedRecord_Record != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__AuthenticatedRecord_Record}
		}
		ma.s += fieldBit__AuthenticatedRecord_Record
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Record.w = &ma.w.Record
		ma.ca_Record.m = &ma.cm
		return &ma.ca_Record, nil
	case "Signature":
		if ma.s & fieldBit__AuthenticatedRecord_Signature != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__AuthenticatedRecord_Signature}
		}
		ma.s += fieldBit__AuthenticatedRecord_Signature
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Signature.w = &ma.w.Signature
		ma.ca_Signature.m = &ma.cm
		return &ma.ca_Signature, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"tasks.AuthenticatedRecord", Key:&_String{k}}
	}
}
func (ma *_AuthenticatedRecord__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_AuthenticatedRecord__KeyAssembler)(ma)
}
func (ma *_AuthenticatedRecord__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Record.w = &ma.w.Record
		ma.ca_Record.m = &ma.cm
		return &ma.ca_Record
	case 1:
		ma.ca_Signature.w = &ma.w.Signature
		ma.ca_Signature.m = &ma.cm
		return &ma.ca_Signature
	default:
		panic("unreachable")
	}
}
func (ma *_AuthenticatedRecord__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s & fieldBits__AuthenticatedRecord_sufficient != fieldBits__AuthenticatedRecord_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s & fieldBit__AuthenticatedRecord_Record == 0 {
			err.Missing = append(err.Missing, "Record")
		}
		if ma.s & fieldBit__AuthenticatedRecord_Signature == 0 {
			err.Missing = append(err.Missing, "Signature")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_AuthenticatedRecord__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_AuthenticatedRecord__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}
type _AuthenticatedRecord__KeyAssembler _AuthenticatedRecord__Assembler
func (_AuthenticatedRecord__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"tasks.AuthenticatedRecord.KeyAssembler"}.BeginMap(0)
}
func (_AuthenticatedRecord__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"tasks.AuthenticatedRecord.KeyAssembler"}.BeginList(0)
}
func (na *_AuthenticatedRecord__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"tasks.AuthenticatedRecord.KeyAssembler"}.AssignNull()
}
func (_AuthenticatedRecord__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"tasks.AuthenticatedRecord.KeyAssembler"}.AssignBool(false)
}
func (_AuthenticatedRecord__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"tasks.AuthenticatedRecord.KeyAssembler"}.AssignInt(0)
}
func (_AuthenticatedRecord__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"tasks.AuthenticatedRecord.KeyAssembler"}.AssignFloat(0)
}
func (ka *_AuthenticatedRecord__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Record":
		if ka.s & fieldBit__AuthenticatedRecord_Record != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__AuthenticatedRecord_Record}
		}
		ka.s += fieldBit__AuthenticatedRecord_Record
		ka.state = maState_expectValue
		ka.f = 0
	case "Signature":
		if ka.s & fieldBit__AuthenticatedRecord_Signature != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__AuthenticatedRecord_Signature}
		}
		ka.s += fieldBit__AuthenticatedRecord_Signature
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName:"tasks.AuthenticatedRecord", Key:&_String{k}}
	}
	return nil
}
func (_AuthenticatedRecord__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"tasks.AuthenticatedRecord.KeyAssembler"}.AssignBytes(nil)
}
func (_AuthenticatedRecord__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"tasks.AuthenticatedRecord.KeyAssembler"}.AssignLink(nil)
}
func (ka *_AuthenticatedRecord__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_AuthenticatedRecord__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (AuthenticatedRecord) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n AuthenticatedRecord) Representation() ipld.Node {
	return (*_AuthenticatedRecord__Repr)(n)
}
type _AuthenticatedRecord__Repr _AuthenticatedRecord
var (
	fieldName__AuthenticatedRecord_Record_serial = _String{"Record"}
	fieldName__AuthenticatedRecord_Signature_serial = _String{"Signature"}
)
var _ ipld.Node = &_AuthenticatedRecord__Repr{}
func (_AuthenticatedRecord__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_AuthenticatedRecord__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Record":
		return n.Record.Representation(), nil
	case "Signature":
		return n.Signature.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_AuthenticatedRecord__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_AuthenticatedRecord__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"tasks.AuthenticatedRecord.Repr"}.LookupByIndex(0)
}
func (n _AuthenticatedRecord__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_AuthenticatedRecord__Repr) MapIterator() ipld.MapIterator {
	return &_AuthenticatedRecord__ReprMapItr{n, 0}
}

type _AuthenticatedRecord__ReprMapItr struct {
	n   *_AuthenticatedRecord__Repr
	idx int
	
}

func (itr *_AuthenticatedRecord__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__AuthenticatedRecord_Record_serial
		v = itr.n.Record.Representation()
	case 1:
		k = &fieldName__AuthenticatedRecord_Signature_serial
		v = itr.n.Signature.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_AuthenticatedRecord__ReprMapItr) Done() bool {
	return itr.idx >= 2
}
func (_AuthenticatedRecord__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_AuthenticatedRecord__Repr) Length() int64 {
	l := 2
	return int64(l)
}
func (_AuthenticatedRecord__Repr) IsAbsent() bool {
	return false
}
func (_AuthenticatedRecord__Repr) IsNull() bool {
	return false
}
func (_AuthenticatedRecord__Repr) AsBool() (bool, error) {
	return mixins.Map{"tasks.AuthenticatedRecord.Repr"}.AsBool()
}
func (_AuthenticatedRecord__Repr) AsInt() (int64, error) {
	return mixins.Map{"tasks.AuthenticatedRecord.Repr"}.AsInt()
}
func (_AuthenticatedRecord__Repr) AsFloat() (float64, error) {
	return mixins.Map{"tasks.AuthenticatedRecord.Repr"}.AsFloat()
}
func (_AuthenticatedRecord__Repr) AsString() (string, error) {
	return mixins.Map{"tasks.AuthenticatedRecord.Repr"}.AsString()
}
func (_AuthenticatedRecord__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"tasks.AuthenticatedRecord.Repr"}.AsBytes()
}
func (_AuthenticatedRecord__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"tasks.AuthenticatedRecord.Repr"}.AsLink()
}
func (_AuthenticatedRecord__Repr) Prototype() ipld.NodePrototype {
	return _AuthenticatedRecord__ReprPrototype{}
}
type _AuthenticatedRecord__ReprPrototype struct{}

func (_AuthenticatedRecord__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _AuthenticatedRecord__ReprBuilder
	nb.Reset()
	return &nb
}
type _AuthenticatedRecord__ReprBuilder struct {
	_AuthenticatedRecord__ReprAssembler
}
func (nb *_AuthenticatedRecord__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_AuthenticatedRecord__ReprBuilder) Reset() {
	var w _AuthenticatedRecord
	var m schema.Maybe
	*nb = _AuthenticatedRecord__ReprBuilder{_AuthenticatedRecord__ReprAssembler{w: &w, m: &m}}
}
type _AuthenticatedRecord__ReprAssembler struct {
	w *_AuthenticatedRecord
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_Record _Link_FinishedTask__ReprAssembler
	ca_Signature _Bytes__ReprAssembler
	}

func (na *_AuthenticatedRecord__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Record.reset()
	na.ca_Signature.reset()
}
func (na *_AuthenticatedRecord__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_AuthenticatedRecord{}
	}
	return na, nil
}
func (_AuthenticatedRecord__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"tasks.AuthenticatedRecord.Repr"}.BeginList(0)
}
func (na *_AuthenticatedRecord__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"tasks.AuthenticatedRecord.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_AuthenticatedRecord__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"tasks.AuthenticatedRecord.Repr"}.AssignBool(false)
}
func (_AuthenticatedRecord__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"tasks.AuthenticatedRecord.Repr"}.AssignInt(0)
}
func (_AuthenticatedRecord__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"tasks.AuthenticatedRecord.Repr"}.AssignFloat(0)
}
func (_AuthenticatedRecord__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"tasks.AuthenticatedRecord.Repr"}.AssignString("")
}
func (_AuthenticatedRecord__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"tasks.AuthenticatedRecord.Repr"}.AssignBytes(nil)
}
func (_AuthenticatedRecord__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"tasks.AuthenticatedRecord.Repr"}.AssignLink(nil)
}
func (na *_AuthenticatedRecord__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_AuthenticatedRecord); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "tasks.AuthenticatedRecord.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_AuthenticatedRecord__ReprAssembler) Prototype() ipld.NodePrototype {
	return _AuthenticatedRecord__ReprPrototype{}
}
func (ma *_AuthenticatedRecord__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_AuthenticatedRecord__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Record":
		if ma.s & fieldBit__AuthenticatedRecord_Record != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__AuthenticatedRecord_Record_serial}
		}
		ma.s += fieldBit__AuthenticatedRecord_Record
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Record.w = &ma.w.Record
		ma.ca_Record.m = &ma.cm
		return &ma.ca_Record, nil
	case "Signature":
		if ma.s & fieldBit__AuthenticatedRecord_Signature != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__AuthenticatedRecord_Signature_serial}
		}
		ma.s += fieldBit__AuthenticatedRecord_Signature
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Signature.w = &ma.w.Signature
		ma.ca_Signature.m = &ma.cm
		return &ma.ca_Signature, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"tasks.AuthenticatedRecord.Repr", Key:&_String{k}}
	}
}
func (ma *_AuthenticatedRecord__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_AuthenticatedRecord__ReprKeyAssembler)(ma)
}
func (ma *_AuthenticatedRecord__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Record.w = &ma.w.Record
		ma.ca_Record.m = &ma.cm
		return &ma.ca_Record
	case 1:
		ma.ca_Signature.w = &ma.w.Signature
		ma.ca_Signature.m = &ma.cm
		return &ma.ca_Signature
	default:
		panic("unreachable")
	}
}
func (ma *_AuthenticatedRecord__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s & fieldBits__AuthenticatedRecord_sufficient != fieldBits__AuthenticatedRecord_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s & fieldBit__AuthenticatedRecord_Record == 0 {
			err.Missing = append(err.Missing, "Record")
		}
		if ma.s & fieldBit__AuthenticatedRecord_Signature == 0 {
			err.Missing = append(err.Missing, "Signature")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_AuthenticatedRecord__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_AuthenticatedRecord__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}
type _AuthenticatedRecord__ReprKeyAssembler _AuthenticatedRecord__ReprAssembler
func (_AuthenticatedRecord__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"tasks.AuthenticatedRecord.Repr.KeyAssembler"}.BeginMap(0)
}
func (_AuthenticatedRecord__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"tasks.AuthenticatedRecord.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_AuthenticatedRecord__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"tasks.AuthenticatedRecord.Repr.KeyAssembler"}.AssignNull()
}
func (_AuthenticatedRecord__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"tasks.AuthenticatedRecord.Repr.KeyAssembler"}.AssignBool(false)
}
func (_AuthenticatedRecord__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"tasks.AuthenticatedRecord.Repr.KeyAssembler"}.AssignInt(0)
}
func (_AuthenticatedRecord__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"tasks.AuthenticatedRecord.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_AuthenticatedRecord__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Record":
		if ka.s & fieldBit__AuthenticatedRecord_Record != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__AuthenticatedRecord_Record_serial}
		}
		ka.s += fieldBit__AuthenticatedRecord_Record
		ka.state = maState_expectValue
		ka.f = 0
	case "Signature":
		if ka.s & fieldBit__AuthenticatedRecord_Signature != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__AuthenticatedRecord_Signature_serial}
		}
		ka.s += fieldBit__AuthenticatedRecord_Signature
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName:"tasks.AuthenticatedRecord.Repr", Key:&_String{k}}
	}
	return nil
}
func (_AuthenticatedRecord__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"tasks.AuthenticatedRecord.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_AuthenticatedRecord__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"tasks.AuthenticatedRecord.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_AuthenticatedRecord__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_AuthenticatedRecord__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n Bool) Bool() bool {
	return n.x
}
func (_Bool__Prototype) FromBool(v bool) (Bool, error) {
	n := _Bool{v}
	return &n, nil
}
type _Bool__Maybe struct {
	m schema.Maybe
	v Bool
}
type MaybeBool = *_Bool__Maybe

func (m MaybeBool) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeBool) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeBool) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeBool) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeBool) Must() Bool {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var _ ipld.Node = (Bool)(&_Bool{})
var _ schema.TypedNode = (Bool)(&_Bool{})
func (Bool) Kind() ipld.Kind {
	return ipld.Kind_Bool
}
func (Bool) LookupByString(string) (ipld.Node, error) {
	return mixins.Bool{"tasks.Bool"}.LookupByString("")
}
func (Bool) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Bool{"tasks.Bool"}.LookupByNode(nil)
}
func (Bool) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Bool{"tasks.Bool"}.LookupByIndex(0)
}
func (Bool) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Bool{"tasks.Bool"}.LookupBySegment(seg)
}
func (Bool) MapIterator() ipld.MapIterator {
	return nil
}
func (Bool) ListIterator() ipld.ListIterator {
	return nil
}
func (Bool) Length() int64 {
	return -1
}
func (Bool) IsAbsent() bool {
	return false
}
func (Bool) IsNull() bool {
	return false
}
func (n Bool) AsBool() (bool, error) {
	return n.x, nil
}
func (Bool) AsInt() (int64, error) {
	return mixins.Bool{"tasks.Bool"}.AsInt()
}
func (Bool) AsFloat() (float64, error) {
	return mixins.Bool{"tasks.Bool"}.AsFloat()
}
func (Bool) AsString() (string, error) {
	return mixins.Bool{"tasks.Bool"}.AsString()
}
func (Bool) AsBytes() ([]byte, error) {
	return mixins.Bool{"tasks.Bool"}.AsBytes()
}
func (Bool) AsLink() (ipld.Link, error) {
	return mixins.Bool{"tasks.Bool"}.AsLink()
}
func (Bool) Prototype() ipld.NodePrototype {
	return _Bool__Prototype{}
}
type _Bool__Prototype struct{}

func (_Bool__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Bool__Builder
	nb.Reset()
	return &nb
}
type _Bool__Builder struct {
	_Bool__Assembler
}
func (nb *_Bool__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Bool__Builder) Reset() {
	var w _Bool
	var m schema.Maybe
	*nb = _Bool__Builder{_Bool__Assembler{w: &w, m: &m}}
}
type _Bool__Assembler struct {
	w *_Bool
	m *schema.Maybe
}

func (na *_Bool__Assembler) reset() {}
func (_Bool__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.BoolAssembler{"tasks.Bool"}.BeginMap(0)
}
func (_Bool__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.BoolAssembler{"tasks.Bool"}.BeginList(0)
}
func (na *_Bool__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.BoolAssembler{"tasks.Bool"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (na *_Bool__Assembler) AssignBool(v bool) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_Bool{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_Bool__Assembler) AssignInt(int64) error {
	return mixins.BoolAssembler{"tasks.Bool"}.AssignInt(0)
}
func (_Bool__Assembler) AssignFloat(float64) error {
	return mixins.BoolAssembler{"tasks.Bool"}.AssignFloat(0)
}
func (_Bool__Assembler) AssignString(string) error {
	return mixins.BoolAssembler{"tasks.Bool"}.AssignString("")
}
func (_Bool__Assembler) AssignBytes([]byte) error {
	return mixins.BoolAssembler{"tasks.Bool"}.AssignBytes(nil)
}
func (_Bool__Assembler) AssignLink(ipld.Link) error {
	return mixins.BoolAssembler{"tasks.Bool"}.AssignLink(nil)
}
func (na *_Bool__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Bool); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsBool(); err != nil {
		return err
	} else {
		return na.AssignBool(v2)
	}
}
func (_Bool__Assembler) Prototype() ipld.NodePrototype {
	return _Bool__Prototype{}
}
func (Bool) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Bool) Representation() ipld.Node {
	return (*_Bool__Repr)(n)
}
type _Bool__Repr = _Bool
var _ ipld.Node = &_Bool__Repr{}
type _Bool__ReprPrototype = _Bool__Prototype
type _Bool__ReprAssembler = _Bool__Assembler

func (n Bytes) Bytes() []byte {
	return n.x
}
func (_Bytes__Prototype) FromBytes(v []byte) (Bytes, error) {
	n := _Bytes{v}
	return &n, nil
}
type _Bytes__Maybe struct {
	m schema.Maybe
	v Bytes
}
type MaybeBytes = *_Bytes__Maybe

func (m MaybeBytes) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeBytes) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeBytes) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeBytes) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeBytes) Must() Bytes {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var _ ipld.Node = (Bytes)(&_Bytes{})
var _ schema.TypedNode = (Bytes)(&_Bytes{})
func (Bytes) Kind() ipld.Kind {
	return ipld.Kind_Bytes
}
func (Bytes) LookupByString(string) (ipld.Node, error) {
	return mixins.Bytes{"tasks.Bytes"}.LookupByString("")
}
func (Bytes) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Bytes{"tasks.Bytes"}.LookupByNode(nil)
}
func (Bytes) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Bytes{"tasks.Bytes"}.LookupByIndex(0)
}
func (Bytes) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Bytes{"tasks.Bytes"}.LookupBySegment(seg)
}
func (Bytes) MapIterator() ipld.MapIterator {
	return nil
}
func (Bytes) ListIterator() ipld.ListIterator {
	return nil
}
func (Bytes) Length() int64 {
	return -1
}
func (Bytes) IsAbsent() bool {
	return false
}
func (Bytes) IsNull() bool {
	return false
}
func (Bytes) AsBool() (bool, error) {
	return mixins.Bytes{"tasks.Bytes"}.AsBool()
}
func (Bytes) AsInt() (int64, error) {
	return mixins.Bytes{"tasks.Bytes"}.AsInt()
}
func (Bytes) AsFloat() (float64, error) {
	return mixins.Bytes{"tasks.Bytes"}.AsFloat()
}
func (Bytes) AsString() (string, error) {
	return mixins.Bytes{"tasks.Bytes"}.AsString()
}
func (n Bytes) AsBytes() ([]byte, error) {
	return n.x, nil
}
func (Bytes) AsLink() (ipld.Link, error) {
	return mixins.Bytes{"tasks.Bytes"}.AsLink()
}
func (Bytes) Prototype() ipld.NodePrototype {
	return _Bytes__Prototype{}
}
type _Bytes__Prototype struct{}

func (_Bytes__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Bytes__Builder
	nb.Reset()
	return &nb
}
type _Bytes__Builder struct {
	_Bytes__Assembler
}
func (nb *_Bytes__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Bytes__Builder) Reset() {
	var w _Bytes
	var m schema.Maybe
	*nb = _Bytes__Builder{_Bytes__Assembler{w: &w, m: &m}}
}
type _Bytes__Assembler struct {
	w *_Bytes
	m *schema.Maybe
}

func (na *_Bytes__Assembler) reset() {}
func (_Bytes__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.BytesAssembler{"tasks.Bytes"}.BeginMap(0)
}
func (_Bytes__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.BytesAssembler{"tasks.Bytes"}.BeginList(0)
}
func (na *_Bytes__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.BytesAssembler{"tasks.Bytes"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_Bytes__Assembler) AssignBool(bool) error {
	return mixins.BytesAssembler{"tasks.Bytes"}.AssignBool(false)
}
func (_Bytes__Assembler) AssignInt(int64) error {
	return mixins.BytesAssembler{"tasks.Bytes"}.AssignInt(0)
}
func (_Bytes__Assembler) AssignFloat(float64) error {
	return mixins.BytesAssembler{"tasks.Bytes"}.AssignFloat(0)
}
func (_Bytes__Assembler) AssignString(string) error {
	return mixins.BytesAssembler{"tasks.Bytes"}.AssignString("")
}
func (na *_Bytes__Assembler) AssignBytes(v []byte) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_Bytes{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_Bytes__Assembler) AssignLink(ipld.Link) error {
	return mixins.BytesAssembler{"tasks.Bytes"}.AssignLink(nil)
}
func (na *_Bytes__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Bytes); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsBytes(); err != nil {
		return err
	} else {
		return na.AssignBytes(v2)
	}
}
func (_Bytes__Assembler) Prototype() ipld.NodePrototype {
	return _Bytes__Prototype{}
}
func (Bytes) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Bytes) Representation() ipld.Node {
	return (*_Bytes__Repr)(n)
}
type _Bytes__Repr = _Bytes
var _ ipld.Node = &_Bytes__Repr{}
type _Bytes__ReprPrototype = _Bytes__Prototype
type _Bytes__ReprAssembler = _Bytes__Assembler


func (n _FinishedTask) FieldStatus() Status {
	return &n.Status
}
func (n _FinishedTask) FieldStartedAt() Time {
	return &n.StartedAt
}
func (n _FinishedTask) FieldErrorMessage() MaybeString {
	return &n.ErrorMessage
}
func (n _FinishedTask) FieldRetrievalTask() MaybeRetrievalTask {
	return &n.RetrievalTask
}
func (n _FinishedTask) FieldStorageTask() MaybeStorageTask {
	return &n.StorageTask
}
func (n _FinishedTask) FieldDealID() Int {
	return &n.DealID
}
func (n _FinishedTask) FieldMinerMultiAddr() String {
	return &n.MinerMultiAddr
}
func (n _FinishedTask) FieldClientApparentAddr() String {
	return &n.ClientApparentAddr
}
func (n _FinishedTask) FieldMinerLatencyMS() MaybeInt {
	return &n.MinerLatencyMS
}
func (n _FinishedTask) FieldTimeToFirstByteMS() MaybeInt {
	return &n.TimeToFirstByteMS
}
func (n _FinishedTask) FieldTimeToLastByteMS() MaybeInt {
	return &n.TimeToLastByteMS
}
func (n _FinishedTask) FieldEvents() Link_List_StageDetails {
	return &n.Events
}
type _FinishedTask__Maybe struct {
	m schema.Maybe
	v FinishedTask
}
type MaybeFinishedTask = *_FinishedTask__Maybe

func (m MaybeFinishedTask) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeFinishedTask) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeFinishedTask) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeFinishedTask) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeFinishedTask) Must() FinishedTask {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
	fieldName__FinishedTask_Status = _String{"Status"}
	fieldName__FinishedTask_StartedAt = _String{"StartedAt"}
	fieldName__FinishedTask_ErrorMessage = _String{"ErrorMessage"}
	fieldName__FinishedTask_RetrievalTask = _String{"RetrievalTask"}
	fieldName__FinishedTask_StorageTask = _String{"StorageTask"}
	fieldName__FinishedTask_DealID = _String{"DealID"}
	fieldName__FinishedTask_MinerMultiAddr = _String{"MinerMultiAddr"}
	fieldName__FinishedTask_ClientApparentAddr = _String{"ClientApparentAddr"}
	fieldName__FinishedTask_MinerLatencyMS = _String{"MinerLatencyMS"}
	fieldName__FinishedTask_TimeToFirstByteMS = _String{"TimeToFirstByteMS"}
	fieldName__FinishedTask_TimeToLastByteMS = _String{"TimeToLastByteMS"}
	fieldName__FinishedTask_Events = _String{"Events"}
)
var _ ipld.Node = (FinishedTask)(&_FinishedTask{})
var _ schema.TypedNode = (FinishedTask)(&_FinishedTask{})
func (FinishedTask) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n FinishedTask) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Status":
		return &n.Status, nil
	case "StartedAt":
		return &n.StartedAt, nil
	case "ErrorMessage":
		if n.ErrorMessage.m == schema.Maybe_Absent {
			return ipld.Absent, nil
		}
		return n.ErrorMessage.v, nil
	case "RetrievalTask":
		if n.RetrievalTask.m == schema.Maybe_Absent {
			return ipld.Absent, nil
		}
		return n.RetrievalTask.v, nil
	case "StorageTask":
		if n.StorageTask.m == schema.Maybe_Absent {
			return ipld.Absent, nil
		}
		return n.StorageTask.v, nil
	case "DealID":
		return &n.DealID, nil
	case "MinerMultiAddr":
		return &n.MinerMultiAddr, nil
	case "ClientApparentAddr":
		return &n.ClientApparentAddr, nil
	case "MinerLatencyMS":
		if n.MinerLatencyMS.m == schema.Maybe_Absent {
			return ipld.Absent, nil
		}
		return n.MinerLatencyMS.v, nil
	case "TimeToFirstByteMS":
		if n.TimeToFirstByteMS.m == schema.Maybe_Absent {
			return ipld.Absent, nil
		}
		return n.TimeToFirstByteMS.v, nil
	case "TimeToLastByteMS":
		if n.TimeToLastByteMS.m == schema.Maybe_Absent {
			return ipld.Absent, nil
		}
		return n.TimeToLastByteMS.v, nil
	case "Events":
		return &n.Events, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n FinishedTask) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (FinishedTask) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"tasks.FinishedTask"}.LookupByIndex(0)
}
func (n FinishedTask) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n FinishedTask) MapIterator() ipld.MapIterator {
	return &_FinishedTask__MapItr{n, 0}
}

type _FinishedTask__MapItr struct {
	n FinishedTask
	idx  int
}

func (itr *_FinishedTask__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 12 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__FinishedTask_Status
		v = &itr.n.Status
	case 1:
		k = &fieldName__FinishedTask_StartedAt
		v = &itr.n.StartedAt
	case 2:
		k = &fieldName__FinishedTask_ErrorMessage
		if itr.n.ErrorMessage.m == schema.Maybe_Absent {
			v = ipld.Absent
			break
		}
		v = itr.n.ErrorMessage.v
	case 3:
		k = &fieldName__FinishedTask_RetrievalTask
		if itr.n.RetrievalTask.m == schema.Maybe_Absent {
			v = ipld.Absent
			break
		}
		v = itr.n.RetrievalTask.v
	case 4:
		k = &fieldName__FinishedTask_StorageTask
		if itr.n.StorageTask.m == schema.Maybe_Absent {
			v = ipld.Absent
			break
		}
		v = itr.n.StorageTask.v
	case 5:
		k = &fieldName__FinishedTask_DealID
		v = &itr.n.DealID
	case 6:
		k = &fieldName__FinishedTask_MinerMultiAddr
		v = &itr.n.MinerMultiAddr
	case 7:
		k = &fieldName__FinishedTask_ClientApparentAddr
		v = &itr.n.ClientApparentAddr
	case 8:
		k = &fieldName__FinishedTask_MinerLatencyMS
		if itr.n.MinerLatencyMS.m == schema.Maybe_Absent {
			v = ipld.Absent
			break
		}
		v = itr.n.MinerLatencyMS.v
	case 9:
		k = &fieldName__FinishedTask_TimeToFirstByteMS
		if itr.n.TimeToFirstByteMS.m == schema.Maybe_Absent {
			v = ipld.Absent
			break
		}
		v = itr.n.TimeToFirstByteMS.v
	case 10:
		k = &fieldName__FinishedTask_TimeToLastByteMS
		if itr.n.TimeToLastByteMS.m == schema.Maybe_Absent {
			v = ipld.Absent
			break
		}
		v = itr.n.TimeToLastByteMS.v
	case 11:
		k = &fieldName__FinishedTask_Events
		v = &itr.n.Events
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_FinishedTask__MapItr) Done() bool {
	return itr.idx >= 12
}

func (FinishedTask) ListIterator() ipld.ListIterator {
	return nil
}
func (FinishedTask) Length() int64 {
	return 12
}
func (FinishedTask) IsAbsent() bool {
	return false
}
func (FinishedTask) IsNull() bool {
	return false
}
func (FinishedTask) AsBool() (bool, error) {
	return mixins.Map{"tasks.FinishedTask"}.AsBool()
}
func (FinishedTask) AsInt() (int64, error) {
	return mixins.Map{"tasks.FinishedTask"}.AsInt()
}
func (FinishedTask) AsFloat() (float64, error) {
	return mixins.Map{"tasks.FinishedTask"}.AsFloat()
}
func (FinishedTask) AsString() (string, error) {
	return mixins.Map{"tasks.FinishedTask"}.AsString()
}
func (FinishedTask) AsBytes() ([]byte, error) {
	return mixins.Map{"tasks.FinishedTask"}.AsBytes()
}
func (FinishedTask) AsLink() (ipld.Link, error) {
	return mixins.Map{"tasks.FinishedTask"}.AsLink()
}
func (FinishedTask) Prototype() ipld.NodePrototype {
	return _FinishedTask__Prototype{}
}
type _FinishedTask__Prototype struct{}

func (_FinishedTask__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _FinishedTask__Builder
	nb.Reset()
	return &nb
}
type _FinishedTask__Builder struct {
	_FinishedTask__Assembler
}
func (nb *_FinishedTask__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_FinishedTask__Builder) Reset() {
	var w _FinishedTask
	var m schema.Maybe
	*nb = _FinishedTask__Builder{_FinishedTask__Assembler{w: &w, m: &m}}
}
type _FinishedTask__Assembler struct {
	w *_FinishedTask
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_Status _Status__Assembler
	ca_StartedAt _Time__Assembler
	ca_ErrorMessage _String__Assembler
	ca_RetrievalTask _RetrievalTask__Assembler
	ca_StorageTask _StorageTask__Assembler
	ca_DealID _Int__Assembler
	ca_MinerMultiAddr _String__Assembler
	ca_ClientApparentAddr _String__Assembler
	ca_MinerLatencyMS _Int__Assembler
	ca_TimeToFirstByteMS _Int__Assembler
	ca_TimeToLastByteMS _Int__Assembler
	ca_Events _Link_List_StageDetails__Assembler
	}

func (na *_FinishedTask__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Status.reset()
	na.ca_StartedAt.reset()
	na.ca_ErrorMessage.reset()
	na.ca_RetrievalTask.reset()
	na.ca_StorageTask.reset()
	na.ca_DealID.reset()
	na.ca_MinerMultiAddr.reset()
	na.ca_ClientApparentAddr.reset()
	na.ca_MinerLatencyMS.reset()
	na.ca_TimeToFirstByteMS.reset()
	na.ca_TimeToLastByteMS.reset()
	na.ca_Events.reset()
}

var (
	fieldBit__FinishedTask_Status = 1 << 0
	fieldBit__FinishedTask_StartedAt = 1 << 1
	fieldBit__FinishedTask_ErrorMessage = 1 << 2
	fieldBit__FinishedTask_RetrievalTask = 1 << 3
	fieldBit__FinishedTask_StorageTask = 1 << 4
	fieldBit__FinishedTask_DealID = 1 << 5
	fieldBit__FinishedTask_MinerMultiAddr = 1 << 6
	fieldBit__FinishedTask_ClientApparentAddr = 1 << 7
	fieldBit__FinishedTask_MinerLatencyMS = 1 << 8
	fieldBit__FinishedTask_TimeToFirstByteMS = 1 << 9
	fieldBit__FinishedTask_TimeToLastByteMS = 1 << 10
	fieldBit__FinishedTask_Events = 1 << 11
	fieldBits__FinishedTask_sufficient = 0 + 1 << 0 + 1 << 1 + 1 << 5 + 1 << 6 + 1 << 7 + 1 << 11
)
func (na *_FinishedTask__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_FinishedTask{}
	}
	return na, nil
}
func (_FinishedTask__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"tasks.FinishedTask"}.BeginList(0)
}
func (na *_FinishedTask__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"tasks.FinishedTask"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_FinishedTask__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"tasks.FinishedTask"}.AssignBool(false)
}
func (_FinishedTask__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"tasks.FinishedTask"}.AssignInt(0)
}
func (_FinishedTask__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"tasks.FinishedTask"}.AssignFloat(0)
}
func (_FinishedTask__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"tasks.FinishedTask"}.AssignString("")
}
func (_FinishedTask__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"tasks.FinishedTask"}.AssignBytes(nil)
}
func (_FinishedTask__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"tasks.FinishedTask"}.AssignLink(nil)
}
func (na *_FinishedTask__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_FinishedTask); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "tasks.FinishedTask", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_FinishedTask__Assembler) Prototype() ipld.NodePrototype {
	return _FinishedTask__Prototype{}
}
func (ma *_FinishedTask__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Status.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_StartedAt.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.w.ErrorMessage.m {
		case schema.Maybe_Value:
			ma.w.ErrorMessage.v = ma.ca_ErrorMessage.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.w.RetrievalTask.m {
		case schema.Maybe_Value:
			ma.w.RetrievalTask.v = ma.ca_RetrievalTask.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.w.StorageTask.m {
		case schema.Maybe_Value:
			ma.w.StorageTask.v = ma.ca_StorageTask.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 5:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_DealID.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 6:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_MinerMultiAddr.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 7:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_ClientApparentAddr.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 8:
		switch ma.w.MinerLatencyMS.m {
		case schema.Maybe_Value:
			ma.w.MinerLatencyMS.v = ma.ca_MinerLatencyMS.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 9:
		switch ma.w.TimeToFirstByteMS.m {
		case schema.Maybe_Value:
			ma.w.TimeToFirstByteMS.v = ma.ca_TimeToFirstByteMS.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 10:
		switch ma.w.TimeToLastByteMS.m {
		case schema.Maybe_Value:
			ma.w.TimeToLastByteMS.v = ma.ca_TimeToLastByteMS.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 11:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Events.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_FinishedTask__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Status":
		if ma.s & fieldBit__FinishedTask_Status != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__FinishedTask_Status}
		}
		ma.s += fieldBit__FinishedTask_Status
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Status.w = &ma.w.Status
		ma.ca_Status.m = &ma.cm
		return &ma.ca_Status, nil
	case "StartedAt":
		if ma.s & fieldBit__FinishedTask_StartedAt != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__FinishedTask_StartedAt}
		}
		ma.s += fieldBit__FinishedTask_StartedAt
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_StartedAt.w = &ma.w.StartedAt
		ma.ca_StartedAt.m = &ma.cm
		return &ma.ca_StartedAt, nil
	case "ErrorMessage":
		if ma.s & fieldBit__FinishedTask_ErrorMessage != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__FinishedTask_ErrorMessage}
		}
		ma.s += fieldBit__FinishedTask_ErrorMessage
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_ErrorMessage.w = ma.w.ErrorMessage.v
		ma.ca_ErrorMessage.m = &ma.w.ErrorMessage.m
		return &ma.ca_ErrorMessage, nil
	case "RetrievalTask":
		if ma.s & fieldBit__FinishedTask_RetrievalTask != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__FinishedTask_RetrievalTask}
		}
		ma.s += fieldBit__FinishedTask_RetrievalTask
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_RetrievalTask.w = ma.w.RetrievalTask.v
		ma.ca_RetrievalTask.m = &ma.w.RetrievalTask.m
		return &ma.ca_RetrievalTask, nil
	case "StorageTask":
		if ma.s & fieldBit__FinishedTask_StorageTask != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__FinishedTask_StorageTask}
		}
		ma.s += fieldBit__FinishedTask_StorageTask
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_StorageTask.w = ma.w.StorageTask.v
		ma.ca_StorageTask.m = &ma.w.StorageTask.m
		return &ma.ca_StorageTask, nil
	case "DealID":
		if ma.s & fieldBit__FinishedTask_DealID != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__FinishedTask_DealID}
		}
		ma.s += fieldBit__FinishedTask_DealID
		ma.state = maState_midValue
		ma.f = 5
		ma.ca_DealID.w = &ma.w.DealID
		ma.ca_DealID.m = &ma.cm
		return &ma.ca_DealID, nil
	case "MinerMultiAddr":
		if ma.s & fieldBit__FinishedTask_MinerMultiAddr != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__FinishedTask_MinerMultiAddr}
		}
		ma.s += fieldBit__FinishedTask_MinerMultiAddr
		ma.state = maState_midValue
		ma.f = 6
		ma.ca_MinerMultiAddr.w = &ma.w.MinerMultiAddr
		ma.ca_MinerMultiAddr.m = &ma.cm
		return &ma.ca_MinerMultiAddr, nil
	case "ClientApparentAddr":
		if ma.s & fieldBit__FinishedTask_ClientApparentAddr != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__FinishedTask_ClientApparentAddr}
		}
		ma.s += fieldBit__FinishedTask_ClientApparentAddr
		ma.state = maState_midValue
		ma.f = 7
		ma.ca_ClientApparentAddr.w = &ma.w.ClientApparentAddr
		ma.ca_ClientApparentAddr.m = &ma.cm
		return &ma.ca_ClientApparentAddr, nil
	case "MinerLatencyMS":
		if ma.s & fieldBit__FinishedTask_MinerLatencyMS != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__FinishedTask_MinerLatencyMS}
		}
		ma.s += fieldBit__FinishedTask_MinerLatencyMS
		ma.state = maState_midValue
		ma.f = 8
		ma.ca_MinerLatencyMS.w = ma.w.MinerLatencyMS.v
		ma.ca_MinerLatencyMS.m = &ma.w.MinerLatencyMS.m
		return &ma.ca_MinerLatencyMS, nil
	case "TimeToFirstByteMS":
		if ma.s & fieldBit__FinishedTask_TimeToFirstByteMS != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__FinishedTask_TimeToFirstByteMS}
		}
		ma.s += fieldBit__FinishedTask_TimeToFirstByteMS
		ma.state = maState_midValue
		ma.f = 9
		ma.ca_TimeToFirstByteMS.w = ma.w.TimeToFirstByteMS.v
		ma.ca_TimeToFirstByteMS.m = &ma.w.TimeToFirstByteMS.m
		return &ma.ca_TimeToFirstByteMS, nil
	case "TimeToLastByteMS":
		if ma.s & fieldBit__FinishedTask_TimeToLastByteMS != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__FinishedTask_TimeToLastByteMS}
		}
		ma.s += fieldBit__FinishedTask_TimeToLastByteMS
		ma.state = maState_midValue
		ma.f = 10
		ma.ca_TimeToLastByteMS.w = ma.w.TimeToLastByteMS.v
		ma.ca_TimeToLastByteMS.m = &ma.w.TimeToLastByteMS.m
		return &ma.ca_TimeToLastByteMS, nil
	case "Events":
		if ma.s & fieldBit__FinishedTask_Events != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__FinishedTask_Events}
		}
		ma.s += fieldBit__FinishedTask_Events
		ma.state = maState_midValue
		ma.f = 11
		ma.ca_Events.w = &ma.w.Events
		ma.ca_Events.m = &ma.cm
		return &ma.ca_Events, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"tasks.FinishedTask", Key:&_String{k}}
	}
}
func (ma *_FinishedTask__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_FinishedTask__KeyAssembler)(ma)
}
func (ma *_FinishedTask__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Status.w = &ma.w.Status
		ma.ca_Status.m = &ma.cm
		return &ma.ca_Status
	case 1:
		ma.ca_StartedAt.w = &ma.w.StartedAt
		ma.ca_StartedAt.m = &ma.cm
		return &ma.ca_StartedAt
	case 2:
		ma.ca_ErrorMessage.w = ma.w.ErrorMessage.v
		ma.ca_ErrorMessage.m = &ma.w.ErrorMessage.m
		return &ma.ca_ErrorMessage
	case 3:
		ma.ca_RetrievalTask.w = ma.w.RetrievalTask.v
		ma.ca_RetrievalTask.m = &ma.w.RetrievalTask.m
		return &ma.ca_RetrievalTask
	case 4:
		ma.ca_StorageTask.w = ma.w.StorageTask.v
		ma.ca_StorageTask.m = &ma.w.StorageTask.m
		return &ma.ca_StorageTask
	case 5:
		ma.ca_DealID.w = &ma.w.DealID
		ma.ca_DealID.m = &ma.cm
		return &ma.ca_DealID
	case 6:
		ma.ca_MinerMultiAddr.w = &ma.w.MinerMultiAddr
		ma.ca_MinerMultiAddr.m = &ma.cm
		return &ma.ca_MinerMultiAddr
	case 7:
		ma.ca_ClientApparentAddr.w = &ma.w.ClientApparentAddr
		ma.ca_ClientApparentAddr.m = &ma.cm
		return &ma.ca_ClientApparentAddr
	case 8:
		ma.ca_MinerLatencyMS.w = ma.w.MinerLatencyMS.v
		ma.ca_MinerLatencyMS.m = &ma.w.MinerLatencyMS.m
		return &ma.ca_MinerLatencyMS
	case 9:
		ma.ca_TimeToFirstByteMS.w = ma.w.TimeToFirstByteMS.v
		ma.ca_TimeToFirstByteMS.m = &ma.w.TimeToFirstByteMS.m
		return &ma.ca_TimeToFirstByteMS
	case 10:
		ma.ca_TimeToLastByteMS.w = ma.w.TimeToLastByteMS.v
		ma.ca_TimeToLastByteMS.m = &ma.w.TimeToLastByteMS.m
		return &ma.ca_TimeToLastByteMS
	case 11:
		ma.ca_Events.w = &ma.w.Events
		ma.ca_Events.m = &ma.cm
		return &ma.ca_Events
	default:
		panic("unreachable")
	}
}
func (ma *_FinishedTask__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s & fieldBits__FinishedTask_sufficient != fieldBits__FinishedTask_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s & fieldBit__FinishedTask_Status == 0 {
			err.Missing = append(err.Missing, "Status")
		}
		if ma.s & fieldBit__FinishedTask_StartedAt == 0 {
			err.Missing = append(err.Missing, "StartedAt")
		}
		if ma.s & fieldBit__FinishedTask_DealID == 0 {
			err.Missing = append(err.Missing, "DealID")
		}
		if ma.s & fieldBit__FinishedTask_MinerMultiAddr == 0 {
			err.Missing = append(err.Missing, "MinerMultiAddr")
		}
		if ma.s & fieldBit__FinishedTask_ClientApparentAddr == 0 {
			err.Missing = append(err.Missing, "ClientApparentAddr")
		}
		if ma.s & fieldBit__FinishedTask_Events == 0 {
			err.Missing = append(err.Missing, "Events")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_FinishedTask__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_FinishedTask__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}
type _FinishedTask__KeyAssembler _FinishedTask__Assembler
func (_FinishedTask__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"tasks.FinishedTask.KeyAssembler"}.BeginMap(0)
}
func (_FinishedTask__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"tasks.FinishedTask.KeyAssembler"}.BeginList(0)
}
func (na *_FinishedTask__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"tasks.FinishedTask.KeyAssembler"}.AssignNull()
}
func (_FinishedTask__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"tasks.FinishedTask.KeyAssembler"}.AssignBool(false)
}
func (_FinishedTask__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"tasks.FinishedTask.KeyAssembler"}.AssignInt(0)
}
func (_FinishedTask__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"tasks.FinishedTask.KeyAssembler"}.AssignFloat(0)
}
func (ka *_FinishedTask__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Status":
		if ka.s & fieldBit__FinishedTask_Status != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__FinishedTask_Status}
		}
		ka.s += fieldBit__FinishedTask_Status
		ka.state = maState_expectValue
		ka.f = 0
	case "StartedAt":
		if ka.s & fieldBit__FinishedTask_StartedAt != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__FinishedTask_StartedAt}
		}
		ka.s += fieldBit__FinishedTask_StartedAt
		ka.state = maState_expectValue
		ka.f = 1
	case "ErrorMessage":
		if ka.s & fieldBit__FinishedTask_ErrorMessage != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__FinishedTask_ErrorMessage}
		}
		ka.s += fieldBit__FinishedTask_ErrorMessage
		ka.state = maState_expectValue
		ka.f = 2
	case "RetrievalTask":
		if ka.s & fieldBit__FinishedTask_RetrievalTask != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__FinishedTask_RetrievalTask}
		}
		ka.s += fieldBit__FinishedTask_RetrievalTask
		ka.state = maState_expectValue
		ka.f = 3
	case "StorageTask":
		if ka.s & fieldBit__FinishedTask_StorageTask != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__FinishedTask_StorageTask}
		}
		ka.s += fieldBit__FinishedTask_StorageTask
		ka.state = maState_expectValue
		ka.f = 4
	case "DealID":
		if ka.s & fieldBit__FinishedTask_DealID != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__FinishedTask_DealID}
		}
		ka.s += fieldBit__FinishedTask_DealID
		ka.state = maState_expectValue
		ka.f = 5
	case "MinerMultiAddr":
		if ka.s & fieldBit__FinishedTask_MinerMultiAddr != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__FinishedTask_MinerMultiAddr}
		}
		ka.s += fieldBit__FinishedTask_MinerMultiAddr
		ka.state = maState_expectValue
		ka.f = 6
	case "ClientApparentAddr":
		if ka.s & fieldBit__FinishedTask_ClientApparentAddr != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__FinishedTask_ClientApparentAddr}
		}
		ka.s += fieldBit__FinishedTask_ClientApparentAddr
		ka.state = maState_expectValue
		ka.f = 7
	case "MinerLatencyMS":
		if ka.s & fieldBit__FinishedTask_MinerLatencyMS != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__FinishedTask_MinerLatencyMS}
		}
		ka.s += fieldBit__FinishedTask_MinerLatencyMS
		ka.state = maState_expectValue
		ka.f = 8
	case "TimeToFirstByteMS":
		if ka.s & fieldBit__FinishedTask_TimeToFirstByteMS != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__FinishedTask_TimeToFirstByteMS}
		}
		ka.s += fieldBit__FinishedTask_TimeToFirstByteMS
		ka.state = maState_expectValue
		ka.f = 9
	case "TimeToLastByteMS":
		if ka.s & fieldBit__FinishedTask_TimeToLastByteMS != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__FinishedTask_TimeToLastByteMS}
		}
		ka.s += fieldBit__FinishedTask_TimeToLastByteMS
		ka.state = maState_expectValue
		ka.f = 10
	case "Events":
		if ka.s & fieldBit__FinishedTask_Events != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__FinishedTask_Events}
		}
		ka.s += fieldBit__FinishedTask_Events
		ka.state = maState_expectValue
		ka.f = 11
	default:
		return ipld.ErrInvalidKey{TypeName:"tasks.FinishedTask", Key:&_String{k}}
	}
	return nil
}
func (_FinishedTask__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"tasks.FinishedTask.KeyAssembler"}.AssignBytes(nil)
}
func (_FinishedTask__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"tasks.FinishedTask.KeyAssembler"}.AssignLink(nil)
}
func (ka *_FinishedTask__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_FinishedTask__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (FinishedTask) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n FinishedTask) Representation() ipld.Node {
	return (*_FinishedTask__Repr)(n)
}
type _FinishedTask__Repr _FinishedTask
var (
	fieldName__FinishedTask_Status_serial = _String{"Status"}
	fieldName__FinishedTask_StartedAt_serial = _String{"StartedAt"}
	fieldName__FinishedTask_ErrorMessage_serial = _String{"ErrorMessage"}
	fieldName__FinishedTask_RetrievalTask_serial = _String{"RetrievalTask"}
	fieldName__FinishedTask_StorageTask_serial = _String{"StorageTask"}
	fieldName__FinishedTask_DealID_serial = _String{"DealID"}
	fieldName__FinishedTask_MinerMultiAddr_serial = _String{"MinerMultiAddr"}
	fieldName__FinishedTask_ClientApparentAddr_serial = _String{"ClientApparentAddr"}
	fieldName__FinishedTask_MinerLatencyMS_serial = _String{"MinerLatencyMS"}
	fieldName__FinishedTask_TimeToFirstByteMS_serial = _String{"TimeToFirstByteMS"}
	fieldName__FinishedTask_TimeToLastByteMS_serial = _String{"TimeToLastByteMS"}
	fieldName__FinishedTask_Events_serial = _String{"Events"}
)
var _ ipld.Node = &_FinishedTask__Repr{}
func (_FinishedTask__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_FinishedTask__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Status":
		return n.Status.Representation(), nil
	case "StartedAt":
		return n.StartedAt.Representation(), nil
	case "ErrorMessage":
		if n.ErrorMessage.m == schema.Maybe_Absent {
			return ipld.Absent, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.ErrorMessage.v.Representation(), nil
	case "RetrievalTask":
		if n.RetrievalTask.m == schema.Maybe_Absent {
			return ipld.Absent, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.RetrievalTask.v.Representation(), nil
	case "StorageTask":
		if n.StorageTask.m == schema.Maybe_Absent {
			return ipld.Absent, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.StorageTask.v.Representation(), nil
	case "DealID":
		return n.DealID.Representation(), nil
	case "MinerMultiAddr":
		return n.MinerMultiAddr.Representation(), nil
	case "ClientApparentAddr":
		return n.ClientApparentAddr.Representation(), nil
	case "MinerLatencyMS":
		if n.MinerLatencyMS.m == schema.Maybe_Absent {
			return ipld.Absent, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.MinerLatencyMS.v.Representation(), nil
	case "TimeToFirstByteMS":
		if n.TimeToFirstByteMS.m == schema.Maybe_Absent {
			return ipld.Absent, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.TimeToFirstByteMS.v.Representation(), nil
	case "TimeToLastByteMS":
		if n.TimeToLastByteMS.m == schema.Maybe_Absent {
			return ipld.Absent, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.TimeToLastByteMS.v.Representation(), nil
	case "Events":
		return n.Events.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_FinishedTask__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_FinishedTask__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"tasks.FinishedTask.Repr"}.LookupByIndex(0)
}
func (n _FinishedTask__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_FinishedTask__Repr) MapIterator() ipld.MapIterator {
	return &_FinishedTask__ReprMapItr{n, 0}
}

type _FinishedTask__ReprMapItr struct {
	n   *_FinishedTask__Repr
	idx int
	
}

func (itr *_FinishedTask__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
advance:if itr.idx >= 12 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__FinishedTask_Status_serial
		v = itr.n.Status.Representation()
	case 1:
		k = &fieldName__FinishedTask_StartedAt_serial
		v = itr.n.StartedAt.Representation()
	case 2:
		k = &fieldName__FinishedTask_ErrorMessage_serial
		if itr.n.ErrorMessage.m == schema.Maybe_Absent {
			itr.idx++
			goto advance
		}
		v = itr.n.ErrorMessage.v.Representation()
	case 3:
		k = &fieldName__FinishedTask_RetrievalTask_serial
		if itr.n.RetrievalTask.m == schema.Maybe_Absent {
			itr.idx++
			goto advance
		}
		v = itr.n.RetrievalTask.v.Representation()
	case 4:
		k = &fieldName__FinishedTask_StorageTask_serial
		if itr.n.StorageTask.m == schema.Maybe_Absent {
			itr.idx++
			goto advance
		}
		v = itr.n.StorageTask.v.Representation()
	case 5:
		k = &fieldName__FinishedTask_DealID_serial
		v = itr.n.DealID.Representation()
	case 6:
		k = &fieldName__FinishedTask_MinerMultiAddr_serial
		v = itr.n.MinerMultiAddr.Representation()
	case 7:
		k = &fieldName__FinishedTask_ClientApparentAddr_serial
		v = itr.n.ClientApparentAddr.Representation()
	case 8:
		k = &fieldName__FinishedTask_MinerLatencyMS_serial
		if itr.n.MinerLatencyMS.m == schema.Maybe_Absent {
			itr.idx++
			goto advance
		}
		v = itr.n.MinerLatencyMS.v.Representation()
	case 9:
		k = &fieldName__FinishedTask_TimeToFirstByteMS_serial
		if itr.n.TimeToFirstByteMS.m == schema.Maybe_Absent {
			itr.idx++
			goto advance
		}
		v = itr.n.TimeToFirstByteMS.v.Representation()
	case 10:
		k = &fieldName__FinishedTask_TimeToLastByteMS_serial
		if itr.n.TimeToLastByteMS.m == schema.Maybe_Absent {
			itr.idx++
			goto advance
		}
		v = itr.n.TimeToLastByteMS.v.Representation()
	case 11:
		k = &fieldName__FinishedTask_Events_serial
		v = itr.n.Events.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_FinishedTask__ReprMapItr) Done() bool {
	return itr.idx >= 12
}
func (_FinishedTask__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_FinishedTask__Repr) Length() int64 {
	l := 12
	if rn.ErrorMessage.m == schema.Maybe_Absent {
		l--
	}
	if rn.RetrievalTask.m == schema.Maybe_Absent {
		l--
	}
	if rn.StorageTask.m == schema.Maybe_Absent {
		l--
	}
	if rn.MinerLatencyMS.m == schema.Maybe_Absent {
		l--
	}
	if rn.TimeToFirstByteMS.m == schema.Maybe_Absent {
		l--
	}
	if rn.TimeToLastByteMS.m == schema.Maybe_Absent {
		l--
	}
	return int64(l)
}
func (_FinishedTask__Repr) IsAbsent() bool {
	return false
}
func (_FinishedTask__Repr) IsNull() bool {
	return false
}
func (_FinishedTask__Repr) AsBool() (bool, error) {
	return mixins.Map{"tasks.FinishedTask.Repr"}.AsBool()
}
func (_FinishedTask__Repr) AsInt() (int64, error) {
	return mixins.Map{"tasks.FinishedTask.Repr"}.AsInt()
}
func (_FinishedTask__Repr) AsFloat() (float64, error) {
	return mixins.Map{"tasks.FinishedTask.Repr"}.AsFloat()
}
func (_FinishedTask__Repr) AsString() (string, error) {
	return mixins.Map{"tasks.FinishedTask.Repr"}.AsString()
}
func (_FinishedTask__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"tasks.FinishedTask.Repr"}.AsBytes()
}
func (_FinishedTask__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"tasks.FinishedTask.Repr"}.AsLink()
}
func (_FinishedTask__Repr) Prototype() ipld.NodePrototype {
	return _FinishedTask__ReprPrototype{}
}
type _FinishedTask__ReprPrototype struct{}

func (_FinishedTask__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _FinishedTask__ReprBuilder
	nb.Reset()
	return &nb
}
type _FinishedTask__ReprBuilder struct {
	_FinishedTask__ReprAssembler
}
func (nb *_FinishedTask__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_FinishedTask__ReprBuilder) Reset() {
	var w _FinishedTask
	var m schema.Maybe
	*nb = _FinishedTask__ReprBuilder{_FinishedTask__ReprAssembler{w: &w, m: &m}}
}
type _FinishedTask__ReprAssembler struct {
	w *_FinishedTask
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_Status _Status__ReprAssembler
	ca_StartedAt _Time__ReprAssembler
	ca_ErrorMessage _String__ReprAssembler
	ca_RetrievalTask _RetrievalTask__ReprAssembler
	ca_StorageTask _StorageTask__ReprAssembler
	ca_DealID _Int__ReprAssembler
	ca_MinerMultiAddr _String__ReprAssembler
	ca_ClientApparentAddr _String__ReprAssembler
	ca_MinerLatencyMS _Int__ReprAssembler
	ca_TimeToFirstByteMS _Int__ReprAssembler
	ca_TimeToLastByteMS _Int__ReprAssembler
	ca_Events _Link_List_StageDetails__ReprAssembler
	}

func (na *_FinishedTask__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Status.reset()
	na.ca_StartedAt.reset()
	na.ca_ErrorMessage.reset()
	na.ca_RetrievalTask.reset()
	na.ca_StorageTask.reset()
	na.ca_DealID.reset()
	na.ca_MinerMultiAddr.reset()
	na.ca_ClientApparentAddr.reset()
	na.ca_MinerLatencyMS.reset()
	na.ca_TimeToFirstByteMS.reset()
	na.ca_TimeToLastByteMS.reset()
	na.ca_Events.reset()
}
func (na *_FinishedTask__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_FinishedTask{}
	}
	return na, nil
}
func (_FinishedTask__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"tasks.FinishedTask.Repr"}.BeginList(0)
}
func (na *_FinishedTask__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"tasks.FinishedTask.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_FinishedTask__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"tasks.FinishedTask.Repr"}.AssignBool(false)
}
func (_FinishedTask__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"tasks.FinishedTask.Repr"}.AssignInt(0)
}
func (_FinishedTask__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"tasks.FinishedTask.Repr"}.AssignFloat(0)
}
func (_FinishedTask__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"tasks.FinishedTask.Repr"}.AssignString("")
}
func (_FinishedTask__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"tasks.FinishedTask.Repr"}.AssignBytes(nil)
}
func (_FinishedTask__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"tasks.FinishedTask.Repr"}.AssignLink(nil)
}
func (na *_FinishedTask__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_FinishedTask); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "tasks.FinishedTask.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_FinishedTask__ReprAssembler) Prototype() ipld.NodePrototype {
	return _FinishedTask__ReprPrototype{}
}
func (ma *_FinishedTask__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.w.ErrorMessage.m {
		case schema.Maybe_Value:
			ma.w.ErrorMessage.v = ma.ca_ErrorMessage.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.w.RetrievalTask.m {
		case schema.Maybe_Value:
			ma.w.RetrievalTask.v = ma.ca_RetrievalTask.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.w.StorageTask.m {
		case schema.Maybe_Value:
			ma.w.StorageTask.v = ma.ca_StorageTask.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 5:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 6:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 7:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 8:
		switch ma.w.MinerLatencyMS.m {
		case schema.Maybe_Value:
			ma.w.MinerLatencyMS.v = ma.ca_MinerLatencyMS.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 9:
		switch ma.w.TimeToFirstByteMS.m {
		case schema.Maybe_Value:
			ma.w.TimeToFirstByteMS.v = ma.ca_TimeToFirstByteMS.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 10:
		switch ma.w.TimeToLastByteMS.m {
		case schema.Maybe_Value:
			ma.w.TimeToLastByteMS.v = ma.ca_TimeToLastByteMS.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 11:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_FinishedTask__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Status":
		if ma.s & fieldBit__FinishedTask_Status != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__FinishedTask_Status_serial}
		}
		ma.s += fieldBit__FinishedTask_Status
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Status.w = &ma.w.Status
		ma.ca_Status.m = &ma.cm
		return &ma.ca_Status, nil
	case "StartedAt":
		if ma.s & fieldBit__FinishedTask_StartedAt != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__FinishedTask_StartedAt_serial}
		}
		ma.s += fieldBit__FinishedTask_StartedAt
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_StartedAt.w = &ma.w.StartedAt
		ma.ca_StartedAt.m = &ma.cm
		return &ma.ca_StartedAt, nil
	case "ErrorMessage":
		if ma.s & fieldBit__FinishedTask_ErrorMessage != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__FinishedTask_ErrorMessage_serial}
		}
		ma.s += fieldBit__FinishedTask_ErrorMessage
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_ErrorMessage.w = ma.w.ErrorMessage.v
		ma.ca_ErrorMessage.m = &ma.w.ErrorMessage.m
		
		return &ma.ca_ErrorMessage, nil
	case "RetrievalTask":
		if ma.s & fieldBit__FinishedTask_RetrievalTask != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__FinishedTask_RetrievalTask_serial}
		}
		ma.s += fieldBit__FinishedTask_RetrievalTask
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_RetrievalTask.w = ma.w.RetrievalTask.v
		ma.ca_RetrievalTask.m = &ma.w.RetrievalTask.m
		
		return &ma.ca_RetrievalTask, nil
	case "StorageTask":
		if ma.s & fieldBit__FinishedTask_StorageTask != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__FinishedTask_StorageTask_serial}
		}
		ma.s += fieldBit__FinishedTask_StorageTask
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_StorageTask.w = ma.w.StorageTask.v
		ma.ca_StorageTask.m = &ma.w.StorageTask.m
		
		return &ma.ca_StorageTask, nil
	case "DealID":
		if ma.s & fieldBit__FinishedTask_DealID != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__FinishedTask_DealID_serial}
		}
		ma.s += fieldBit__FinishedTask_DealID
		ma.state = maState_midValue
		ma.f = 5
		ma.ca_DealID.w = &ma.w.DealID
		ma.ca_DealID.m = &ma.cm
		return &ma.ca_DealID, nil
	case "MinerMultiAddr":
		if ma.s & fieldBit__FinishedTask_MinerMultiAddr != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__FinishedTask_MinerMultiAddr_serial}
		}
		ma.s += fieldBit__FinishedTask_MinerMultiAddr
		ma.state = maState_midValue
		ma.f = 6
		ma.ca_MinerMultiAddr.w = &ma.w.MinerMultiAddr
		ma.ca_MinerMultiAddr.m = &ma.cm
		return &ma.ca_MinerMultiAddr, nil
	case "ClientApparentAddr":
		if ma.s & fieldBit__FinishedTask_ClientApparentAddr != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__FinishedTask_ClientApparentAddr_serial}
		}
		ma.s += fieldBit__FinishedTask_ClientApparentAddr
		ma.state = maState_midValue
		ma.f = 7
		ma.ca_ClientApparentAddr.w = &ma.w.ClientApparentAddr
		ma.ca_ClientApparentAddr.m = &ma.cm
		return &ma.ca_ClientApparentAddr, nil
	case "MinerLatencyMS":
		if ma.s & fieldBit__FinishedTask_MinerLatencyMS != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__FinishedTask_MinerLatencyMS_serial}
		}
		ma.s += fieldBit__FinishedTask_MinerLatencyMS
		ma.state = maState_midValue
		ma.f = 8
		ma.ca_MinerLatencyMS.w = ma.w.MinerLatencyMS.v
		ma.ca_MinerLatencyMS.m = &ma.w.MinerLatencyMS.m
		
		return &ma.ca_MinerLatencyMS, nil
	case "TimeToFirstByteMS":
		if ma.s & fieldBit__FinishedTask_TimeToFirstByteMS != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__FinishedTask_TimeToFirstByteMS_serial}
		}
		ma.s += fieldBit__FinishedTask_TimeToFirstByteMS
		ma.state = maState_midValue
		ma.f = 9
		ma.ca_TimeToFirstByteMS.w = ma.w.TimeToFirstByteMS.v
		ma.ca_TimeToFirstByteMS.m = &ma.w.TimeToFirstByteMS.m
		
		return &ma.ca_TimeToFirstByteMS, nil
	case "TimeToLastByteMS":
		if ma.s & fieldBit__FinishedTask_TimeToLastByteMS != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__FinishedTask_TimeToLastByteMS_serial}
		}
		ma.s += fieldBit__FinishedTask_TimeToLastByteMS
		ma.state = maState_midValue
		ma.f = 10
		ma.ca_TimeToLastByteMS.w = ma.w.TimeToLastByteMS.v
		ma.ca_TimeToLastByteMS.m = &ma.w.TimeToLastByteMS.m
		
		return &ma.ca_TimeToLastByteMS, nil
	case "Events":
		if ma.s & fieldBit__FinishedTask_Events != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__FinishedTask_Events_serial}
		}
		ma.s += fieldBit__FinishedTask_Events
		ma.state = maState_midValue
		ma.f = 11
		ma.ca_Events.w = &ma.w.Events
		ma.ca_Events.m = &ma.cm
		return &ma.ca_Events, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"tasks.FinishedTask.Repr", Key:&_String{k}}
	}
}
func (ma *_FinishedTask__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_FinishedTask__ReprKeyAssembler)(ma)
}
func (ma *_FinishedTask__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Status.w = &ma.w.Status
		ma.ca_Status.m = &ma.cm
		return &ma.ca_Status
	case 1:
		ma.ca_StartedAt.w = &ma.w.StartedAt
		ma.ca_StartedAt.m = &ma.cm
		return &ma.ca_StartedAt
	case 2:
		ma.ca_ErrorMessage.w = ma.w.ErrorMessage.v
		ma.ca_ErrorMessage.m = &ma.w.ErrorMessage.m
		
		return &ma.ca_ErrorMessage
	case 3:
		ma.ca_RetrievalTask.w = ma.w.RetrievalTask.v
		ma.ca_RetrievalTask.m = &ma.w.RetrievalTask.m
		
		return &ma.ca_RetrievalTask
	case 4:
		ma.ca_StorageTask.w = ma.w.StorageTask.v
		ma.ca_StorageTask.m = &ma.w.StorageTask.m
		
		return &ma.ca_StorageTask
	case 5:
		ma.ca_DealID.w = &ma.w.DealID
		ma.ca_DealID.m = &ma.cm
		return &ma.ca_DealID
	case 6:
		ma.ca_MinerMultiAddr.w = &ma.w.MinerMultiAddr
		ma.ca_MinerMultiAddr.m = &ma.cm
		return &ma.ca_MinerMultiAddr
	case 7:
		ma.ca_ClientApparentAddr.w = &ma.w.ClientApparentAddr
		ma.ca_ClientApparentAddr.m = &ma.cm
		return &ma.ca_ClientApparentAddr
	case 8:
		ma.ca_MinerLatencyMS.w = ma.w.MinerLatencyMS.v
		ma.ca_MinerLatencyMS.m = &ma.w.MinerLatencyMS.m
		
		return &ma.ca_MinerLatencyMS
	case 9:
		ma.ca_TimeToFirstByteMS.w = ma.w.TimeToFirstByteMS.v
		ma.ca_TimeToFirstByteMS.m = &ma.w.TimeToFirstByteMS.m
		
		return &ma.ca_TimeToFirstByteMS
	case 10:
		ma.ca_TimeToLastByteMS.w = ma.w.TimeToLastByteMS.v
		ma.ca_TimeToLastByteMS.m = &ma.w.TimeToLastByteMS.m
		
		return &ma.ca_TimeToLastByteMS
	case 11:
		ma.ca_Events.w = &ma.w.Events
		ma.ca_Events.m = &ma.cm
		return &ma.ca_Events
	default:
		panic("unreachable")
	}
}
func (ma *_FinishedTask__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s & fieldBits__FinishedTask_sufficient != fieldBits__FinishedTask_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s & fieldBit__FinishedTask_Status == 0 {
			err.Missing = append(err.Missing, "Status")
		}
		if ma.s & fieldBit__FinishedTask_StartedAt == 0 {
			err.Missing = append(err.Missing, "StartedAt")
		}
		if ma.s & fieldBit__FinishedTask_DealID == 0 {
			err.Missing = append(err.Missing, "DealID")
		}
		if ma.s & fieldBit__FinishedTask_MinerMultiAddr == 0 {
			err.Missing = append(err.Missing, "MinerMultiAddr")
		}
		if ma.s & fieldBit__FinishedTask_ClientApparentAddr == 0 {
			err.Missing = append(err.Missing, "ClientApparentAddr")
		}
		if ma.s & fieldBit__FinishedTask_Events == 0 {
			err.Missing = append(err.Missing, "Events")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_FinishedTask__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_FinishedTask__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}
type _FinishedTask__ReprKeyAssembler _FinishedTask__ReprAssembler
func (_FinishedTask__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"tasks.FinishedTask.Repr.KeyAssembler"}.BeginMap(0)
}
func (_FinishedTask__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"tasks.FinishedTask.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_FinishedTask__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"tasks.FinishedTask.Repr.KeyAssembler"}.AssignNull()
}
func (_FinishedTask__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"tasks.FinishedTask.Repr.KeyAssembler"}.AssignBool(false)
}
func (_FinishedTask__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"tasks.FinishedTask.Repr.KeyAssembler"}.AssignInt(0)
}
func (_FinishedTask__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"tasks.FinishedTask.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_FinishedTask__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Status":
		if ka.s & fieldBit__FinishedTask_Status != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__FinishedTask_Status_serial}
		}
		ka.s += fieldBit__FinishedTask_Status
		ka.state = maState_expectValue
		ka.f = 0
	case "StartedAt":
		if ka.s & fieldBit__FinishedTask_StartedAt != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__FinishedTask_StartedAt_serial}
		}
		ka.s += fieldBit__FinishedTask_StartedAt
		ka.state = maState_expectValue
		ka.f = 1
	case "ErrorMessage":
		if ka.s & fieldBit__FinishedTask_ErrorMessage != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__FinishedTask_ErrorMessage_serial}
		}
		ka.s += fieldBit__FinishedTask_ErrorMessage
		ka.state = maState_expectValue
		ka.f = 2
	case "RetrievalTask":
		if ka.s & fieldBit__FinishedTask_RetrievalTask != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__FinishedTask_RetrievalTask_serial}
		}
		ka.s += fieldBit__FinishedTask_RetrievalTask
		ka.state = maState_expectValue
		ka.f = 3
	case "StorageTask":
		if ka.s & fieldBit__FinishedTask_StorageTask != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__FinishedTask_StorageTask_serial}
		}
		ka.s += fieldBit__FinishedTask_StorageTask
		ka.state = maState_expectValue
		ka.f = 4
	case "DealID":
		if ka.s & fieldBit__FinishedTask_DealID != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__FinishedTask_DealID_serial}
		}
		ka.s += fieldBit__FinishedTask_DealID
		ka.state = maState_expectValue
		ka.f = 5
	case "MinerMultiAddr":
		if ka.s & fieldBit__FinishedTask_MinerMultiAddr != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__FinishedTask_MinerMultiAddr_serial}
		}
		ka.s += fieldBit__FinishedTask_MinerMultiAddr
		ka.state = maState_expectValue
		ka.f = 6
	case "ClientApparentAddr":
		if ka.s & fieldBit__FinishedTask_ClientApparentAddr != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__FinishedTask_ClientApparentAddr_serial}
		}
		ka.s += fieldBit__FinishedTask_ClientApparentAddr
		ka.state = maState_expectValue
		ka.f = 7
	case "MinerLatencyMS":
		if ka.s & fieldBit__FinishedTask_MinerLatencyMS != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__FinishedTask_MinerLatencyMS_serial}
		}
		ka.s += fieldBit__FinishedTask_MinerLatencyMS
		ka.state = maState_expectValue
		ka.f = 8
	case "TimeToFirstByteMS":
		if ka.s & fieldBit__FinishedTask_TimeToFirstByteMS != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__FinishedTask_TimeToFirstByteMS_serial}
		}
		ka.s += fieldBit__FinishedTask_TimeToFirstByteMS
		ka.state = maState_expectValue
		ka.f = 9
	case "TimeToLastByteMS":
		if ka.s & fieldBit__FinishedTask_TimeToLastByteMS != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__FinishedTask_TimeToLastByteMS_serial}
		}
		ka.s += fieldBit__FinishedTask_TimeToLastByteMS
		ka.state = maState_expectValue
		ka.f = 10
	case "Events":
		if ka.s & fieldBit__FinishedTask_Events != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__FinishedTask_Events_serial}
		}
		ka.s += fieldBit__FinishedTask_Events
		ka.state = maState_expectValue
		ka.f = 11
	default:
		return ipld.ErrInvalidKey{TypeName:"tasks.FinishedTask.Repr", Key:&_String{k}}
	}
	return nil
}
func (_FinishedTask__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"tasks.FinishedTask.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_FinishedTask__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"tasks.FinishedTask.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_FinishedTask__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_FinishedTask__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n Float) Float() float64 {
	return n.x
}
func (_Float__Prototype) FromFloat(v float64) (Float, error) {
	n := _Float{v}
	return &n, nil
}
type _Float__Maybe struct {
	m schema.Maybe
	v Float
}
type MaybeFloat = *_Float__Maybe

func (m MaybeFloat) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeFloat) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeFloat) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeFloat) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeFloat) Must() Float {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var _ ipld.Node = (Float)(&_Float{})
var _ schema.TypedNode = (Float)(&_Float{})
func (Float) Kind() ipld.Kind {
	return ipld.Kind_Float
}
func (Float) LookupByString(string) (ipld.Node, error) {
	return mixins.Float{"tasks.Float"}.LookupByString("")
}
func (Float) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Float{"tasks.Float"}.LookupByNode(nil)
}
func (Float) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Float{"tasks.Float"}.LookupByIndex(0)
}
func (Float) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Float{"tasks.Float"}.LookupBySegment(seg)
}
func (Float) MapIterator() ipld.MapIterator {
	return nil
}
func (Float) ListIterator() ipld.ListIterator {
	return nil
}
func (Float) Length() int64 {
	return -1
}
func (Float) IsAbsent() bool {
	return false
}
func (Float) IsNull() bool {
	return false
}
func (Float) AsBool() (bool, error) {
	return mixins.Float{"tasks.Float"}.AsBool()
}
func (Float) AsInt() (int64, error) {
	return mixins.Float{"tasks.Float"}.AsInt()
}
func (n Float) AsFloat() (float64, error) {
	return n.x, nil
}
func (Float) AsString() (string, error) {
	return mixins.Float{"tasks.Float"}.AsString()
}
func (Float) AsBytes() ([]byte, error) {
	return mixins.Float{"tasks.Float"}.AsBytes()
}
func (Float) AsLink() (ipld.Link, error) {
	return mixins.Float{"tasks.Float"}.AsLink()
}
func (Float) Prototype() ipld.NodePrototype {
	return _Float__Prototype{}
}
type _Float__Prototype struct{}

func (_Float__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Float__Builder
	nb.Reset()
	return &nb
}
type _Float__Builder struct {
	_Float__Assembler
}
func (nb *_Float__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Float__Builder) Reset() {
	var w _Float
	var m schema.Maybe
	*nb = _Float__Builder{_Float__Assembler{w: &w, m: &m}}
}
type _Float__Assembler struct {
	w *_Float
	m *schema.Maybe
}

func (na *_Float__Assembler) reset() {}
func (_Float__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.FloatAssembler{"tasks.Float"}.BeginMap(0)
}
func (_Float__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.FloatAssembler{"tasks.Float"}.BeginList(0)
}
func (na *_Float__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.FloatAssembler{"tasks.Float"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_Float__Assembler) AssignBool(bool) error {
	return mixins.FloatAssembler{"tasks.Float"}.AssignBool(false)
}
func (_Float__Assembler) AssignInt(int64) error {
	return mixins.FloatAssembler{"tasks.Float"}.AssignInt(0)
}
func (na *_Float__Assembler) AssignFloat(v float64) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_Float{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_Float__Assembler) AssignString(string) error {
	return mixins.FloatAssembler{"tasks.Float"}.AssignString("")
}
func (_Float__Assembler) AssignBytes([]byte) error {
	return mixins.FloatAssembler{"tasks.Float"}.AssignBytes(nil)
}
func (_Float__Assembler) AssignLink(ipld.Link) error {
	return mixins.FloatAssembler{"tasks.Float"}.AssignLink(nil)
}
func (na *_Float__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Float); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsFloat(); err != nil {
		return err
	} else {
		return na.AssignFloat(v2)
	}
}
func (_Float__Assembler) Prototype() ipld.NodePrototype {
	return _Float__Prototype{}
}
func (Float) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Float) Representation() ipld.Node {
	return (*_Float__Repr)(n)
}
type _Float__Repr = _Float
var _ ipld.Node = &_Float__Repr{}
type _Float__ReprPrototype = _Float__Prototype
type _Float__ReprAssembler = _Float__Assembler

func (n Int) Int() int64 {
	return n.x
}
func (_Int__Prototype) FromInt(v int64) (Int, error) {
	n := _Int{v}
	return &n, nil
}
type _Int__Maybe struct {
	m schema.Maybe
	v Int
}
type MaybeInt = *_Int__Maybe

func (m MaybeInt) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeInt) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeInt) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeInt) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeInt) Must() Int {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var _ ipld.Node = (Int)(&_Int{})
var _ schema.TypedNode = (Int)(&_Int{})
func (Int) Kind() ipld.Kind {
	return ipld.Kind_Int
}
func (Int) LookupByString(string) (ipld.Node, error) {
	return mixins.Int{"tasks.Int"}.LookupByString("")
}
func (Int) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Int{"tasks.Int"}.LookupByNode(nil)
}
func (Int) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Int{"tasks.Int"}.LookupByIndex(0)
}
func (Int) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Int{"tasks.Int"}.LookupBySegment(seg)
}
func (Int) MapIterator() ipld.MapIterator {
	return nil
}
func (Int) ListIterator() ipld.ListIterator {
	return nil
}
func (Int) Length() int64 {
	return -1
}
func (Int) IsAbsent() bool {
	return false
}
func (Int) IsNull() bool {
	return false
}
func (Int) AsBool() (bool, error) {
	return mixins.Int{"tasks.Int"}.AsBool()
}
func (n Int) AsInt() (int64, error) {
	return n.x, nil
}
func (Int) AsFloat() (float64, error) {
	return mixins.Int{"tasks.Int"}.AsFloat()
}
func (Int) AsString() (string, error) {
	return mixins.Int{"tasks.Int"}.AsString()
}
func (Int) AsBytes() ([]byte, error) {
	return mixins.Int{"tasks.Int"}.AsBytes()
}
func (Int) AsLink() (ipld.Link, error) {
	return mixins.Int{"tasks.Int"}.AsLink()
}
func (Int) Prototype() ipld.NodePrototype {
	return _Int__Prototype{}
}
type _Int__Prototype struct{}

func (_Int__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Int__Builder
	nb.Reset()
	return &nb
}
type _Int__Builder struct {
	_Int__Assembler
}
func (nb *_Int__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Int__Builder) Reset() {
	var w _Int
	var m schema.Maybe
	*nb = _Int__Builder{_Int__Assembler{w: &w, m: &m}}
}
type _Int__Assembler struct {
	w *_Int
	m *schema.Maybe
}

func (na *_Int__Assembler) reset() {}
func (_Int__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.IntAssembler{"tasks.Int"}.BeginMap(0)
}
func (_Int__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.IntAssembler{"tasks.Int"}.BeginList(0)
}
func (na *_Int__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.IntAssembler{"tasks.Int"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_Int__Assembler) AssignBool(bool) error {
	return mixins.IntAssembler{"tasks.Int"}.AssignBool(false)
}
func (na *_Int__Assembler) AssignInt(v int64) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_Int{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_Int__Assembler) AssignFloat(float64) error {
	return mixins.IntAssembler{"tasks.Int"}.AssignFloat(0)
}
func (_Int__Assembler) AssignString(string) error {
	return mixins.IntAssembler{"tasks.Int"}.AssignString("")
}
func (_Int__Assembler) AssignBytes([]byte) error {
	return mixins.IntAssembler{"tasks.Int"}.AssignBytes(nil)
}
func (_Int__Assembler) AssignLink(ipld.Link) error {
	return mixins.IntAssembler{"tasks.Int"}.AssignLink(nil)
}
func (na *_Int__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Int); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsInt(); err != nil {
		return err
	} else {
		return na.AssignInt(v2)
	}
}
func (_Int__Assembler) Prototype() ipld.NodePrototype {
	return _Int__Prototype{}
}
func (Int) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Int) Representation() ipld.Node {
	return (*_Int__Repr)(n)
}
type _Int__Repr = _Int
var _ ipld.Node = &_Int__Repr{}
type _Int__ReprPrototype = _Int__Prototype
type _Int__ReprAssembler = _Int__Assembler

func (n Link) Link() ipld.Link {
	return n.x
}
func (_Link__Prototype) FromLink(v ipld.Link) (Link, error) {
	n := _Link{v}
	return &n, nil
}
type _Link__Maybe struct {
	m schema.Maybe
	v Link
}
type MaybeLink = *_Link__Maybe

func (m MaybeLink) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeLink) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeLink) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeLink) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeLink) Must() Link {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var _ ipld.Node = (Link)(&_Link{})
var _ schema.TypedNode = (Link)(&_Link{})
func (Link) Kind() ipld.Kind {
	return ipld.Kind_Link
}
func (Link) LookupByString(string) (ipld.Node, error) {
	return mixins.Link{"tasks.Link"}.LookupByString("")
}
func (Link) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Link{"tasks.Link"}.LookupByNode(nil)
}
func (Link) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Link{"tasks.Link"}.LookupByIndex(0)
}
func (Link) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Link{"tasks.Link"}.LookupBySegment(seg)
}
func (Link) MapIterator() ipld.MapIterator {
	return nil
}
func (Link) ListIterator() ipld.ListIterator {
	return nil
}
func (Link) Length() int64 {
	return -1
}
func (Link) IsAbsent() bool {
	return false
}
func (Link) IsNull() bool {
	return false
}
func (Link) AsBool() (bool, error) {
	return mixins.Link{"tasks.Link"}.AsBool()
}
func (Link) AsInt() (int64, error) {
	return mixins.Link{"tasks.Link"}.AsInt()
}
func (Link) AsFloat() (float64, error) {
	return mixins.Link{"tasks.Link"}.AsFloat()
}
func (Link) AsString() (string, error) {
	return mixins.Link{"tasks.Link"}.AsString()
}
func (Link) AsBytes() ([]byte, error) {
	return mixins.Link{"tasks.Link"}.AsBytes()
}
func (n Link) AsLink() (ipld.Link, error) {
	return n.x, nil
}
func (Link) Prototype() ipld.NodePrototype {
	return _Link__Prototype{}
}
type _Link__Prototype struct{}

func (_Link__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Link__Builder
	nb.Reset()
	return &nb
}
type _Link__Builder struct {
	_Link__Assembler
}
func (nb *_Link__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Link__Builder) Reset() {
	var w _Link
	var m schema.Maybe
	*nb = _Link__Builder{_Link__Assembler{w: &w, m: &m}}
}
type _Link__Assembler struct {
	w *_Link
	m *schema.Maybe
}

func (na *_Link__Assembler) reset() {}
func (_Link__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.LinkAssembler{"tasks.Link"}.BeginMap(0)
}
func (_Link__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.LinkAssembler{"tasks.Link"}.BeginList(0)
}
func (na *_Link__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.LinkAssembler{"tasks.Link"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_Link__Assembler) AssignBool(bool) error {
	return mixins.LinkAssembler{"tasks.Link"}.AssignBool(false)
}
func (_Link__Assembler) AssignInt(int64) error {
	return mixins.LinkAssembler{"tasks.Link"}.AssignInt(0)
}
func (_Link__Assembler) AssignFloat(float64) error {
	return mixins.LinkAssembler{"tasks.Link"}.AssignFloat(0)
}
func (_Link__Assembler) AssignString(string) error {
	return mixins.LinkAssembler{"tasks.Link"}.AssignString("")
}
func (_Link__Assembler) AssignBytes([]byte) error {
	return mixins.LinkAssembler{"tasks.Link"}.AssignBytes(nil)
}
func (na *_Link__Assembler) AssignLink(v ipld.Link) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_Link{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (na *_Link__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Link); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsLink(); err != nil {
		return err
	} else {
		return na.AssignLink(v2)
	}
}
func (_Link__Assembler) Prototype() ipld.NodePrototype {
	return _Link__Prototype{}
}
func (Link) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Link) Representation() ipld.Node {
	return (*_Link__Repr)(n)
}
type _Link__Repr = _Link
var _ ipld.Node = &_Link__Repr{}
type _Link__ReprPrototype = _Link__Prototype
type _Link__ReprAssembler = _Link__Assembler

func (n Link_FinishedTask) Link() ipld.Link {
	return n.x
}
func (_Link_FinishedTask__Prototype) FromLink(v ipld.Link) (Link_FinishedTask, error) {
	n := _Link_FinishedTask{v}
	return &n, nil
}
type _Link_FinishedTask__Maybe struct {
	m schema.Maybe
	v Link_FinishedTask
}
type MaybeLink_FinishedTask = *_Link_FinishedTask__Maybe

func (m MaybeLink_FinishedTask) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeLink_FinishedTask) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeLink_FinishedTask) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeLink_FinishedTask) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeLink_FinishedTask) Must() Link_FinishedTask {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var _ ipld.Node = (Link_FinishedTask)(&_Link_FinishedTask{})
var _ schema.TypedNode = (Link_FinishedTask)(&_Link_FinishedTask{})
func (Link_FinishedTask) Kind() ipld.Kind {
	return ipld.Kind_Link
}
func (Link_FinishedTask) LookupByString(string) (ipld.Node, error) {
	return mixins.Link{"tasks.Link_FinishedTask"}.LookupByString("")
}
func (Link_FinishedTask) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Link{"tasks.Link_FinishedTask"}.LookupByNode(nil)
}
func (Link_FinishedTask) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Link{"tasks.Link_FinishedTask"}.LookupByIndex(0)
}
func (Link_FinishedTask) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Link{"tasks.Link_FinishedTask"}.LookupBySegment(seg)
}
func (Link_FinishedTask) MapIterator() ipld.MapIterator {
	return nil
}
func (Link_FinishedTask) ListIterator() ipld.ListIterator {
	return nil
}
func (Link_FinishedTask) Length() int64 {
	return -1
}
func (Link_FinishedTask) IsAbsent() bool {
	return false
}
func (Link_FinishedTask) IsNull() bool {
	return false
}
func (Link_FinishedTask) AsBool() (bool, error) {
	return mixins.Link{"tasks.Link_FinishedTask"}.AsBool()
}
func (Link_FinishedTask) AsInt() (int64, error) {
	return mixins.Link{"tasks.Link_FinishedTask"}.AsInt()
}
func (Link_FinishedTask) AsFloat() (float64, error) {
	return mixins.Link{"tasks.Link_FinishedTask"}.AsFloat()
}
func (Link_FinishedTask) AsString() (string, error) {
	return mixins.Link{"tasks.Link_FinishedTask"}.AsString()
}
func (Link_FinishedTask) AsBytes() ([]byte, error) {
	return mixins.Link{"tasks.Link_FinishedTask"}.AsBytes()
}
func (n Link_FinishedTask) AsLink() (ipld.Link, error) {
	return n.x, nil
}
func (Link_FinishedTask) Prototype() ipld.NodePrototype {
	return _Link_FinishedTask__Prototype{}
}
type _Link_FinishedTask__Prototype struct{}

func (_Link_FinishedTask__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Link_FinishedTask__Builder
	nb.Reset()
	return &nb
}
type _Link_FinishedTask__Builder struct {
	_Link_FinishedTask__Assembler
}
func (nb *_Link_FinishedTask__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Link_FinishedTask__Builder) Reset() {
	var w _Link_FinishedTask
	var m schema.Maybe
	*nb = _Link_FinishedTask__Builder{_Link_FinishedTask__Assembler{w: &w, m: &m}}
}
type _Link_FinishedTask__Assembler struct {
	w *_Link_FinishedTask
	m *schema.Maybe
}

func (na *_Link_FinishedTask__Assembler) reset() {}
func (_Link_FinishedTask__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.LinkAssembler{"tasks.Link_FinishedTask"}.BeginMap(0)
}
func (_Link_FinishedTask__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.LinkAssembler{"tasks.Link_FinishedTask"}.BeginList(0)
}
func (na *_Link_FinishedTask__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.LinkAssembler{"tasks.Link_FinishedTask"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_Link_FinishedTask__Assembler) AssignBool(bool) error {
	return mixins.LinkAssembler{"tasks.Link_FinishedTask"}.AssignBool(false)
}
func (_Link_FinishedTask__Assembler) AssignInt(int64) error {
	return mixins.LinkAssembler{"tasks.Link_FinishedTask"}.AssignInt(0)
}
func (_Link_FinishedTask__Assembler) AssignFloat(float64) error {
	return mixins.LinkAssembler{"tasks.Link_FinishedTask"}.AssignFloat(0)
}
func (_Link_FinishedTask__Assembler) AssignString(string) error {
	return mixins.LinkAssembler{"tasks.Link_FinishedTask"}.AssignString("")
}
func (_Link_FinishedTask__Assembler) AssignBytes([]byte) error {
	return mixins.LinkAssembler{"tasks.Link_FinishedTask"}.AssignBytes(nil)
}
func (na *_Link_FinishedTask__Assembler) AssignLink(v ipld.Link) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_Link_FinishedTask{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (na *_Link_FinishedTask__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Link_FinishedTask); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsLink(); err != nil {
		return err
	} else {
		return na.AssignLink(v2)
	}
}
func (_Link_FinishedTask__Assembler) Prototype() ipld.NodePrototype {
	return _Link_FinishedTask__Prototype{}
}
func (Link_FinishedTask) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (Link_FinishedTask) LinkTargetNodePrototype() ipld.NodePrototype {
	return Type.Link_FinishedTask__Repr
}
func (n Link_FinishedTask) Representation() ipld.Node {
	return (*_Link_FinishedTask__Repr)(n)
}
type _Link_FinishedTask__Repr = _Link_FinishedTask
var _ ipld.Node = &_Link_FinishedTask__Repr{}
type _Link_FinishedTask__ReprPrototype = _Link_FinishedTask__Prototype
type _Link_FinishedTask__ReprAssembler = _Link_FinishedTask__Assembler

func (n Link_List_StageDetails) Link() ipld.Link {
	return n.x
}
func (_Link_List_StageDetails__Prototype) FromLink(v ipld.Link) (Link_List_StageDetails, error) {
	n := _Link_List_StageDetails{v}
	return &n, nil
}
type _Link_List_StageDetails__Maybe struct {
	m schema.Maybe
	v Link_List_StageDetails
}
type MaybeLink_List_StageDetails = *_Link_List_StageDetails__Maybe

func (m MaybeLink_List_StageDetails) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeLink_List_StageDetails) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeLink_List_StageDetails) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeLink_List_StageDetails) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeLink_List_StageDetails) Must() Link_List_StageDetails {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var _ ipld.Node = (Link_List_StageDetails)(&_Link_List_StageDetails{})
var _ schema.TypedNode = (Link_List_StageDetails)(&_Link_List_StageDetails{})
func (Link_List_StageDetails) Kind() ipld.Kind {
	return ipld.Kind_Link
}
func (Link_List_StageDetails) LookupByString(string) (ipld.Node, error) {
	return mixins.Link{"tasks.Link_List_StageDetails"}.LookupByString("")
}
func (Link_List_StageDetails) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Link{"tasks.Link_List_StageDetails"}.LookupByNode(nil)
}
func (Link_List_StageDetails) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Link{"tasks.Link_List_StageDetails"}.LookupByIndex(0)
}
func (Link_List_StageDetails) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Link{"tasks.Link_List_StageDetails"}.LookupBySegment(seg)
}
func (Link_List_StageDetails) MapIterator() ipld.MapIterator {
	return nil
}
func (Link_List_StageDetails) ListIterator() ipld.ListIterator {
	return nil
}
func (Link_List_StageDetails) Length() int64 {
	return -1
}
func (Link_List_StageDetails) IsAbsent() bool {
	return false
}
func (Link_List_StageDetails) IsNull() bool {
	return false
}
func (Link_List_StageDetails) AsBool() (bool, error) {
	return mixins.Link{"tasks.Link_List_StageDetails"}.AsBool()
}
func (Link_List_StageDetails) AsInt() (int64, error) {
	return mixins.Link{"tasks.Link_List_StageDetails"}.AsInt()
}
func (Link_List_StageDetails) AsFloat() (float64, error) {
	return mixins.Link{"tasks.Link_List_StageDetails"}.AsFloat()
}
func (Link_List_StageDetails) AsString() (string, error) {
	return mixins.Link{"tasks.Link_List_StageDetails"}.AsString()
}
func (Link_List_StageDetails) AsBytes() ([]byte, error) {
	return mixins.Link{"tasks.Link_List_StageDetails"}.AsBytes()
}
func (n Link_List_StageDetails) AsLink() (ipld.Link, error) {
	return n.x, nil
}
func (Link_List_StageDetails) Prototype() ipld.NodePrototype {
	return _Link_List_StageDetails__Prototype{}
}
type _Link_List_StageDetails__Prototype struct{}

func (_Link_List_StageDetails__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Link_List_StageDetails__Builder
	nb.Reset()
	return &nb
}
type _Link_List_StageDetails__Builder struct {
	_Link_List_StageDetails__Assembler
}
func (nb *_Link_List_StageDetails__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Link_List_StageDetails__Builder) Reset() {
	var w _Link_List_StageDetails
	var m schema.Maybe
	*nb = _Link_List_StageDetails__Builder{_Link_List_StageDetails__Assembler{w: &w, m: &m}}
}
type _Link_List_StageDetails__Assembler struct {
	w *_Link_List_StageDetails
	m *schema.Maybe
}

func (na *_Link_List_StageDetails__Assembler) reset() {}
func (_Link_List_StageDetails__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.LinkAssembler{"tasks.Link_List_StageDetails"}.BeginMap(0)
}
func (_Link_List_StageDetails__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.LinkAssembler{"tasks.Link_List_StageDetails"}.BeginList(0)
}
func (na *_Link_List_StageDetails__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.LinkAssembler{"tasks.Link_List_StageDetails"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_Link_List_StageDetails__Assembler) AssignBool(bool) error {
	return mixins.LinkAssembler{"tasks.Link_List_StageDetails"}.AssignBool(false)
}
func (_Link_List_StageDetails__Assembler) AssignInt(int64) error {
	return mixins.LinkAssembler{"tasks.Link_List_StageDetails"}.AssignInt(0)
}
func (_Link_List_StageDetails__Assembler) AssignFloat(float64) error {
	return mixins.LinkAssembler{"tasks.Link_List_StageDetails"}.AssignFloat(0)
}
func (_Link_List_StageDetails__Assembler) AssignString(string) error {
	return mixins.LinkAssembler{"tasks.Link_List_StageDetails"}.AssignString("")
}
func (_Link_List_StageDetails__Assembler) AssignBytes([]byte) error {
	return mixins.LinkAssembler{"tasks.Link_List_StageDetails"}.AssignBytes(nil)
}
func (na *_Link_List_StageDetails__Assembler) AssignLink(v ipld.Link) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_Link_List_StageDetails{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (na *_Link_List_StageDetails__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Link_List_StageDetails); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsLink(); err != nil {
		return err
	} else {
		return na.AssignLink(v2)
	}
}
func (_Link_List_StageDetails__Assembler) Prototype() ipld.NodePrototype {
	return _Link_List_StageDetails__Prototype{}
}
func (Link_List_StageDetails) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (Link_List_StageDetails) LinkTargetNodePrototype() ipld.NodePrototype {
	return Type.Link_List_StageDetails__Repr
}
func (n Link_List_StageDetails) Representation() ipld.Node {
	return (*_Link_List_StageDetails__Repr)(n)
}
type _Link_List_StageDetails__Repr = _Link_List_StageDetails
var _ ipld.Node = &_Link_List_StageDetails__Repr{}
type _Link_List_StageDetails__ReprPrototype = _Link_List_StageDetails__Prototype
type _Link_List_StageDetails__ReprAssembler = _Link_List_StageDetails__Assembler

func (n *_List) Lookup(idx int64) Any {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	if v.m == schema.Maybe_Null {
		return nil
	}
	return v.v
}
func (n *_List) LookupMaybe(idx int64) MaybeAny {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return v
}

var _List__valueAbsent = _Any__Maybe{m:schema.Maybe_Absent}
func (n List) Iterator() *List__Itr {
	return &List__Itr{n, 0}
}

type List__Itr struct {
	n List
	idx  int
}

func (itr *List__Itr) Next() (idx int64, v MaybeAny) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil
	}
	idx = int64(itr.idx)
	v = &itr.n.x[itr.idx]
	itr.idx++
	return
}
func (itr *List__Itr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

type _List__Maybe struct {
	m schema.Maybe
	v List
}
type MaybeList = *_List__Maybe

func (m MaybeList) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeList) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeList) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeList) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeList) Must() List {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var _ ipld.Node = (List)(&_List{})
var _ schema.TypedNode = (List)(&_List{})
func (List) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (List) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"tasks.List"}.LookupByString("")
}
func (n List) LookupByNode(k ipld.Node) (ipld.Node, error) {
	idx, err := k.AsInt()
	if err != nil {
		return nil, err
	}
	return n.LookupByIndex(idx)
}
func (n List) LookupByIndex(idx int64) (ipld.Node, error) {
	if n.Length() <= idx {
		return nil, ipld.ErrNotExists{ipld.PathSegmentOfInt(idx)}
	}
	v := &n.x[idx]
	if v.m == schema.Maybe_Null {
		return ipld.Null, nil
	}
	return v.v, nil
}
func (n List) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "tasks.List", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (List) MapIterator() ipld.MapIterator {
	return nil
}
func (n List) ListIterator() ipld.ListIterator {
	return &_List__ListItr{n, 0}
}

type _List__ListItr struct {
	n List
	idx  int
}

func (itr *_List__ListItr) Next() (idx int64, v ipld.Node, _ error) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil, ipld.ErrIteratorOverread{}
	}
	idx = int64(itr.idx)
	x := &itr.n.x[itr.idx]
	switch x.m {
	case schema.Maybe_Null:
		v = ipld.Null
	case schema.Maybe_Value:
		v = x.v
	}
	itr.idx++
	return
}
func (itr *_List__ListItr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

func (n List) Length() int64 {
	return int64(len(n.x))
}
func (List) IsAbsent() bool {
	return false
}
func (List) IsNull() bool {
	return false
}
func (List) AsBool() (bool, error) {
	return mixins.List{"tasks.List"}.AsBool()
}
func (List) AsInt() (int64, error) {
	return mixins.List{"tasks.List"}.AsInt()
}
func (List) AsFloat() (float64, error) {
	return mixins.List{"tasks.List"}.AsFloat()
}
func (List) AsString() (string, error) {
	return mixins.List{"tasks.List"}.AsString()
}
func (List) AsBytes() ([]byte, error) {
	return mixins.List{"tasks.List"}.AsBytes()
}
func (List) AsLink() (ipld.Link, error) {
	return mixins.List{"tasks.List"}.AsLink()
}
func (List) Prototype() ipld.NodePrototype {
	return _List__Prototype{}
}
type _List__Prototype struct{}

func (_List__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _List__Builder
	nb.Reset()
	return &nb
}
type _List__Builder struct {
	_List__Assembler
}
func (nb *_List__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_List__Builder) Reset() {
	var w _List
	var m schema.Maybe
	*nb = _List__Builder{_List__Assembler{w: &w, m: &m}}
}
type _List__Assembler struct {
	w *_List
	m *schema.Maybe
	state laState

	
	va _Any__Assembler
}

func (na *_List__Assembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_List__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"tasks.List"}.BeginMap(0)
}
func (na *_List__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_List{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_Any__Maybe, 0, sizeHint)
	}
	return na, nil
}
func (na *_List__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"tasks.List"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_List__Assembler) AssignBool(bool) error {
	return mixins.ListAssembler{"tasks.List"}.AssignBool(false)
}
func (_List__Assembler) AssignInt(int64) error {
	return mixins.ListAssembler{"tasks.List"}.AssignInt(0)
}
func (_List__Assembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"tasks.List"}.AssignFloat(0)
}
func (_List__Assembler) AssignString(string) error {
	return mixins.ListAssembler{"tasks.List"}.AssignString("")
}
func (_List__Assembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"tasks.List"}.AssignBytes(nil)
}
func (_List__Assembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"tasks.List"}.AssignLink(nil)
}
func (na *_List__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_List); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "tasks.List", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_List__Assembler) Prototype() ipld.NodePrototype {
	return _List__Prototype{}
}
func (la *_List__Assembler) valueFinishTidy() bool {
	row := &la.w.x[len(la.w.x)-1]
	switch row.m {
	case schema.Maybe_Value:
		row.v = la.va.w
		la.va.w = nil
		fallthrough
	case schema.Maybe_Null:
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_List__Assembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Any__Maybe{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.m = &row.m
	row.m = allowNull
	return &la.va
}
func (la *_List__Assembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_List__Assembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Any__Prototype{}
}
func (List) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n List) Representation() ipld.Node {
	return (*_List__Repr)(n)
}
type _List__Repr _List
var _ ipld.Node = &_List__Repr{}
func (_List__Repr) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (_List__Repr) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"tasks.List.Repr"}.LookupByString("")
}
func (nr *_List__Repr) LookupByNode(k ipld.Node) (ipld.Node, error) {
	v, err := (List)(nr).LookupByNode(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Any).Representation(), nil
}
func (nr *_List__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	v, err := (List)(nr).LookupByIndex(idx)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Any).Representation(), nil
}
func (n _List__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "tasks.List.Repr", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (_List__Repr) MapIterator() ipld.MapIterator {
	return nil
}
func (nr *_List__Repr) ListIterator() ipld.ListIterator {
	return &_List__ReprListItr{(List)(nr), 0}
}

type _List__ReprListItr _List__ListItr

func (itr *_List__ReprListItr) Next() (idx int64, v ipld.Node, err error) {
	idx, v, err = (*_List__ListItr)(itr).Next()
	if err != nil || v == ipld.Null {
		return
	}
	return idx, v.(Any).Representation(), nil
}
func (itr *_List__ReprListItr) Done() bool {
	return (*_List__ListItr)(itr).Done()
}

func (rn *_List__Repr) Length() int64 {
	return int64(len(rn.x))
}
func (_List__Repr) IsAbsent() bool {
	return false
}
func (_List__Repr) IsNull() bool {
	return false
}
func (_List__Repr) AsBool() (bool, error) {
	return mixins.List{"tasks.List.Repr"}.AsBool()
}
func (_List__Repr) AsInt() (int64, error) {
	return mixins.List{"tasks.List.Repr"}.AsInt()
}
func (_List__Repr) AsFloat() (float64, error) {
	return mixins.List{"tasks.List.Repr"}.AsFloat()
}
func (_List__Repr) AsString() (string, error) {
	return mixins.List{"tasks.List.Repr"}.AsString()
}
func (_List__Repr) AsBytes() ([]byte, error) {
	return mixins.List{"tasks.List.Repr"}.AsBytes()
}
func (_List__Repr) AsLink() (ipld.Link, error) {
	return mixins.List{"tasks.List.Repr"}.AsLink()
}
func (_List__Repr) Prototype() ipld.NodePrototype {
	return _List__ReprPrototype{}
}
type _List__ReprPrototype struct{}

func (_List__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _List__ReprBuilder
	nb.Reset()
	return &nb
}
type _List__ReprBuilder struct {
	_List__ReprAssembler
}
func (nb *_List__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_List__ReprBuilder) Reset() {
	var w _List
	var m schema.Maybe
	*nb = _List__ReprBuilder{_List__ReprAssembler{w: &w, m: &m}}
}
type _List__ReprAssembler struct {
	w *_List
	m *schema.Maybe
	state laState

	
	va _Any__ReprAssembler
}

func (na *_List__ReprAssembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_List__ReprAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"tasks.List.Repr"}.BeginMap(0)
}
func (na *_List__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_List{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_Any__Maybe, 0, sizeHint)
	}
	return na, nil
}
func (na *_List__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"tasks.List.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_List__ReprAssembler) AssignBool(bool) error {
	return mixins.ListAssembler{"tasks.List.Repr"}.AssignBool(false)
}
func (_List__ReprAssembler) AssignInt(int64) error {
	return mixins.ListAssembler{"tasks.List.Repr"}.AssignInt(0)
}
func (_List__ReprAssembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"tasks.List.Repr"}.AssignFloat(0)
}
func (_List__ReprAssembler) AssignString(string) error {
	return mixins.ListAssembler{"tasks.List.Repr"}.AssignString("")
}
func (_List__ReprAssembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"tasks.List.Repr"}.AssignBytes(nil)
}
func (_List__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"tasks.List.Repr"}.AssignLink(nil)
}
func (na *_List__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_List); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "tasks.List.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_List__ReprAssembler) Prototype() ipld.NodePrototype {
	return _List__ReprPrototype{}
}
func (la *_List__ReprAssembler) valueFinishTidy() bool {
	row := &la.w.x[len(la.w.x)-1]
	switch row.m {
	case schema.Maybe_Value:
		row.v = la.va.w
		la.va.w = nil
		fallthrough
	case schema.Maybe_Null:
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_List__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Any__Maybe{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.m = &row.m
	row.m = allowNull
	return &la.va
}
func (la *_List__ReprAssembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_List__ReprAssembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Any__ReprPrototype{}
}

func (n *_List_AuthenticatedRecord) Lookup(idx int64) AuthenticatedRecord {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return v
}
func (n *_List_AuthenticatedRecord) LookupMaybe(idx int64) MaybeAuthenticatedRecord {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return &_AuthenticatedRecord__Maybe{
		m: schema.Maybe_Value,
		v: v,
	}
}

var _List_AuthenticatedRecord__valueAbsent = _AuthenticatedRecord__Maybe{m:schema.Maybe_Absent}
func (n List_AuthenticatedRecord) Iterator() *List_AuthenticatedRecord__Itr {
	return &List_AuthenticatedRecord__Itr{n, 0}
}

type List_AuthenticatedRecord__Itr struct {
	n List_AuthenticatedRecord
	idx  int
}

func (itr *List_AuthenticatedRecord__Itr) Next() (idx int64, v AuthenticatedRecord) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil
	}
	idx = int64(itr.idx)
	v = &itr.n.x[itr.idx]
	itr.idx++
	return
}
func (itr *List_AuthenticatedRecord__Itr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

type _List_AuthenticatedRecord__Maybe struct {
	m schema.Maybe
	v List_AuthenticatedRecord
}
type MaybeList_AuthenticatedRecord = *_List_AuthenticatedRecord__Maybe

func (m MaybeList_AuthenticatedRecord) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeList_AuthenticatedRecord) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeList_AuthenticatedRecord) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeList_AuthenticatedRecord) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeList_AuthenticatedRecord) Must() List_AuthenticatedRecord {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var _ ipld.Node = (List_AuthenticatedRecord)(&_List_AuthenticatedRecord{})
var _ schema.TypedNode = (List_AuthenticatedRecord)(&_List_AuthenticatedRecord{})
func (List_AuthenticatedRecord) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (List_AuthenticatedRecord) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"tasks.List_AuthenticatedRecord"}.LookupByString("")
}
func (n List_AuthenticatedRecord) LookupByNode(k ipld.Node) (ipld.Node, error) {
	idx, err := k.AsInt()
	if err != nil {
		return nil, err
	}
	return n.LookupByIndex(idx)
}
func (n List_AuthenticatedRecord) LookupByIndex(idx int64) (ipld.Node, error) {
	if n.Length() <= idx {
		return nil, ipld.ErrNotExists{ipld.PathSegmentOfInt(idx)}
	}
	v := &n.x[idx]
	return v, nil
}
func (n List_AuthenticatedRecord) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "tasks.List_AuthenticatedRecord", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (List_AuthenticatedRecord) MapIterator() ipld.MapIterator {
	return nil
}
func (n List_AuthenticatedRecord) ListIterator() ipld.ListIterator {
	return &_List_AuthenticatedRecord__ListItr{n, 0}
}

type _List_AuthenticatedRecord__ListItr struct {
	n List_AuthenticatedRecord
	idx  int
}

func (itr *_List_AuthenticatedRecord__ListItr) Next() (idx int64, v ipld.Node, _ error) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil, ipld.ErrIteratorOverread{}
	}
	idx = int64(itr.idx)
	x := &itr.n.x[itr.idx]
	v = x
	itr.idx++
	return
}
func (itr *_List_AuthenticatedRecord__ListItr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

func (n List_AuthenticatedRecord) Length() int64 {
	return int64(len(n.x))
}
func (List_AuthenticatedRecord) IsAbsent() bool {
	return false
}
func (List_AuthenticatedRecord) IsNull() bool {
	return false
}
func (List_AuthenticatedRecord) AsBool() (bool, error) {
	return mixins.List{"tasks.List_AuthenticatedRecord"}.AsBool()
}
func (List_AuthenticatedRecord) AsInt() (int64, error) {
	return mixins.List{"tasks.List_AuthenticatedRecord"}.AsInt()
}
func (List_AuthenticatedRecord) AsFloat() (float64, error) {
	return mixins.List{"tasks.List_AuthenticatedRecord"}.AsFloat()
}
func (List_AuthenticatedRecord) AsString() (string, error) {
	return mixins.List{"tasks.List_AuthenticatedRecord"}.AsString()
}
func (List_AuthenticatedRecord) AsBytes() ([]byte, error) {
	return mixins.List{"tasks.List_AuthenticatedRecord"}.AsBytes()
}
func (List_AuthenticatedRecord) AsLink() (ipld.Link, error) {
	return mixins.List{"tasks.List_AuthenticatedRecord"}.AsLink()
}
func (List_AuthenticatedRecord) Prototype() ipld.NodePrototype {
	return _List_AuthenticatedRecord__Prototype{}
}
type _List_AuthenticatedRecord__Prototype struct{}

func (_List_AuthenticatedRecord__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _List_AuthenticatedRecord__Builder
	nb.Reset()
	return &nb
}
type _List_AuthenticatedRecord__Builder struct {
	_List_AuthenticatedRecord__Assembler
}
func (nb *_List_AuthenticatedRecord__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_List_AuthenticatedRecord__Builder) Reset() {
	var w _List_AuthenticatedRecord
	var m schema.Maybe
	*nb = _List_AuthenticatedRecord__Builder{_List_AuthenticatedRecord__Assembler{w: &w, m: &m}}
}
type _List_AuthenticatedRecord__Assembler struct {
	w *_List_AuthenticatedRecord
	m *schema.Maybe
	state laState

	cm schema.Maybe
	va _AuthenticatedRecord__Assembler
}

func (na *_List_AuthenticatedRecord__Assembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_List_AuthenticatedRecord__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"tasks.List_AuthenticatedRecord"}.BeginMap(0)
}
func (na *_List_AuthenticatedRecord__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_List_AuthenticatedRecord{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_AuthenticatedRecord, 0, sizeHint)
	}
	return na, nil
}
func (na *_List_AuthenticatedRecord__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"tasks.List_AuthenticatedRecord"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_List_AuthenticatedRecord__Assembler) AssignBool(bool) error {
	return mixins.ListAssembler{"tasks.List_AuthenticatedRecord"}.AssignBool(false)
}
func (_List_AuthenticatedRecord__Assembler) AssignInt(int64) error {
	return mixins.ListAssembler{"tasks.List_AuthenticatedRecord"}.AssignInt(0)
}
func (_List_AuthenticatedRecord__Assembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"tasks.List_AuthenticatedRecord"}.AssignFloat(0)
}
func (_List_AuthenticatedRecord__Assembler) AssignString(string) error {
	return mixins.ListAssembler{"tasks.List_AuthenticatedRecord"}.AssignString("")
}
func (_List_AuthenticatedRecord__Assembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"tasks.List_AuthenticatedRecord"}.AssignBytes(nil)
}
func (_List_AuthenticatedRecord__Assembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"tasks.List_AuthenticatedRecord"}.AssignLink(nil)
}
func (na *_List_AuthenticatedRecord__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_List_AuthenticatedRecord); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "tasks.List_AuthenticatedRecord", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_List_AuthenticatedRecord__Assembler) Prototype() ipld.NodePrototype {
	return _List_AuthenticatedRecord__Prototype{}
}
func (la *_List_AuthenticatedRecord__Assembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_List_AuthenticatedRecord__Assembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _AuthenticatedRecord{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_List_AuthenticatedRecord__Assembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_List_AuthenticatedRecord__Assembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _AuthenticatedRecord__Prototype{}
}
func (List_AuthenticatedRecord) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n List_AuthenticatedRecord) Representation() ipld.Node {
	return (*_List_AuthenticatedRecord__Repr)(n)
}
type _List_AuthenticatedRecord__Repr _List_AuthenticatedRecord
var _ ipld.Node = &_List_AuthenticatedRecord__Repr{}
func (_List_AuthenticatedRecord__Repr) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (_List_AuthenticatedRecord__Repr) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"tasks.List_AuthenticatedRecord.Repr"}.LookupByString("")
}
func (nr *_List_AuthenticatedRecord__Repr) LookupByNode(k ipld.Node) (ipld.Node, error) {
	v, err := (List_AuthenticatedRecord)(nr).LookupByNode(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(AuthenticatedRecord).Representation(), nil
}
func (nr *_List_AuthenticatedRecord__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	v, err := (List_AuthenticatedRecord)(nr).LookupByIndex(idx)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(AuthenticatedRecord).Representation(), nil
}
func (n _List_AuthenticatedRecord__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "tasks.List_AuthenticatedRecord.Repr", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (_List_AuthenticatedRecord__Repr) MapIterator() ipld.MapIterator {
	return nil
}
func (nr *_List_AuthenticatedRecord__Repr) ListIterator() ipld.ListIterator {
	return &_List_AuthenticatedRecord__ReprListItr{(List_AuthenticatedRecord)(nr), 0}
}

type _List_AuthenticatedRecord__ReprListItr _List_AuthenticatedRecord__ListItr

func (itr *_List_AuthenticatedRecord__ReprListItr) Next() (idx int64, v ipld.Node, err error) {
	idx, v, err = (*_List_AuthenticatedRecord__ListItr)(itr).Next()
	if err != nil || v == ipld.Null {
		return
	}
	return idx, v.(AuthenticatedRecord).Representation(), nil
}
func (itr *_List_AuthenticatedRecord__ReprListItr) Done() bool {
	return (*_List_AuthenticatedRecord__ListItr)(itr).Done()
}

func (rn *_List_AuthenticatedRecord__Repr) Length() int64 {
	return int64(len(rn.x))
}
func (_List_AuthenticatedRecord__Repr) IsAbsent() bool {
	return false
}
func (_List_AuthenticatedRecord__Repr) IsNull() bool {
	return false
}
func (_List_AuthenticatedRecord__Repr) AsBool() (bool, error) {
	return mixins.List{"tasks.List_AuthenticatedRecord.Repr"}.AsBool()
}
func (_List_AuthenticatedRecord__Repr) AsInt() (int64, error) {
	return mixins.List{"tasks.List_AuthenticatedRecord.Repr"}.AsInt()
}
func (_List_AuthenticatedRecord__Repr) AsFloat() (float64, error) {
	return mixins.List{"tasks.List_AuthenticatedRecord.Repr"}.AsFloat()
}
func (_List_AuthenticatedRecord__Repr) AsString() (string, error) {
	return mixins.List{"tasks.List_AuthenticatedRecord.Repr"}.AsString()
}
func (_List_AuthenticatedRecord__Repr) AsBytes() ([]byte, error) {
	return mixins.List{"tasks.List_AuthenticatedRecord.Repr"}.AsBytes()
}
func (_List_AuthenticatedRecord__Repr) AsLink() (ipld.Link, error) {
	return mixins.List{"tasks.List_AuthenticatedRecord.Repr"}.AsLink()
}
func (_List_AuthenticatedRecord__Repr) Prototype() ipld.NodePrototype {
	return _List_AuthenticatedRecord__ReprPrototype{}
}
type _List_AuthenticatedRecord__ReprPrototype struct{}

func (_List_AuthenticatedRecord__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _List_AuthenticatedRecord__ReprBuilder
	nb.Reset()
	return &nb
}
type _List_AuthenticatedRecord__ReprBuilder struct {
	_List_AuthenticatedRecord__ReprAssembler
}
func (nb *_List_AuthenticatedRecord__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_List_AuthenticatedRecord__ReprBuilder) Reset() {
	var w _List_AuthenticatedRecord
	var m schema.Maybe
	*nb = _List_AuthenticatedRecord__ReprBuilder{_List_AuthenticatedRecord__ReprAssembler{w: &w, m: &m}}
}
type _List_AuthenticatedRecord__ReprAssembler struct {
	w *_List_AuthenticatedRecord
	m *schema.Maybe
	state laState

	cm schema.Maybe
	va _AuthenticatedRecord__ReprAssembler
}

func (na *_List_AuthenticatedRecord__ReprAssembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_List_AuthenticatedRecord__ReprAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"tasks.List_AuthenticatedRecord.Repr"}.BeginMap(0)
}
func (na *_List_AuthenticatedRecord__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_List_AuthenticatedRecord{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_AuthenticatedRecord, 0, sizeHint)
	}
	return na, nil
}
func (na *_List_AuthenticatedRecord__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"tasks.List_AuthenticatedRecord.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_List_AuthenticatedRecord__ReprAssembler) AssignBool(bool) error {
	return mixins.ListAssembler{"tasks.List_AuthenticatedRecord.Repr"}.AssignBool(false)
}
func (_List_AuthenticatedRecord__ReprAssembler) AssignInt(int64) error {
	return mixins.ListAssembler{"tasks.List_AuthenticatedRecord.Repr"}.AssignInt(0)
}
func (_List_AuthenticatedRecord__ReprAssembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"tasks.List_AuthenticatedRecord.Repr"}.AssignFloat(0)
}
func (_List_AuthenticatedRecord__ReprAssembler) AssignString(string) error {
	return mixins.ListAssembler{"tasks.List_AuthenticatedRecord.Repr"}.AssignString("")
}
func (_List_AuthenticatedRecord__ReprAssembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"tasks.List_AuthenticatedRecord.Repr"}.AssignBytes(nil)
}
func (_List_AuthenticatedRecord__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"tasks.List_AuthenticatedRecord.Repr"}.AssignLink(nil)
}
func (na *_List_AuthenticatedRecord__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_List_AuthenticatedRecord); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "tasks.List_AuthenticatedRecord.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_List_AuthenticatedRecord__ReprAssembler) Prototype() ipld.NodePrototype {
	return _List_AuthenticatedRecord__ReprPrototype{}
}
func (la *_List_AuthenticatedRecord__ReprAssembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_List_AuthenticatedRecord__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _AuthenticatedRecord{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_List_AuthenticatedRecord__ReprAssembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_List_AuthenticatedRecord__ReprAssembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _AuthenticatedRecord__ReprPrototype{}
}

func (n *_List_Logs) Lookup(idx int64) Logs {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return v
}
func (n *_List_Logs) LookupMaybe(idx int64) MaybeLogs {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return &_Logs__Maybe{
		m: schema.Maybe_Value,
		v: v,
	}
}

var _List_Logs__valueAbsent = _Logs__Maybe{m:schema.Maybe_Absent}
func (n List_Logs) Iterator() *List_Logs__Itr {
	return &List_Logs__Itr{n, 0}
}

type List_Logs__Itr struct {
	n List_Logs
	idx  int
}

func (itr *List_Logs__Itr) Next() (idx int64, v Logs) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil
	}
	idx = int64(itr.idx)
	v = &itr.n.x[itr.idx]
	itr.idx++
	return
}
func (itr *List_Logs__Itr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

type _List_Logs__Maybe struct {
	m schema.Maybe
	v List_Logs
}
type MaybeList_Logs = *_List_Logs__Maybe

func (m MaybeList_Logs) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeList_Logs) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeList_Logs) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeList_Logs) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeList_Logs) Must() List_Logs {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var _ ipld.Node = (List_Logs)(&_List_Logs{})
var _ schema.TypedNode = (List_Logs)(&_List_Logs{})
func (List_Logs) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (List_Logs) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"tasks.List_Logs"}.LookupByString("")
}
func (n List_Logs) LookupByNode(k ipld.Node) (ipld.Node, error) {
	idx, err := k.AsInt()
	if err != nil {
		return nil, err
	}
	return n.LookupByIndex(idx)
}
func (n List_Logs) LookupByIndex(idx int64) (ipld.Node, error) {
	if n.Length() <= idx {
		return nil, ipld.ErrNotExists{ipld.PathSegmentOfInt(idx)}
	}
	v := &n.x[idx]
	return v, nil
}
func (n List_Logs) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "tasks.List_Logs", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (List_Logs) MapIterator() ipld.MapIterator {
	return nil
}
func (n List_Logs) ListIterator() ipld.ListIterator {
	return &_List_Logs__ListItr{n, 0}
}

type _List_Logs__ListItr struct {
	n List_Logs
	idx  int
}

func (itr *_List_Logs__ListItr) Next() (idx int64, v ipld.Node, _ error) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil, ipld.ErrIteratorOverread{}
	}
	idx = int64(itr.idx)
	x := &itr.n.x[itr.idx]
	v = x
	itr.idx++
	return
}
func (itr *_List_Logs__ListItr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

func (n List_Logs) Length() int64 {
	return int64(len(n.x))
}
func (List_Logs) IsAbsent() bool {
	return false
}
func (List_Logs) IsNull() bool {
	return false
}
func (List_Logs) AsBool() (bool, error) {
	return mixins.List{"tasks.List_Logs"}.AsBool()
}
func (List_Logs) AsInt() (int64, error) {
	return mixins.List{"tasks.List_Logs"}.AsInt()
}
func (List_Logs) AsFloat() (float64, error) {
	return mixins.List{"tasks.List_Logs"}.AsFloat()
}
func (List_Logs) AsString() (string, error) {
	return mixins.List{"tasks.List_Logs"}.AsString()
}
func (List_Logs) AsBytes() ([]byte, error) {
	return mixins.List{"tasks.List_Logs"}.AsBytes()
}
func (List_Logs) AsLink() (ipld.Link, error) {
	return mixins.List{"tasks.List_Logs"}.AsLink()
}
func (List_Logs) Prototype() ipld.NodePrototype {
	return _List_Logs__Prototype{}
}
type _List_Logs__Prototype struct{}

func (_List_Logs__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _List_Logs__Builder
	nb.Reset()
	return &nb
}
type _List_Logs__Builder struct {
	_List_Logs__Assembler
}
func (nb *_List_Logs__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_List_Logs__Builder) Reset() {
	var w _List_Logs
	var m schema.Maybe
	*nb = _List_Logs__Builder{_List_Logs__Assembler{w: &w, m: &m}}
}
type _List_Logs__Assembler struct {
	w *_List_Logs
	m *schema.Maybe
	state laState

	cm schema.Maybe
	va _Logs__Assembler
}

func (na *_List_Logs__Assembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_List_Logs__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"tasks.List_Logs"}.BeginMap(0)
}
func (na *_List_Logs__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_List_Logs{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_Logs, 0, sizeHint)
	}
	return na, nil
}
func (na *_List_Logs__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"tasks.List_Logs"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_List_Logs__Assembler) AssignBool(bool) error {
	return mixins.ListAssembler{"tasks.List_Logs"}.AssignBool(false)
}
func (_List_Logs__Assembler) AssignInt(int64) error {
	return mixins.ListAssembler{"tasks.List_Logs"}.AssignInt(0)
}
func (_List_Logs__Assembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"tasks.List_Logs"}.AssignFloat(0)
}
func (_List_Logs__Assembler) AssignString(string) error {
	return mixins.ListAssembler{"tasks.List_Logs"}.AssignString("")
}
func (_List_Logs__Assembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"tasks.List_Logs"}.AssignBytes(nil)
}
func (_List_Logs__Assembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"tasks.List_Logs"}.AssignLink(nil)
}
func (na *_List_Logs__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_List_Logs); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "tasks.List_Logs", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_List_Logs__Assembler) Prototype() ipld.NodePrototype {
	return _List_Logs__Prototype{}
}
func (la *_List_Logs__Assembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_List_Logs__Assembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Logs{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_List_Logs__Assembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_List_Logs__Assembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Logs__Prototype{}
}
func (List_Logs) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n List_Logs) Representation() ipld.Node {
	return (*_List_Logs__Repr)(n)
}
type _List_Logs__Repr _List_Logs
var _ ipld.Node = &_List_Logs__Repr{}
func (_List_Logs__Repr) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (_List_Logs__Repr) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"tasks.List_Logs.Repr"}.LookupByString("")
}
func (nr *_List_Logs__Repr) LookupByNode(k ipld.Node) (ipld.Node, error) {
	v, err := (List_Logs)(nr).LookupByNode(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Logs).Representation(), nil
}
func (nr *_List_Logs__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	v, err := (List_Logs)(nr).LookupByIndex(idx)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Logs).Representation(), nil
}
func (n _List_Logs__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "tasks.List_Logs.Repr", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (_List_Logs__Repr) MapIterator() ipld.MapIterator {
	return nil
}
func (nr *_List_Logs__Repr) ListIterator() ipld.ListIterator {
	return &_List_Logs__ReprListItr{(List_Logs)(nr), 0}
}

type _List_Logs__ReprListItr _List_Logs__ListItr

func (itr *_List_Logs__ReprListItr) Next() (idx int64, v ipld.Node, err error) {
	idx, v, err = (*_List_Logs__ListItr)(itr).Next()
	if err != nil || v == ipld.Null {
		return
	}
	return idx, v.(Logs).Representation(), nil
}
func (itr *_List_Logs__ReprListItr) Done() bool {
	return (*_List_Logs__ListItr)(itr).Done()
}

func (rn *_List_Logs__Repr) Length() int64 {
	return int64(len(rn.x))
}
func (_List_Logs__Repr) IsAbsent() bool {
	return false
}
func (_List_Logs__Repr) IsNull() bool {
	return false
}
func (_List_Logs__Repr) AsBool() (bool, error) {
	return mixins.List{"tasks.List_Logs.Repr"}.AsBool()
}
func (_List_Logs__Repr) AsInt() (int64, error) {
	return mixins.List{"tasks.List_Logs.Repr"}.AsInt()
}
func (_List_Logs__Repr) AsFloat() (float64, error) {
	return mixins.List{"tasks.List_Logs.Repr"}.AsFloat()
}
func (_List_Logs__Repr) AsString() (string, error) {
	return mixins.List{"tasks.List_Logs.Repr"}.AsString()
}
func (_List_Logs__Repr) AsBytes() ([]byte, error) {
	return mixins.List{"tasks.List_Logs.Repr"}.AsBytes()
}
func (_List_Logs__Repr) AsLink() (ipld.Link, error) {
	return mixins.List{"tasks.List_Logs.Repr"}.AsLink()
}
func (_List_Logs__Repr) Prototype() ipld.NodePrototype {
	return _List_Logs__ReprPrototype{}
}
type _List_Logs__ReprPrototype struct{}

func (_List_Logs__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _List_Logs__ReprBuilder
	nb.Reset()
	return &nb
}
type _List_Logs__ReprBuilder struct {
	_List_Logs__ReprAssembler
}
func (nb *_List_Logs__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_List_Logs__ReprBuilder) Reset() {
	var w _List_Logs
	var m schema.Maybe
	*nb = _List_Logs__ReprBuilder{_List_Logs__ReprAssembler{w: &w, m: &m}}
}
type _List_Logs__ReprAssembler struct {
	w *_List_Logs
	m *schema.Maybe
	state laState

	cm schema.Maybe
	va _Logs__ReprAssembler
}

func (na *_List_Logs__ReprAssembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_List_Logs__ReprAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"tasks.List_Logs.Repr"}.BeginMap(0)
}
func (na *_List_Logs__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_List_Logs{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_Logs, 0, sizeHint)
	}
	return na, nil
}
func (na *_List_Logs__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"tasks.List_Logs.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_List_Logs__ReprAssembler) AssignBool(bool) error {
	return mixins.ListAssembler{"tasks.List_Logs.Repr"}.AssignBool(false)
}
func (_List_Logs__ReprAssembler) AssignInt(int64) error {
	return mixins.ListAssembler{"tasks.List_Logs.Repr"}.AssignInt(0)
}
func (_List_Logs__ReprAssembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"tasks.List_Logs.Repr"}.AssignFloat(0)
}
func (_List_Logs__ReprAssembler) AssignString(string) error {
	return mixins.ListAssembler{"tasks.List_Logs.Repr"}.AssignString("")
}
func (_List_Logs__ReprAssembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"tasks.List_Logs.Repr"}.AssignBytes(nil)
}
func (_List_Logs__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"tasks.List_Logs.Repr"}.AssignLink(nil)
}
func (na *_List_Logs__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_List_Logs); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "tasks.List_Logs.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_List_Logs__ReprAssembler) Prototype() ipld.NodePrototype {
	return _List_Logs__ReprPrototype{}
}
func (la *_List_Logs__ReprAssembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_List_Logs__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Logs{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_List_Logs__ReprAssembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_List_Logs__ReprAssembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Logs__ReprPrototype{}
}

func (n *_List_StageDetails) Lookup(idx int64) StageDetails {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return v
}
func (n *_List_StageDetails) LookupMaybe(idx int64) MaybeStageDetails {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return &_StageDetails__Maybe{
		m: schema.Maybe_Value,
		v: v,
	}
}

var _List_StageDetails__valueAbsent = _StageDetails__Maybe{m:schema.Maybe_Absent}
func (n List_StageDetails) Iterator() *List_StageDetails__Itr {
	return &List_StageDetails__Itr{n, 0}
}

type List_StageDetails__Itr struct {
	n List_StageDetails
	idx  int
}

func (itr *List_StageDetails__Itr) Next() (idx int64, v StageDetails) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil
	}
	idx = int64(itr.idx)
	v = &itr.n.x[itr.idx]
	itr.idx++
	return
}
func (itr *List_StageDetails__Itr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

type _List_StageDetails__Maybe struct {
	m schema.Maybe
	v List_StageDetails
}
type MaybeList_StageDetails = *_List_StageDetails__Maybe

func (m MaybeList_StageDetails) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeList_StageDetails) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeList_StageDetails) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeList_StageDetails) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeList_StageDetails) Must() List_StageDetails {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var _ ipld.Node = (List_StageDetails)(&_List_StageDetails{})
var _ schema.TypedNode = (List_StageDetails)(&_List_StageDetails{})
func (List_StageDetails) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (List_StageDetails) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"tasks.List_StageDetails"}.LookupByString("")
}
func (n List_StageDetails) LookupByNode(k ipld.Node) (ipld.Node, error) {
	idx, err := k.AsInt()
	if err != nil {
		return nil, err
	}
	return n.LookupByIndex(idx)
}
func (n List_StageDetails) LookupByIndex(idx int64) (ipld.Node, error) {
	if n.Length() <= idx {
		return nil, ipld.ErrNotExists{ipld.PathSegmentOfInt(idx)}
	}
	v := &n.x[idx]
	return v, nil
}
func (n List_StageDetails) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "tasks.List_StageDetails", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (List_StageDetails) MapIterator() ipld.MapIterator {
	return nil
}
func (n List_StageDetails) ListIterator() ipld.ListIterator {
	return &_List_StageDetails__ListItr{n, 0}
}

type _List_StageDetails__ListItr struct {
	n List_StageDetails
	idx  int
}

func (itr *_List_StageDetails__ListItr) Next() (idx int64, v ipld.Node, _ error) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil, ipld.ErrIteratorOverread{}
	}
	idx = int64(itr.idx)
	x := &itr.n.x[itr.idx]
	v = x
	itr.idx++
	return
}
func (itr *_List_StageDetails__ListItr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

func (n List_StageDetails) Length() int64 {
	return int64(len(n.x))
}
func (List_StageDetails) IsAbsent() bool {
	return false
}
func (List_StageDetails) IsNull() bool {
	return false
}
func (List_StageDetails) AsBool() (bool, error) {
	return mixins.List{"tasks.List_StageDetails"}.AsBool()
}
func (List_StageDetails) AsInt() (int64, error) {
	return mixins.List{"tasks.List_StageDetails"}.AsInt()
}
func (List_StageDetails) AsFloat() (float64, error) {
	return mixins.List{"tasks.List_StageDetails"}.AsFloat()
}
func (List_StageDetails) AsString() (string, error) {
	return mixins.List{"tasks.List_StageDetails"}.AsString()
}
func (List_StageDetails) AsBytes() ([]byte, error) {
	return mixins.List{"tasks.List_StageDetails"}.AsBytes()
}
func (List_StageDetails) AsLink() (ipld.Link, error) {
	return mixins.List{"tasks.List_StageDetails"}.AsLink()
}
func (List_StageDetails) Prototype() ipld.NodePrototype {
	return _List_StageDetails__Prototype{}
}
type _List_StageDetails__Prototype struct{}

func (_List_StageDetails__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _List_StageDetails__Builder
	nb.Reset()
	return &nb
}
type _List_StageDetails__Builder struct {
	_List_StageDetails__Assembler
}
func (nb *_List_StageDetails__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_List_StageDetails__Builder) Reset() {
	var w _List_StageDetails
	var m schema.Maybe
	*nb = _List_StageDetails__Builder{_List_StageDetails__Assembler{w: &w, m: &m}}
}
type _List_StageDetails__Assembler struct {
	w *_List_StageDetails
	m *schema.Maybe
	state laState

	cm schema.Maybe
	va _StageDetails__Assembler
}

func (na *_List_StageDetails__Assembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_List_StageDetails__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"tasks.List_StageDetails"}.BeginMap(0)
}
func (na *_List_StageDetails__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_List_StageDetails{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_StageDetails, 0, sizeHint)
	}
	return na, nil
}
func (na *_List_StageDetails__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"tasks.List_StageDetails"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_List_StageDetails__Assembler) AssignBool(bool) error {
	return mixins.ListAssembler{"tasks.List_StageDetails"}.AssignBool(false)
}
func (_List_StageDetails__Assembler) AssignInt(int64) error {
	return mixins.ListAssembler{"tasks.List_StageDetails"}.AssignInt(0)
}
func (_List_StageDetails__Assembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"tasks.List_StageDetails"}.AssignFloat(0)
}
func (_List_StageDetails__Assembler) AssignString(string) error {
	return mixins.ListAssembler{"tasks.List_StageDetails"}.AssignString("")
}
func (_List_StageDetails__Assembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"tasks.List_StageDetails"}.AssignBytes(nil)
}
func (_List_StageDetails__Assembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"tasks.List_StageDetails"}.AssignLink(nil)
}
func (na *_List_StageDetails__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_List_StageDetails); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "tasks.List_StageDetails", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_List_StageDetails__Assembler) Prototype() ipld.NodePrototype {
	return _List_StageDetails__Prototype{}
}
func (la *_List_StageDetails__Assembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_List_StageDetails__Assembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _StageDetails{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_List_StageDetails__Assembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_List_StageDetails__Assembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _StageDetails__Prototype{}
}
func (List_StageDetails) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n List_StageDetails) Representation() ipld.Node {
	return (*_List_StageDetails__Repr)(n)
}
type _List_StageDetails__Repr _List_StageDetails
var _ ipld.Node = &_List_StageDetails__Repr{}
func (_List_StageDetails__Repr) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (_List_StageDetails__Repr) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"tasks.List_StageDetails.Repr"}.LookupByString("")
}
func (nr *_List_StageDetails__Repr) LookupByNode(k ipld.Node) (ipld.Node, error) {
	v, err := (List_StageDetails)(nr).LookupByNode(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(StageDetails).Representation(), nil
}
func (nr *_List_StageDetails__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	v, err := (List_StageDetails)(nr).LookupByIndex(idx)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(StageDetails).Representation(), nil
}
func (n _List_StageDetails__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "tasks.List_StageDetails.Repr", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (_List_StageDetails__Repr) MapIterator() ipld.MapIterator {
	return nil
}
func (nr *_List_StageDetails__Repr) ListIterator() ipld.ListIterator {
	return &_List_StageDetails__ReprListItr{(List_StageDetails)(nr), 0}
}

type _List_StageDetails__ReprListItr _List_StageDetails__ListItr

func (itr *_List_StageDetails__ReprListItr) Next() (idx int64, v ipld.Node, err error) {
	idx, v, err = (*_List_StageDetails__ListItr)(itr).Next()
	if err != nil || v == ipld.Null {
		return
	}
	return idx, v.(StageDetails).Representation(), nil
}
func (itr *_List_StageDetails__ReprListItr) Done() bool {
	return (*_List_StageDetails__ListItr)(itr).Done()
}

func (rn *_List_StageDetails__Repr) Length() int64 {
	return int64(len(rn.x))
}
func (_List_StageDetails__Repr) IsAbsent() bool {
	return false
}
func (_List_StageDetails__Repr) IsNull() bool {
	return false
}
func (_List_StageDetails__Repr) AsBool() (bool, error) {
	return mixins.List{"tasks.List_StageDetails.Repr"}.AsBool()
}
func (_List_StageDetails__Repr) AsInt() (int64, error) {
	return mixins.List{"tasks.List_StageDetails.Repr"}.AsInt()
}
func (_List_StageDetails__Repr) AsFloat() (float64, error) {
	return mixins.List{"tasks.List_StageDetails.Repr"}.AsFloat()
}
func (_List_StageDetails__Repr) AsString() (string, error) {
	return mixins.List{"tasks.List_StageDetails.Repr"}.AsString()
}
func (_List_StageDetails__Repr) AsBytes() ([]byte, error) {
	return mixins.List{"tasks.List_StageDetails.Repr"}.AsBytes()
}
func (_List_StageDetails__Repr) AsLink() (ipld.Link, error) {
	return mixins.List{"tasks.List_StageDetails.Repr"}.AsLink()
}
func (_List_StageDetails__Repr) Prototype() ipld.NodePrototype {
	return _List_StageDetails__ReprPrototype{}
}
type _List_StageDetails__ReprPrototype struct{}

func (_List_StageDetails__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _List_StageDetails__ReprBuilder
	nb.Reset()
	return &nb
}
type _List_StageDetails__ReprBuilder struct {
	_List_StageDetails__ReprAssembler
}
func (nb *_List_StageDetails__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_List_StageDetails__ReprBuilder) Reset() {
	var w _List_StageDetails
	var m schema.Maybe
	*nb = _List_StageDetails__ReprBuilder{_List_StageDetails__ReprAssembler{w: &w, m: &m}}
}
type _List_StageDetails__ReprAssembler struct {
	w *_List_StageDetails
	m *schema.Maybe
	state laState

	cm schema.Maybe
	va _StageDetails__ReprAssembler
}

func (na *_List_StageDetails__ReprAssembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_List_StageDetails__ReprAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"tasks.List_StageDetails.Repr"}.BeginMap(0)
}
func (na *_List_StageDetails__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_List_StageDetails{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_StageDetails, 0, sizeHint)
	}
	return na, nil
}
func (na *_List_StageDetails__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"tasks.List_StageDetails.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_List_StageDetails__ReprAssembler) AssignBool(bool) error {
	return mixins.ListAssembler{"tasks.List_StageDetails.Repr"}.AssignBool(false)
}
func (_List_StageDetails__ReprAssembler) AssignInt(int64) error {
	return mixins.ListAssembler{"tasks.List_StageDetails.Repr"}.AssignInt(0)
}
func (_List_StageDetails__ReprAssembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"tasks.List_StageDetails.Repr"}.AssignFloat(0)
}
func (_List_StageDetails__ReprAssembler) AssignString(string) error {
	return mixins.ListAssembler{"tasks.List_StageDetails.Repr"}.AssignString("")
}
func (_List_StageDetails__ReprAssembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"tasks.List_StageDetails.Repr"}.AssignBytes(nil)
}
func (_List_StageDetails__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"tasks.List_StageDetails.Repr"}.AssignLink(nil)
}
func (na *_List_StageDetails__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_List_StageDetails); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "tasks.List_StageDetails.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_List_StageDetails__ReprAssembler) Prototype() ipld.NodePrototype {
	return _List_StageDetails__ReprPrototype{}
}
func (la *_List_StageDetails__ReprAssembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_List_StageDetails__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _StageDetails{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_List_StageDetails__ReprAssembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_List_StageDetails__ReprAssembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _StageDetails__ReprPrototype{}
}


func (n _Logs) FieldLog() String {
	return &n.Log
}
func (n _Logs) FieldUpdatedAt() Time {
	return &n.UpdatedAt
}
type _Logs__Maybe struct {
	m schema.Maybe
	v Logs
}
type MaybeLogs = *_Logs__Maybe

func (m MaybeLogs) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeLogs) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeLogs) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeLogs) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeLogs) Must() Logs {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
	fieldName__Logs_Log = _String{"Log"}
	fieldName__Logs_UpdatedAt = _String{"UpdatedAt"}
)
var _ ipld.Node = (Logs)(&_Logs{})
var _ schema.TypedNode = (Logs)(&_Logs{})
func (Logs) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n Logs) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Log":
		return &n.Log, nil
	case "UpdatedAt":
		return &n.UpdatedAt, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n Logs) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (Logs) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"tasks.Logs"}.LookupByIndex(0)
}
func (n Logs) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n Logs) MapIterator() ipld.MapIterator {
	return &_Logs__MapItr{n, 0}
}

type _Logs__MapItr struct {
	n Logs
	idx  int
}

func (itr *_Logs__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Logs_Log
		v = &itr.n.Log
	case 1:
		k = &fieldName__Logs_UpdatedAt
		v = &itr.n.UpdatedAt
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Logs__MapItr) Done() bool {
	return itr.idx >= 2
}

func (Logs) ListIterator() ipld.ListIterator {
	return nil
}
func (Logs) Length() int64 {
	return 2
}
func (Logs) IsAbsent() bool {
	return false
}
func (Logs) IsNull() bool {
	return false
}
func (Logs) AsBool() (bool, error) {
	return mixins.Map{"tasks.Logs"}.AsBool()
}
func (Logs) AsInt() (int64, error) {
	return mixins.Map{"tasks.Logs"}.AsInt()
}
func (Logs) AsFloat() (float64, error) {
	return mixins.Map{"tasks.Logs"}.AsFloat()
}
func (Logs) AsString() (string, error) {
	return mixins.Map{"tasks.Logs"}.AsString()
}
func (Logs) AsBytes() ([]byte, error) {
	return mixins.Map{"tasks.Logs"}.AsBytes()
}
func (Logs) AsLink() (ipld.Link, error) {
	return mixins.Map{"tasks.Logs"}.AsLink()
}
func (Logs) Prototype() ipld.NodePrototype {
	return _Logs__Prototype{}
}
type _Logs__Prototype struct{}

func (_Logs__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Logs__Builder
	nb.Reset()
	return &nb
}
type _Logs__Builder struct {
	_Logs__Assembler
}
func (nb *_Logs__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Logs__Builder) Reset() {
	var w _Logs
	var m schema.Maybe
	*nb = _Logs__Builder{_Logs__Assembler{w: &w, m: &m}}
}
type _Logs__Assembler struct {
	w *_Logs
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_Log _String__Assembler
	ca_UpdatedAt _Time__Assembler
	}

func (na *_Logs__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Log.reset()
	na.ca_UpdatedAt.reset()
}

var (
	fieldBit__Logs_Log = 1 << 0
	fieldBit__Logs_UpdatedAt = 1 << 1
	fieldBits__Logs_sufficient = 0 + 1 << 0 + 1 << 1
)
func (na *_Logs__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Logs{}
	}
	return na, nil
}
func (_Logs__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"tasks.Logs"}.BeginList(0)
}
func (na *_Logs__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"tasks.Logs"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Logs__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"tasks.Logs"}.AssignBool(false)
}
func (_Logs__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"tasks.Logs"}.AssignInt(0)
}
func (_Logs__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"tasks.Logs"}.AssignFloat(0)
}
func (_Logs__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"tasks.Logs"}.AssignString("")
}
func (_Logs__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"tasks.Logs"}.AssignBytes(nil)
}
func (_Logs__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"tasks.Logs"}.AssignLink(nil)
}
func (na *_Logs__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Logs); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "tasks.Logs", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Logs__Assembler) Prototype() ipld.NodePrototype {
	return _Logs__Prototype{}
}
func (ma *_Logs__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Log.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_UpdatedAt.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Logs__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Log":
		if ma.s & fieldBit__Logs_Log != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__Logs_Log}
		}
		ma.s += fieldBit__Logs_Log
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Log.w = &ma.w.Log
		ma.ca_Log.m = &ma.cm
		return &ma.ca_Log, nil
	case "UpdatedAt":
		if ma.s & fieldBit__Logs_UpdatedAt != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__Logs_UpdatedAt}
		}
		ma.s += fieldBit__Logs_UpdatedAt
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_UpdatedAt.w = &ma.w.UpdatedAt
		ma.ca_UpdatedAt.m = &ma.cm
		return &ma.ca_UpdatedAt, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"tasks.Logs", Key:&_String{k}}
	}
}
func (ma *_Logs__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Logs__KeyAssembler)(ma)
}
func (ma *_Logs__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Log.w = &ma.w.Log
		ma.ca_Log.m = &ma.cm
		return &ma.ca_Log
	case 1:
		ma.ca_UpdatedAt.w = &ma.w.UpdatedAt
		ma.ca_UpdatedAt.m = &ma.cm
		return &ma.ca_UpdatedAt
	default:
		panic("unreachable")
	}
}
func (ma *_Logs__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s & fieldBits__Logs_sufficient != fieldBits__Logs_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s & fieldBit__Logs_Log == 0 {
			err.Missing = append(err.Missing, "Log")
		}
		if ma.s & fieldBit__Logs_UpdatedAt == 0 {
			err.Missing = append(err.Missing, "UpdatedAt")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Logs__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Logs__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}
type _Logs__KeyAssembler _Logs__Assembler
func (_Logs__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"tasks.Logs.KeyAssembler"}.BeginMap(0)
}
func (_Logs__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"tasks.Logs.KeyAssembler"}.BeginList(0)
}
func (na *_Logs__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"tasks.Logs.KeyAssembler"}.AssignNull()
}
func (_Logs__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"tasks.Logs.KeyAssembler"}.AssignBool(false)
}
func (_Logs__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"tasks.Logs.KeyAssembler"}.AssignInt(0)
}
func (_Logs__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"tasks.Logs.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Logs__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Log":
		if ka.s & fieldBit__Logs_Log != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__Logs_Log}
		}
		ka.s += fieldBit__Logs_Log
		ka.state = maState_expectValue
		ka.f = 0
	case "UpdatedAt":
		if ka.s & fieldBit__Logs_UpdatedAt != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__Logs_UpdatedAt}
		}
		ka.s += fieldBit__Logs_UpdatedAt
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName:"tasks.Logs", Key:&_String{k}}
	}
	return nil
}
func (_Logs__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"tasks.Logs.KeyAssembler"}.AssignBytes(nil)
}
func (_Logs__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"tasks.Logs.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Logs__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Logs__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (Logs) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Logs) Representation() ipld.Node {
	return (*_Logs__Repr)(n)
}
type _Logs__Repr _Logs
var (
	fieldName__Logs_Log_serial = _String{"Log"}
	fieldName__Logs_UpdatedAt_serial = _String{"UpdatedAt"}
)
var _ ipld.Node = &_Logs__Repr{}
func (_Logs__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_Logs__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Log":
		return n.Log.Representation(), nil
	case "UpdatedAt":
		return n.UpdatedAt.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_Logs__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_Logs__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"tasks.Logs.Repr"}.LookupByIndex(0)
}
func (n _Logs__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_Logs__Repr) MapIterator() ipld.MapIterator {
	return &_Logs__ReprMapItr{n, 0}
}

type _Logs__ReprMapItr struct {
	n   *_Logs__Repr
	idx int
	
}

func (itr *_Logs__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Logs_Log_serial
		v = itr.n.Log.Representation()
	case 1:
		k = &fieldName__Logs_UpdatedAt_serial
		v = itr.n.UpdatedAt.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Logs__ReprMapItr) Done() bool {
	return itr.idx >= 2
}
func (_Logs__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_Logs__Repr) Length() int64 {
	l := 2
	return int64(l)
}
func (_Logs__Repr) IsAbsent() bool {
	return false
}
func (_Logs__Repr) IsNull() bool {
	return false
}
func (_Logs__Repr) AsBool() (bool, error) {
	return mixins.Map{"tasks.Logs.Repr"}.AsBool()
}
func (_Logs__Repr) AsInt() (int64, error) {
	return mixins.Map{"tasks.Logs.Repr"}.AsInt()
}
func (_Logs__Repr) AsFloat() (float64, error) {
	return mixins.Map{"tasks.Logs.Repr"}.AsFloat()
}
func (_Logs__Repr) AsString() (string, error) {
	return mixins.Map{"tasks.Logs.Repr"}.AsString()
}
func (_Logs__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"tasks.Logs.Repr"}.AsBytes()
}
func (_Logs__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"tasks.Logs.Repr"}.AsLink()
}
func (_Logs__Repr) Prototype() ipld.NodePrototype {
	return _Logs__ReprPrototype{}
}
type _Logs__ReprPrototype struct{}

func (_Logs__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Logs__ReprBuilder
	nb.Reset()
	return &nb
}
type _Logs__ReprBuilder struct {
	_Logs__ReprAssembler
}
func (nb *_Logs__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Logs__ReprBuilder) Reset() {
	var w _Logs
	var m schema.Maybe
	*nb = _Logs__ReprBuilder{_Logs__ReprAssembler{w: &w, m: &m}}
}
type _Logs__ReprAssembler struct {
	w *_Logs
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_Log _String__ReprAssembler
	ca_UpdatedAt _Time__ReprAssembler
	}

func (na *_Logs__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Log.reset()
	na.ca_UpdatedAt.reset()
}
func (na *_Logs__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Logs{}
	}
	return na, nil
}
func (_Logs__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"tasks.Logs.Repr"}.BeginList(0)
}
func (na *_Logs__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"tasks.Logs.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Logs__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"tasks.Logs.Repr"}.AssignBool(false)
}
func (_Logs__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"tasks.Logs.Repr"}.AssignInt(0)
}
func (_Logs__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"tasks.Logs.Repr"}.AssignFloat(0)
}
func (_Logs__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"tasks.Logs.Repr"}.AssignString("")
}
func (_Logs__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"tasks.Logs.Repr"}.AssignBytes(nil)
}
func (_Logs__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"tasks.Logs.Repr"}.AssignLink(nil)
}
func (na *_Logs__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Logs); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "tasks.Logs.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Logs__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Logs__ReprPrototype{}
}
func (ma *_Logs__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Logs__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Log":
		if ma.s & fieldBit__Logs_Log != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__Logs_Log_serial}
		}
		ma.s += fieldBit__Logs_Log
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Log.w = &ma.w.Log
		ma.ca_Log.m = &ma.cm
		return &ma.ca_Log, nil
	case "UpdatedAt":
		if ma.s & fieldBit__Logs_UpdatedAt != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__Logs_UpdatedAt_serial}
		}
		ma.s += fieldBit__Logs_UpdatedAt
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_UpdatedAt.w = &ma.w.UpdatedAt
		ma.ca_UpdatedAt.m = &ma.cm
		return &ma.ca_UpdatedAt, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"tasks.Logs.Repr", Key:&_String{k}}
	}
}
func (ma *_Logs__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Logs__ReprKeyAssembler)(ma)
}
func (ma *_Logs__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Log.w = &ma.w.Log
		ma.ca_Log.m = &ma.cm
		return &ma.ca_Log
	case 1:
		ma.ca_UpdatedAt.w = &ma.w.UpdatedAt
		ma.ca_UpdatedAt.m = &ma.cm
		return &ma.ca_UpdatedAt
	default:
		panic("unreachable")
	}
}
func (ma *_Logs__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s & fieldBits__Logs_sufficient != fieldBits__Logs_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s & fieldBit__Logs_Log == 0 {
			err.Missing = append(err.Missing, "Log")
		}
		if ma.s & fieldBit__Logs_UpdatedAt == 0 {
			err.Missing = append(err.Missing, "UpdatedAt")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Logs__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Logs__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}
type _Logs__ReprKeyAssembler _Logs__ReprAssembler
func (_Logs__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"tasks.Logs.Repr.KeyAssembler"}.BeginMap(0)
}
func (_Logs__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"tasks.Logs.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_Logs__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"tasks.Logs.Repr.KeyAssembler"}.AssignNull()
}
func (_Logs__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"tasks.Logs.Repr.KeyAssembler"}.AssignBool(false)
}
func (_Logs__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"tasks.Logs.Repr.KeyAssembler"}.AssignInt(0)
}
func (_Logs__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"tasks.Logs.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Logs__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Log":
		if ka.s & fieldBit__Logs_Log != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__Logs_Log_serial}
		}
		ka.s += fieldBit__Logs_Log
		ka.state = maState_expectValue
		ka.f = 0
	case "UpdatedAt":
		if ka.s & fieldBit__Logs_UpdatedAt != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__Logs_UpdatedAt_serial}
		}
		ka.s += fieldBit__Logs_UpdatedAt
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName:"tasks.Logs.Repr", Key:&_String{k}}
	}
	return nil
}
func (_Logs__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"tasks.Logs.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_Logs__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"tasks.Logs.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Logs__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Logs__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n *_Map) Lookup(k String) Any {
	v, exists := n.m[*k]
	if !exists {
		return nil
	}
	if v.m == schema.Maybe_Null {
		return nil
	}
	return v.v
}
func (n *_Map) LookupMaybe(k String) MaybeAny {
	v, exists := n.m[*k]
	if !exists {
		return &_Map__valueAbsent
	}
	return v
}

var _Map__valueAbsent = _Any__Maybe{m:schema.Maybe_Absent}
func (n Map) Iterator() *Map__Itr {
	return &Map__Itr{n, 0}
}

type Map__Itr struct {
	n Map
	idx  int
}

func (itr *Map__Itr) Next() (k String, v MaybeAny) {
	if itr.idx >= len(itr.n.t) {
		return nil, nil
	}
	x := &itr.n.t[itr.idx]
	k = &x.k
	v = &x.v
	itr.idx++
	return
}
func (itr *Map__Itr) Done() bool {
	return itr.idx >= len(itr.n.t)
}

type _Map__Maybe struct {
	m schema.Maybe
	v Map
}
type MaybeMap = *_Map__Maybe

func (m MaybeMap) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeMap) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeMap) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeMap) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeMap) Must() Map {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var _ ipld.Node = (Map)(&_Map{})
var _ schema.TypedNode = (Map)(&_Map{})
func (Map) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n Map) LookupByString(k string) (ipld.Node, error) {
	var k2 _String
	if err := (_String__Prototype{}).fromString(&k2, k); err != nil {
		return nil, err // TODO wrap in some kind of ErrInvalidKey
	}
	v, exists := n.m[k2]
	if !exists {
		return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(k)}
	}
	if v.m == schema.Maybe_Null {
		return ipld.Null, nil
	}
	return v.v, nil
}
func (n Map) LookupByNode(k ipld.Node) (ipld.Node, error) {
	k2, ok := k.(String)
	if !ok {
		panic("todo invalid key type error")
		// 'ipld.ErrInvalidKey{TypeName:"tasks.Map", Key:&_String{k}}' doesn't quite cut it: need room to explain the type, and it's not guaranteed k can be turned into a string at all
	}
	v, exists := n.m[*k2]
	if !exists {
		return nil, ipld.ErrNotExists{ipld.PathSegmentOfString(k2.String())}
	}
	if v.m == schema.Maybe_Null {
		return ipld.Null, nil
	}
	return v.v, nil
}
func (Map) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"tasks.Map"}.LookupByIndex(0)
}
func (n Map) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n Map) MapIterator() ipld.MapIterator {
	return &_Map__MapItr{n, 0}
}

type _Map__MapItr struct {
	n Map
	idx  int
}

func (itr *_Map__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= len(itr.n.t) {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	x := &itr.n.t[itr.idx]
	k = &x.k
	switch x.v.m {
	case schema.Maybe_Null:
		v = ipld.Null
	case schema.Maybe_Value:
		v = x.v.v
	}
	itr.idx++
	return
}
func (itr *_Map__MapItr) Done() bool {
	return itr.idx >= len(itr.n.t)
}

func (Map) ListIterator() ipld.ListIterator {
	return nil
}
func (n Map) Length() int64 {
	return int64(len(n.t))
}
func (Map) IsAbsent() bool {
	return false
}
func (Map) IsNull() bool {
	return false
}
func (Map) AsBool() (bool, error) {
	return mixins.Map{"tasks.Map"}.AsBool()
}
func (Map) AsInt() (int64, error) {
	return mixins.Map{"tasks.Map"}.AsInt()
}
func (Map) AsFloat() (float64, error) {
	return mixins.Map{"tasks.Map"}.AsFloat()
}
func (Map) AsString() (string, error) {
	return mixins.Map{"tasks.Map"}.AsString()
}
func (Map) AsBytes() ([]byte, error) {
	return mixins.Map{"tasks.Map"}.AsBytes()
}
func (Map) AsLink() (ipld.Link, error) {
	return mixins.Map{"tasks.Map"}.AsLink()
}
func (Map) Prototype() ipld.NodePrototype {
	return _Map__Prototype{}
}
type _Map__Prototype struct{}

func (_Map__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Map__Builder
	nb.Reset()
	return &nb
}
type _Map__Builder struct {
	_Map__Assembler
}
func (nb *_Map__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Map__Builder) Reset() {
	var w _Map
	var m schema.Maybe
	*nb = _Map__Builder{_Map__Assembler{w: &w, m: &m}}
}
type _Map__Assembler struct {
	w *_Map
	m *schema.Maybe
	state maState

	cm schema.Maybe
	ka _String__Assembler
	va _Any__Assembler
}

func (na *_Map__Assembler) reset() {
	na.state = maState_initial
	na.ka.reset()
	na.va.reset()
}
func (na *_Map__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_Map{}
	}
	na.w.m = make(map[_String]MaybeAny, sizeHint)
	na.w.t = make([]_Map__entry, 0, sizeHint)
	return na, nil
}
func (_Map__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"tasks.Map"}.BeginList(0)
}
func (na *_Map__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"tasks.Map"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Map__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"tasks.Map"}.AssignBool(false)
}
func (_Map__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"tasks.Map"}.AssignInt(0)
}
func (_Map__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"tasks.Map"}.AssignFloat(0)
}
func (_Map__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"tasks.Map"}.AssignString("")
}
func (_Map__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"tasks.Map"}.AssignBytes(nil)
}
func (_Map__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"tasks.Map"}.AssignLink(nil)
}
func (na *_Map__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Map); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "tasks.Map", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Map__Assembler) Prototype() ipld.NodePrototype {
	return _Map__Prototype{}
}
func (ma *_Map__Assembler) keyFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.ka.w = nil
		tz := &ma.w.t[len(ma.w.t)-1]
		ma.cm = schema.Maybe_Absent
		ma.state = maState_expectValue
		ma.w.m[tz.k] = &tz.v
		ma.va.m = &tz.v.m
		tz.v.m = allowNull
		ma.ka.reset()
		return true
	default:
		return false
	}
}
func (ma *_Map__Assembler) valueFinishTidy() bool {
	tz := &ma.w.t[len(ma.w.t)-1]
	switch tz.v.m {
	case schema.Maybe_Null:
		ma.state = maState_initial
		ma.va.reset()
		return true
	case schema.Maybe_Value:
		tz.v.v = ma.va.w
		ma.va.w = nil
		ma.state = maState_initial
		ma.va.reset()
		return true
	default:
		return false
	}
}
func (ma *_Map__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}

	var k2 _String
	if err := (_String__Prototype{}).fromString(&k2, k); err != nil {
		return nil, err // TODO wrap in some kind of ErrInvalidKey
	}
	if _, exists := ma.w.m[k2]; exists {
		return nil, ipld.ErrRepeatedMapKey{&k2}
	}
	ma.w.t = append(ma.w.t, _Map__entry{k: k2})
	tz := &ma.w.t[len(ma.w.t)-1]
	ma.state = maState_midValue

	ma.w.m[k2] = &tz.v
	ma.va.m = &tz.v.m
	tz.v.m = allowNull
	return &ma.va, nil
}
func (ma *_Map__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.w.t = append(ma.w.t, _Map__entry{})
	ma.state = maState_midKey
	ma.ka.m = &ma.cm
	ma.ka.w = &ma.w.t[len(ma.w.t)-1].k
	return &ma.ka
}
func (ma *_Map__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		if !ma.keyFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
		} // if tidy success: carry on
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	return &ma.va
}
func (ma *_Map__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Map__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Map__Assembler) ValuePrototype(_ string) ipld.NodePrototype {
	return _Any__Prototype{}
}
func (Map) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Map) Representation() ipld.Node {
	return (*_Map__Repr)(n)
}
type _Map__Repr _Map
var _ ipld.Node = &_Map__Repr{}
func (_Map__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (nr *_Map__Repr) LookupByString(k string) (ipld.Node, error) {
	v, err := (Map)(nr).LookupByString(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Any).Representation(), nil
}
func (nr *_Map__Repr) LookupByNode(k ipld.Node) (ipld.Node, error) {
	v, err := (Map)(nr).LookupByNode(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Any).Representation(), nil
}
func (_Map__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"tasks.Map.Repr"}.LookupByIndex(0)
}
func (n _Map__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (nr *_Map__Repr) MapIterator() ipld.MapIterator {
	return &_Map__ReprMapItr{(Map)(nr), 0}
}

type _Map__ReprMapItr _Map__MapItr

func (itr *_Map__ReprMapItr) Next() (k ipld.Node, v ipld.Node, err error) {
	k, v, err = (*_Map__MapItr)(itr).Next()
	if err != nil || v == ipld.Null {
		return
	}
	return k, v.(Any).Representation(), nil
}
func (itr *_Map__ReprMapItr) Done() bool {
	return (*_Map__MapItr)(itr).Done()
}

func (_Map__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_Map__Repr) Length() int64 {
	return int64(len(rn.t))
}
func (_Map__Repr) IsAbsent() bool {
	return false
}
func (_Map__Repr) IsNull() bool {
	return false
}
func (_Map__Repr) AsBool() (bool, error) {
	return mixins.Map{"tasks.Map.Repr"}.AsBool()
}
func (_Map__Repr) AsInt() (int64, error) {
	return mixins.Map{"tasks.Map.Repr"}.AsInt()
}
func (_Map__Repr) AsFloat() (float64, error) {
	return mixins.Map{"tasks.Map.Repr"}.AsFloat()
}
func (_Map__Repr) AsString() (string, error) {
	return mixins.Map{"tasks.Map.Repr"}.AsString()
}
func (_Map__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"tasks.Map.Repr"}.AsBytes()
}
func (_Map__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"tasks.Map.Repr"}.AsLink()
}
func (_Map__Repr) Prototype() ipld.NodePrototype {
	return _Map__ReprPrototype{}
}
type _Map__ReprPrototype struct{}

func (_Map__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Map__ReprBuilder
	nb.Reset()
	return &nb
}
type _Map__ReprBuilder struct {
	_Map__ReprAssembler
}
func (nb *_Map__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Map__ReprBuilder) Reset() {
	var w _Map
	var m schema.Maybe
	*nb = _Map__ReprBuilder{_Map__ReprAssembler{w: &w, m: &m}}
}
type _Map__ReprAssembler struct {
	w *_Map
	m *schema.Maybe
	state maState

	cm schema.Maybe
	ka _String__ReprAssembler
	va _Any__ReprAssembler
}

func (na *_Map__ReprAssembler) reset() {
	na.state = maState_initial
	na.ka.reset()
	na.va.reset()
}
func (na *_Map__ReprAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_Map{}
	}
	na.w.m = make(map[_String]MaybeAny, sizeHint)
	na.w.t = make([]_Map__entry, 0, sizeHint)
	return na, nil
}
func (_Map__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"tasks.Map.Repr"}.BeginList(0)
}
func (na *_Map__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"tasks.Map.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Map__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"tasks.Map.Repr"}.AssignBool(false)
}
func (_Map__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"tasks.Map.Repr"}.AssignInt(0)
}
func (_Map__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"tasks.Map.Repr"}.AssignFloat(0)
}
func (_Map__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"tasks.Map.Repr"}.AssignString("")
}
func (_Map__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"tasks.Map.Repr"}.AssignBytes(nil)
}
func (_Map__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"tasks.Map.Repr"}.AssignLink(nil)
}
func (na *_Map__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Map); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "tasks.Map.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Map__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Map__ReprPrototype{}
}
func (ma *_Map__ReprAssembler) keyFinishTidy() bool {
	switch ma.cm {
	case schema.Maybe_Value:
		ma.ka.w = nil
		tz := &ma.w.t[len(ma.w.t)-1]
		ma.cm = schema.Maybe_Absent
		ma.state = maState_expectValue
		ma.w.m[tz.k] = &tz.v
		ma.va.m = &tz.v.m
		tz.v.m = allowNull
		ma.ka.reset()
		return true
	default:
		return false
	}
}
func (ma *_Map__ReprAssembler) valueFinishTidy() bool {
	tz := &ma.w.t[len(ma.w.t)-1]
	switch tz.v.m {
	case schema.Maybe_Null:
		ma.state = maState_initial
		ma.va.reset()
		return true
	case schema.Maybe_Value:
		tz.v.v = ma.va.w
		ma.va.w = nil
		ma.state = maState_initial
		ma.va.reset()
		return true
	default:
		return false
	}
}
func (ma *_Map__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}

	var k2 _String
	if err := (_String__ReprPrototype{}).fromString(&k2, k); err != nil {
		return nil, err // TODO wrap in some kind of ErrInvalidKey
	}
	if _, exists := ma.w.m[k2]; exists {
		return nil, ipld.ErrRepeatedMapKey{&k2}
	}
	ma.w.t = append(ma.w.t, _Map__entry{k: k2})
	tz := &ma.w.t[len(ma.w.t)-1]
	ma.state = maState_midValue

	ma.w.m[k2] = &tz.v
	ma.va.m = &tz.v.m
	tz.v.m = allowNull
	return &ma.va, nil
}
func (ma *_Map__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.w.t = append(ma.w.t, _Map__entry{})
	ma.state = maState_midKey
	ma.ka.m = &ma.cm
	ma.ka.w = &ma.w.t[len(ma.w.t)-1].k
	return &ma.ka
}
func (ma *_Map__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		if !ma.keyFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
		} // if tidy success: carry on
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	return &ma.va
}
func (ma *_Map__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Map__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__ReprPrototype{}
}
func (ma *_Map__ReprAssembler) ValuePrototype(_ string) ipld.NodePrototype {
	return _Any__ReprPrototype{}
}


func (n _PopTask) FieldStatus() Status {
	return &n.Status
}
func (n _PopTask) FieldWorkedBy() String {
	return &n.WorkedBy
}
type _PopTask__Maybe struct {
	m schema.Maybe
	v PopTask
}
type MaybePopTask = *_PopTask__Maybe

func (m MaybePopTask) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybePopTask) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybePopTask) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybePopTask) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybePopTask) Must() PopTask {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
	fieldName__PopTask_Status = _String{"Status"}
	fieldName__PopTask_WorkedBy = _String{"WorkedBy"}
)
var _ ipld.Node = (PopTask)(&_PopTask{})
var _ schema.TypedNode = (PopTask)(&_PopTask{})
func (PopTask) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n PopTask) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Status":
		return &n.Status, nil
	case "WorkedBy":
		return &n.WorkedBy, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n PopTask) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (PopTask) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"tasks.PopTask"}.LookupByIndex(0)
}
func (n PopTask) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n PopTask) MapIterator() ipld.MapIterator {
	return &_PopTask__MapItr{n, 0}
}

type _PopTask__MapItr struct {
	n PopTask
	idx  int
}

func (itr *_PopTask__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__PopTask_Status
		v = &itr.n.Status
	case 1:
		k = &fieldName__PopTask_WorkedBy
		v = &itr.n.WorkedBy
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_PopTask__MapItr) Done() bool {
	return itr.idx >= 2
}

func (PopTask) ListIterator() ipld.ListIterator {
	return nil
}
func (PopTask) Length() int64 {
	return 2
}
func (PopTask) IsAbsent() bool {
	return false
}
func (PopTask) IsNull() bool {
	return false
}
func (PopTask) AsBool() (bool, error) {
	return mixins.Map{"tasks.PopTask"}.AsBool()
}
func (PopTask) AsInt() (int64, error) {
	return mixins.Map{"tasks.PopTask"}.AsInt()
}
func (PopTask) AsFloat() (float64, error) {
	return mixins.Map{"tasks.PopTask"}.AsFloat()
}
func (PopTask) AsString() (string, error) {
	return mixins.Map{"tasks.PopTask"}.AsString()
}
func (PopTask) AsBytes() ([]byte, error) {
	return mixins.Map{"tasks.PopTask"}.AsBytes()
}
func (PopTask) AsLink() (ipld.Link, error) {
	return mixins.Map{"tasks.PopTask"}.AsLink()
}
func (PopTask) Prototype() ipld.NodePrototype {
	return _PopTask__Prototype{}
}
type _PopTask__Prototype struct{}

func (_PopTask__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _PopTask__Builder
	nb.Reset()
	return &nb
}
type _PopTask__Builder struct {
	_PopTask__Assembler
}
func (nb *_PopTask__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_PopTask__Builder) Reset() {
	var w _PopTask
	var m schema.Maybe
	*nb = _PopTask__Builder{_PopTask__Assembler{w: &w, m: &m}}
}
type _PopTask__Assembler struct {
	w *_PopTask
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_Status _Status__Assembler
	ca_WorkedBy _String__Assembler
	}

func (na *_PopTask__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Status.reset()
	na.ca_WorkedBy.reset()
}

var (
	fieldBit__PopTask_Status = 1 << 0
	fieldBit__PopTask_WorkedBy = 1 << 1
	fieldBits__PopTask_sufficient = 0 + 1 << 0 + 1 << 1
)
func (na *_PopTask__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_PopTask{}
	}
	return na, nil
}
func (_PopTask__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"tasks.PopTask"}.BeginList(0)
}
func (na *_PopTask__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"tasks.PopTask"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_PopTask__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"tasks.PopTask"}.AssignBool(false)
}
func (_PopTask__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"tasks.PopTask"}.AssignInt(0)
}
func (_PopTask__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"tasks.PopTask"}.AssignFloat(0)
}
func (_PopTask__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"tasks.PopTask"}.AssignString("")
}
func (_PopTask__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"tasks.PopTask"}.AssignBytes(nil)
}
func (_PopTask__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"tasks.PopTask"}.AssignLink(nil)
}
func (na *_PopTask__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_PopTask); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "tasks.PopTask", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_PopTask__Assembler) Prototype() ipld.NodePrototype {
	return _PopTask__Prototype{}
}
func (ma *_PopTask__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Status.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_WorkedBy.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_PopTask__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Status":
		if ma.s & fieldBit__PopTask_Status != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__PopTask_Status}
		}
		ma.s += fieldBit__PopTask_Status
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Status.w = &ma.w.Status
		ma.ca_Status.m = &ma.cm
		return &ma.ca_Status, nil
	case "WorkedBy":
		if ma.s & fieldBit__PopTask_WorkedBy != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__PopTask_WorkedBy}
		}
		ma.s += fieldBit__PopTask_WorkedBy
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_WorkedBy.w = &ma.w.WorkedBy
		ma.ca_WorkedBy.m = &ma.cm
		return &ma.ca_WorkedBy, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"tasks.PopTask", Key:&_String{k}}
	}
}
func (ma *_PopTask__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_PopTask__KeyAssembler)(ma)
}
func (ma *_PopTask__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Status.w = &ma.w.Status
		ma.ca_Status.m = &ma.cm
		return &ma.ca_Status
	case 1:
		ma.ca_WorkedBy.w = &ma.w.WorkedBy
		ma.ca_WorkedBy.m = &ma.cm
		return &ma.ca_WorkedBy
	default:
		panic("unreachable")
	}
}
func (ma *_PopTask__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s & fieldBits__PopTask_sufficient != fieldBits__PopTask_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s & fieldBit__PopTask_Status == 0 {
			err.Missing = append(err.Missing, "Status")
		}
		if ma.s & fieldBit__PopTask_WorkedBy == 0 {
			err.Missing = append(err.Missing, "WorkedBy")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_PopTask__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_PopTask__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}
type _PopTask__KeyAssembler _PopTask__Assembler
func (_PopTask__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"tasks.PopTask.KeyAssembler"}.BeginMap(0)
}
func (_PopTask__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"tasks.PopTask.KeyAssembler"}.BeginList(0)
}
func (na *_PopTask__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"tasks.PopTask.KeyAssembler"}.AssignNull()
}
func (_PopTask__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"tasks.PopTask.KeyAssembler"}.AssignBool(false)
}
func (_PopTask__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"tasks.PopTask.KeyAssembler"}.AssignInt(0)
}
func (_PopTask__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"tasks.PopTask.KeyAssembler"}.AssignFloat(0)
}
func (ka *_PopTask__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Status":
		if ka.s & fieldBit__PopTask_Status != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__PopTask_Status}
		}
		ka.s += fieldBit__PopTask_Status
		ka.state = maState_expectValue
		ka.f = 0
	case "WorkedBy":
		if ka.s & fieldBit__PopTask_WorkedBy != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__PopTask_WorkedBy}
		}
		ka.s += fieldBit__PopTask_WorkedBy
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName:"tasks.PopTask", Key:&_String{k}}
	}
	return nil
}
func (_PopTask__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"tasks.PopTask.KeyAssembler"}.AssignBytes(nil)
}
func (_PopTask__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"tasks.PopTask.KeyAssembler"}.AssignLink(nil)
}
func (ka *_PopTask__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_PopTask__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (PopTask) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n PopTask) Representation() ipld.Node {
	return (*_PopTask__Repr)(n)
}
type _PopTask__Repr _PopTask
var (
	fieldName__PopTask_Status_serial = _String{"Status"}
	fieldName__PopTask_WorkedBy_serial = _String{"WorkedBy"}
)
var _ ipld.Node = &_PopTask__Repr{}
func (_PopTask__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_PopTask__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Status":
		return n.Status.Representation(), nil
	case "WorkedBy":
		return n.WorkedBy.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_PopTask__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_PopTask__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"tasks.PopTask.Repr"}.LookupByIndex(0)
}
func (n _PopTask__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_PopTask__Repr) MapIterator() ipld.MapIterator {
	return &_PopTask__ReprMapItr{n, 0}
}

type _PopTask__ReprMapItr struct {
	n   *_PopTask__Repr
	idx int
	
}

func (itr *_PopTask__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
if itr.idx >= 2 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__PopTask_Status_serial
		v = itr.n.Status.Representation()
	case 1:
		k = &fieldName__PopTask_WorkedBy_serial
		v = itr.n.WorkedBy.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_PopTask__ReprMapItr) Done() bool {
	return itr.idx >= 2
}
func (_PopTask__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_PopTask__Repr) Length() int64 {
	l := 2
	return int64(l)
}
func (_PopTask__Repr) IsAbsent() bool {
	return false
}
func (_PopTask__Repr) IsNull() bool {
	return false
}
func (_PopTask__Repr) AsBool() (bool, error) {
	return mixins.Map{"tasks.PopTask.Repr"}.AsBool()
}
func (_PopTask__Repr) AsInt() (int64, error) {
	return mixins.Map{"tasks.PopTask.Repr"}.AsInt()
}
func (_PopTask__Repr) AsFloat() (float64, error) {
	return mixins.Map{"tasks.PopTask.Repr"}.AsFloat()
}
func (_PopTask__Repr) AsString() (string, error) {
	return mixins.Map{"tasks.PopTask.Repr"}.AsString()
}
func (_PopTask__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"tasks.PopTask.Repr"}.AsBytes()
}
func (_PopTask__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"tasks.PopTask.Repr"}.AsLink()
}
func (_PopTask__Repr) Prototype() ipld.NodePrototype {
	return _PopTask__ReprPrototype{}
}
type _PopTask__ReprPrototype struct{}

func (_PopTask__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _PopTask__ReprBuilder
	nb.Reset()
	return &nb
}
type _PopTask__ReprBuilder struct {
	_PopTask__ReprAssembler
}
func (nb *_PopTask__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_PopTask__ReprBuilder) Reset() {
	var w _PopTask
	var m schema.Maybe
	*nb = _PopTask__ReprBuilder{_PopTask__ReprAssembler{w: &w, m: &m}}
}
type _PopTask__ReprAssembler struct {
	w *_PopTask
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_Status _Status__ReprAssembler
	ca_WorkedBy _String__ReprAssembler
	}

func (na *_PopTask__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Status.reset()
	na.ca_WorkedBy.reset()
}
func (na *_PopTask__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_PopTask{}
	}
	return na, nil
}
func (_PopTask__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"tasks.PopTask.Repr"}.BeginList(0)
}
func (na *_PopTask__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"tasks.PopTask.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_PopTask__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"tasks.PopTask.Repr"}.AssignBool(false)
}
func (_PopTask__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"tasks.PopTask.Repr"}.AssignInt(0)
}
func (_PopTask__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"tasks.PopTask.Repr"}.AssignFloat(0)
}
func (_PopTask__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"tasks.PopTask.Repr"}.AssignString("")
}
func (_PopTask__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"tasks.PopTask.Repr"}.AssignBytes(nil)
}
func (_PopTask__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"tasks.PopTask.Repr"}.AssignLink(nil)
}
func (na *_PopTask__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_PopTask); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "tasks.PopTask.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_PopTask__ReprAssembler) Prototype() ipld.NodePrototype {
	return _PopTask__ReprPrototype{}
}
func (ma *_PopTask__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_PopTask__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Status":
		if ma.s & fieldBit__PopTask_Status != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__PopTask_Status_serial}
		}
		ma.s += fieldBit__PopTask_Status
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Status.w = &ma.w.Status
		ma.ca_Status.m = &ma.cm
		return &ma.ca_Status, nil
	case "WorkedBy":
		if ma.s & fieldBit__PopTask_WorkedBy != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__PopTask_WorkedBy_serial}
		}
		ma.s += fieldBit__PopTask_WorkedBy
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_WorkedBy.w = &ma.w.WorkedBy
		ma.ca_WorkedBy.m = &ma.cm
		return &ma.ca_WorkedBy, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"tasks.PopTask.Repr", Key:&_String{k}}
	}
}
func (ma *_PopTask__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_PopTask__ReprKeyAssembler)(ma)
}
func (ma *_PopTask__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Status.w = &ma.w.Status
		ma.ca_Status.m = &ma.cm
		return &ma.ca_Status
	case 1:
		ma.ca_WorkedBy.w = &ma.w.WorkedBy
		ma.ca_WorkedBy.m = &ma.cm
		return &ma.ca_WorkedBy
	default:
		panic("unreachable")
	}
}
func (ma *_PopTask__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s & fieldBits__PopTask_sufficient != fieldBits__PopTask_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s & fieldBit__PopTask_Status == 0 {
			err.Missing = append(err.Missing, "Status")
		}
		if ma.s & fieldBit__PopTask_WorkedBy == 0 {
			err.Missing = append(err.Missing, "WorkedBy")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_PopTask__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_PopTask__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}
type _PopTask__ReprKeyAssembler _PopTask__ReprAssembler
func (_PopTask__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"tasks.PopTask.Repr.KeyAssembler"}.BeginMap(0)
}
func (_PopTask__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"tasks.PopTask.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_PopTask__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"tasks.PopTask.Repr.KeyAssembler"}.AssignNull()
}
func (_PopTask__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"tasks.PopTask.Repr.KeyAssembler"}.AssignBool(false)
}
func (_PopTask__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"tasks.PopTask.Repr.KeyAssembler"}.AssignInt(0)
}
func (_PopTask__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"tasks.PopTask.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_PopTask__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Status":
		if ka.s & fieldBit__PopTask_Status != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__PopTask_Status_serial}
		}
		ka.s += fieldBit__PopTask_Status
		ka.state = maState_expectValue
		ka.f = 0
	case "WorkedBy":
		if ka.s & fieldBit__PopTask_WorkedBy != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__PopTask_WorkedBy_serial}
		}
		ka.s += fieldBit__PopTask_WorkedBy
		ka.state = maState_expectValue
		ka.f = 1
	default:
		return ipld.ErrInvalidKey{TypeName:"tasks.PopTask.Repr", Key:&_String{k}}
	}
	return nil
}
func (_PopTask__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"tasks.PopTask.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_PopTask__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"tasks.PopTask.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_PopTask__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_PopTask__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}


func (n _RecordUpdate) FieldRecords() List_AuthenticatedRecord {
	return &n.Records
}
func (n _RecordUpdate) FieldSigPrev() Bytes {
	return &n.SigPrev
}
func (n _RecordUpdate) FieldPrevious() MaybeLink {
	return &n.Previous
}
type _RecordUpdate__Maybe struct {
	m schema.Maybe
	v RecordUpdate
}
type MaybeRecordUpdate = *_RecordUpdate__Maybe

func (m MaybeRecordUpdate) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeRecordUpdate) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeRecordUpdate) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeRecordUpdate) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeRecordUpdate) Must() RecordUpdate {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
	fieldName__RecordUpdate_Records = _String{"Records"}
	fieldName__RecordUpdate_SigPrev = _String{"SigPrev"}
	fieldName__RecordUpdate_Previous = _String{"Previous"}
)
var _ ipld.Node = (RecordUpdate)(&_RecordUpdate{})
var _ schema.TypedNode = (RecordUpdate)(&_RecordUpdate{})
func (RecordUpdate) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n RecordUpdate) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Records":
		return &n.Records, nil
	case "SigPrev":
		return &n.SigPrev, nil
	case "Previous":
		if n.Previous.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Previous.v, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n RecordUpdate) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (RecordUpdate) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"tasks.RecordUpdate"}.LookupByIndex(0)
}
func (n RecordUpdate) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n RecordUpdate) MapIterator() ipld.MapIterator {
	return &_RecordUpdate__MapItr{n, 0}
}

type _RecordUpdate__MapItr struct {
	n RecordUpdate
	idx  int
}

func (itr *_RecordUpdate__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 3 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__RecordUpdate_Records
		v = &itr.n.Records
	case 1:
		k = &fieldName__RecordUpdate_SigPrev
		v = &itr.n.SigPrev
	case 2:
		k = &fieldName__RecordUpdate_Previous
		if itr.n.Previous.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Previous.v
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_RecordUpdate__MapItr) Done() bool {
	return itr.idx >= 3
}

func (RecordUpdate) ListIterator() ipld.ListIterator {
	return nil
}
func (RecordUpdate) Length() int64 {
	return 3
}
func (RecordUpdate) IsAbsent() bool {
	return false
}
func (RecordUpdate) IsNull() bool {
	return false
}
func (RecordUpdate) AsBool() (bool, error) {
	return mixins.Map{"tasks.RecordUpdate"}.AsBool()
}
func (RecordUpdate) AsInt() (int64, error) {
	return mixins.Map{"tasks.RecordUpdate"}.AsInt()
}
func (RecordUpdate) AsFloat() (float64, error) {
	return mixins.Map{"tasks.RecordUpdate"}.AsFloat()
}
func (RecordUpdate) AsString() (string, error) {
	return mixins.Map{"tasks.RecordUpdate"}.AsString()
}
func (RecordUpdate) AsBytes() ([]byte, error) {
	return mixins.Map{"tasks.RecordUpdate"}.AsBytes()
}
func (RecordUpdate) AsLink() (ipld.Link, error) {
	return mixins.Map{"tasks.RecordUpdate"}.AsLink()
}
func (RecordUpdate) Prototype() ipld.NodePrototype {
	return _RecordUpdate__Prototype{}
}
type _RecordUpdate__Prototype struct{}

func (_RecordUpdate__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _RecordUpdate__Builder
	nb.Reset()
	return &nb
}
type _RecordUpdate__Builder struct {
	_RecordUpdate__Assembler
}
func (nb *_RecordUpdate__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_RecordUpdate__Builder) Reset() {
	var w _RecordUpdate
	var m schema.Maybe
	*nb = _RecordUpdate__Builder{_RecordUpdate__Assembler{w: &w, m: &m}}
}
type _RecordUpdate__Assembler struct {
	w *_RecordUpdate
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_Records _List_AuthenticatedRecord__Assembler
	ca_SigPrev _Bytes__Assembler
	ca_Previous _Link__Assembler
	}

func (na *_RecordUpdate__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Records.reset()
	na.ca_SigPrev.reset()
	na.ca_Previous.reset()
}

var (
	fieldBit__RecordUpdate_Records = 1 << 0
	fieldBit__RecordUpdate_SigPrev = 1 << 1
	fieldBit__RecordUpdate_Previous = 1 << 2
	fieldBits__RecordUpdate_sufficient = 0 + 1 << 0 + 1 << 1 + 1 << 2
)
func (na *_RecordUpdate__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_RecordUpdate{}
	}
	return na, nil
}
func (_RecordUpdate__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"tasks.RecordUpdate"}.BeginList(0)
}
func (na *_RecordUpdate__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"tasks.RecordUpdate"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_RecordUpdate__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"tasks.RecordUpdate"}.AssignBool(false)
}
func (_RecordUpdate__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"tasks.RecordUpdate"}.AssignInt(0)
}
func (_RecordUpdate__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"tasks.RecordUpdate"}.AssignFloat(0)
}
func (_RecordUpdate__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"tasks.RecordUpdate"}.AssignString("")
}
func (_RecordUpdate__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"tasks.RecordUpdate"}.AssignBytes(nil)
}
func (_RecordUpdate__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"tasks.RecordUpdate"}.AssignLink(nil)
}
func (na *_RecordUpdate__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_RecordUpdate); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "tasks.RecordUpdate", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_RecordUpdate__Assembler) Prototype() ipld.NodePrototype {
	return _RecordUpdate__Prototype{}
}
func (ma *_RecordUpdate__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Records.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_SigPrev.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.w.Previous.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Previous.v = ma.ca_Previous.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_RecordUpdate__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Records":
		if ma.s & fieldBit__RecordUpdate_Records != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__RecordUpdate_Records}
		}
		ma.s += fieldBit__RecordUpdate_Records
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Records.w = &ma.w.Records
		ma.ca_Records.m = &ma.cm
		return &ma.ca_Records, nil
	case "SigPrev":
		if ma.s & fieldBit__RecordUpdate_SigPrev != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__RecordUpdate_SigPrev}
		}
		ma.s += fieldBit__RecordUpdate_SigPrev
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_SigPrev.w = &ma.w.SigPrev
		ma.ca_SigPrev.m = &ma.cm
		return &ma.ca_SigPrev, nil
	case "Previous":
		if ma.s & fieldBit__RecordUpdate_Previous != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__RecordUpdate_Previous}
		}
		ma.s += fieldBit__RecordUpdate_Previous
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Previous.w = ma.w.Previous.v
		ma.ca_Previous.m = &ma.w.Previous.m
		ma.w.Previous.m = allowNull
		return &ma.ca_Previous, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"tasks.RecordUpdate", Key:&_String{k}}
	}
}
func (ma *_RecordUpdate__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_RecordUpdate__KeyAssembler)(ma)
}
func (ma *_RecordUpdate__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Records.w = &ma.w.Records
		ma.ca_Records.m = &ma.cm
		return &ma.ca_Records
	case 1:
		ma.ca_SigPrev.w = &ma.w.SigPrev
		ma.ca_SigPrev.m = &ma.cm
		return &ma.ca_SigPrev
	case 2:
		ma.ca_Previous.w = ma.w.Previous.v
		ma.ca_Previous.m = &ma.w.Previous.m
		ma.w.Previous.m = allowNull
		return &ma.ca_Previous
	default:
		panic("unreachable")
	}
}
func (ma *_RecordUpdate__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s & fieldBits__RecordUpdate_sufficient != fieldBits__RecordUpdate_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s & fieldBit__RecordUpdate_Records == 0 {
			err.Missing = append(err.Missing, "Records")
		}
		if ma.s & fieldBit__RecordUpdate_SigPrev == 0 {
			err.Missing = append(err.Missing, "SigPrev")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_RecordUpdate__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_RecordUpdate__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}
type _RecordUpdate__KeyAssembler _RecordUpdate__Assembler
func (_RecordUpdate__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"tasks.RecordUpdate.KeyAssembler"}.BeginMap(0)
}
func (_RecordUpdate__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"tasks.RecordUpdate.KeyAssembler"}.BeginList(0)
}
func (na *_RecordUpdate__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"tasks.RecordUpdate.KeyAssembler"}.AssignNull()
}
func (_RecordUpdate__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"tasks.RecordUpdate.KeyAssembler"}.AssignBool(false)
}
func (_RecordUpdate__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"tasks.RecordUpdate.KeyAssembler"}.AssignInt(0)
}
func (_RecordUpdate__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"tasks.RecordUpdate.KeyAssembler"}.AssignFloat(0)
}
func (ka *_RecordUpdate__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Records":
		if ka.s & fieldBit__RecordUpdate_Records != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__RecordUpdate_Records}
		}
		ka.s += fieldBit__RecordUpdate_Records
		ka.state = maState_expectValue
		ka.f = 0
	case "SigPrev":
		if ka.s & fieldBit__RecordUpdate_SigPrev != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__RecordUpdate_SigPrev}
		}
		ka.s += fieldBit__RecordUpdate_SigPrev
		ka.state = maState_expectValue
		ka.f = 1
	case "Previous":
		if ka.s & fieldBit__RecordUpdate_Previous != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__RecordUpdate_Previous}
		}
		ka.s += fieldBit__RecordUpdate_Previous
		ka.state = maState_expectValue
		ka.f = 2
	default:
		return ipld.ErrInvalidKey{TypeName:"tasks.RecordUpdate", Key:&_String{k}}
	}
	return nil
}
func (_RecordUpdate__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"tasks.RecordUpdate.KeyAssembler"}.AssignBytes(nil)
}
func (_RecordUpdate__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"tasks.RecordUpdate.KeyAssembler"}.AssignLink(nil)
}
func (ka *_RecordUpdate__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_RecordUpdate__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (RecordUpdate) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n RecordUpdate) Representation() ipld.Node {
	return (*_RecordUpdate__Repr)(n)
}
type _RecordUpdate__Repr _RecordUpdate
var (
	fieldName__RecordUpdate_Records_serial = _String{"Records"}
	fieldName__RecordUpdate_SigPrev_serial = _String{"SigPrev"}
	fieldName__RecordUpdate_Previous_serial = _String{"Previous"}
)
var _ ipld.Node = &_RecordUpdate__Repr{}
func (_RecordUpdate__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_RecordUpdate__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Records":
		return n.Records.Representation(), nil
	case "SigPrev":
		return n.SigPrev.Representation(), nil
	case "Previous":
		if n.Previous.m == schema.Maybe_Null {
			return ipld.Null, nil
		}
		return n.Previous.v.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_RecordUpdate__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_RecordUpdate__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"tasks.RecordUpdate.Repr"}.LookupByIndex(0)
}
func (n _RecordUpdate__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_RecordUpdate__Repr) MapIterator() ipld.MapIterator {
	return &_RecordUpdate__ReprMapItr{n, 0}
}

type _RecordUpdate__ReprMapItr struct {
	n   *_RecordUpdate__Repr
	idx int
	
}

func (itr *_RecordUpdate__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
if itr.idx >= 3 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__RecordUpdate_Records_serial
		v = itr.n.Records.Representation()
	case 1:
		k = &fieldName__RecordUpdate_SigPrev_serial
		v = itr.n.SigPrev.Representation()
	case 2:
		k = &fieldName__RecordUpdate_Previous_serial
		if itr.n.Previous.m == schema.Maybe_Null {
			v = ipld.Null
			break
		}
		v = itr.n.Previous.v.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_RecordUpdate__ReprMapItr) Done() bool {
	return itr.idx >= 3
}
func (_RecordUpdate__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_RecordUpdate__Repr) Length() int64 {
	l := 3
	return int64(l)
}
func (_RecordUpdate__Repr) IsAbsent() bool {
	return false
}
func (_RecordUpdate__Repr) IsNull() bool {
	return false
}
func (_RecordUpdate__Repr) AsBool() (bool, error) {
	return mixins.Map{"tasks.RecordUpdate.Repr"}.AsBool()
}
func (_RecordUpdate__Repr) AsInt() (int64, error) {
	return mixins.Map{"tasks.RecordUpdate.Repr"}.AsInt()
}
func (_RecordUpdate__Repr) AsFloat() (float64, error) {
	return mixins.Map{"tasks.RecordUpdate.Repr"}.AsFloat()
}
func (_RecordUpdate__Repr) AsString() (string, error) {
	return mixins.Map{"tasks.RecordUpdate.Repr"}.AsString()
}
func (_RecordUpdate__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"tasks.RecordUpdate.Repr"}.AsBytes()
}
func (_RecordUpdate__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"tasks.RecordUpdate.Repr"}.AsLink()
}
func (_RecordUpdate__Repr) Prototype() ipld.NodePrototype {
	return _RecordUpdate__ReprPrototype{}
}
type _RecordUpdate__ReprPrototype struct{}

func (_RecordUpdate__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _RecordUpdate__ReprBuilder
	nb.Reset()
	return &nb
}
type _RecordUpdate__ReprBuilder struct {
	_RecordUpdate__ReprAssembler
}
func (nb *_RecordUpdate__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_RecordUpdate__ReprBuilder) Reset() {
	var w _RecordUpdate
	var m schema.Maybe
	*nb = _RecordUpdate__ReprBuilder{_RecordUpdate__ReprAssembler{w: &w, m: &m}}
}
type _RecordUpdate__ReprAssembler struct {
	w *_RecordUpdate
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_Records _List_AuthenticatedRecord__ReprAssembler
	ca_SigPrev _Bytes__ReprAssembler
	ca_Previous _Link__ReprAssembler
	}

func (na *_RecordUpdate__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Records.reset()
	na.ca_SigPrev.reset()
	na.ca_Previous.reset()
}
func (na *_RecordUpdate__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_RecordUpdate{}
	}
	return na, nil
}
func (_RecordUpdate__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"tasks.RecordUpdate.Repr"}.BeginList(0)
}
func (na *_RecordUpdate__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"tasks.RecordUpdate.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_RecordUpdate__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"tasks.RecordUpdate.Repr"}.AssignBool(false)
}
func (_RecordUpdate__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"tasks.RecordUpdate.Repr"}.AssignInt(0)
}
func (_RecordUpdate__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"tasks.RecordUpdate.Repr"}.AssignFloat(0)
}
func (_RecordUpdate__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"tasks.RecordUpdate.Repr"}.AssignString("")
}
func (_RecordUpdate__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"tasks.RecordUpdate.Repr"}.AssignBytes(nil)
}
func (_RecordUpdate__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"tasks.RecordUpdate.Repr"}.AssignLink(nil)
}
func (na *_RecordUpdate__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_RecordUpdate); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "tasks.RecordUpdate.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_RecordUpdate__ReprAssembler) Prototype() ipld.NodePrototype {
	return _RecordUpdate__ReprPrototype{}
}
func (ma *_RecordUpdate__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.w.Previous.m {
		case schema.Maybe_Null:
			ma.state = maState_initial
			return true
		case schema.Maybe_Value:
			ma.w.Previous.v = ma.ca_Previous.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_RecordUpdate__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Records":
		if ma.s & fieldBit__RecordUpdate_Records != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__RecordUpdate_Records_serial}
		}
		ma.s += fieldBit__RecordUpdate_Records
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Records.w = &ma.w.Records
		ma.ca_Records.m = &ma.cm
		return &ma.ca_Records, nil
	case "SigPrev":
		if ma.s & fieldBit__RecordUpdate_SigPrev != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__RecordUpdate_SigPrev_serial}
		}
		ma.s += fieldBit__RecordUpdate_SigPrev
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_SigPrev.w = &ma.w.SigPrev
		ma.ca_SigPrev.m = &ma.cm
		return &ma.ca_SigPrev, nil
	case "Previous":
		if ma.s & fieldBit__RecordUpdate_Previous != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__RecordUpdate_Previous_serial}
		}
		ma.s += fieldBit__RecordUpdate_Previous
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Previous.w = ma.w.Previous.v
		ma.ca_Previous.m = &ma.w.Previous.m
		ma.w.Previous.m = allowNull
		return &ma.ca_Previous, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"tasks.RecordUpdate.Repr", Key:&_String{k}}
	}
}
func (ma *_RecordUpdate__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_RecordUpdate__ReprKeyAssembler)(ma)
}
func (ma *_RecordUpdate__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Records.w = &ma.w.Records
		ma.ca_Records.m = &ma.cm
		return &ma.ca_Records
	case 1:
		ma.ca_SigPrev.w = &ma.w.SigPrev
		ma.ca_SigPrev.m = &ma.cm
		return &ma.ca_SigPrev
	case 2:
		ma.ca_Previous.w = ma.w.Previous.v
		ma.ca_Previous.m = &ma.w.Previous.m
		ma.w.Previous.m = allowNull
		return &ma.ca_Previous
	default:
		panic("unreachable")
	}
}
func (ma *_RecordUpdate__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s & fieldBits__RecordUpdate_sufficient != fieldBits__RecordUpdate_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s & fieldBit__RecordUpdate_Records == 0 {
			err.Missing = append(err.Missing, "Records")
		}
		if ma.s & fieldBit__RecordUpdate_SigPrev == 0 {
			err.Missing = append(err.Missing, "SigPrev")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_RecordUpdate__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_RecordUpdate__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}
type _RecordUpdate__ReprKeyAssembler _RecordUpdate__ReprAssembler
func (_RecordUpdate__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"tasks.RecordUpdate.Repr.KeyAssembler"}.BeginMap(0)
}
func (_RecordUpdate__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"tasks.RecordUpdate.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_RecordUpdate__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"tasks.RecordUpdate.Repr.KeyAssembler"}.AssignNull()
}
func (_RecordUpdate__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"tasks.RecordUpdate.Repr.KeyAssembler"}.AssignBool(false)
}
func (_RecordUpdate__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"tasks.RecordUpdate.Repr.KeyAssembler"}.AssignInt(0)
}
func (_RecordUpdate__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"tasks.RecordUpdate.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_RecordUpdate__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Records":
		if ka.s & fieldBit__RecordUpdate_Records != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__RecordUpdate_Records_serial}
		}
		ka.s += fieldBit__RecordUpdate_Records
		ka.state = maState_expectValue
		ka.f = 0
	case "SigPrev":
		if ka.s & fieldBit__RecordUpdate_SigPrev != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__RecordUpdate_SigPrev_serial}
		}
		ka.s += fieldBit__RecordUpdate_SigPrev
		ka.state = maState_expectValue
		ka.f = 1
	case "Previous":
		if ka.s & fieldBit__RecordUpdate_Previous != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__RecordUpdate_Previous_serial}
		}
		ka.s += fieldBit__RecordUpdate_Previous
		ka.state = maState_expectValue
		ka.f = 2
	default:
		return ipld.ErrInvalidKey{TypeName:"tasks.RecordUpdate.Repr", Key:&_String{k}}
	}
	return nil
}
func (_RecordUpdate__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"tasks.RecordUpdate.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_RecordUpdate__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"tasks.RecordUpdate.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_RecordUpdate__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_RecordUpdate__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}


func (n _RetrievalTask) FieldMiner() String {
	return &n.Miner
}
func (n _RetrievalTask) FieldPayloadCID() String {
	return &n.PayloadCID
}
func (n _RetrievalTask) FieldCARExport() Bool {
	return &n.CARExport
}
func (n _RetrievalTask) FieldSchedule() MaybeString {
	return &n.Schedule
}
func (n _RetrievalTask) FieldScheduleLimit() MaybeString {
	return &n.ScheduleLimit
}
type _RetrievalTask__Maybe struct {
	m schema.Maybe
	v RetrievalTask
}
type MaybeRetrievalTask = *_RetrievalTask__Maybe

func (m MaybeRetrievalTask) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeRetrievalTask) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeRetrievalTask) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeRetrievalTask) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeRetrievalTask) Must() RetrievalTask {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
	fieldName__RetrievalTask_Miner = _String{"Miner"}
	fieldName__RetrievalTask_PayloadCID = _String{"PayloadCID"}
	fieldName__RetrievalTask_CARExport = _String{"CARExport"}
	fieldName__RetrievalTask_Schedule = _String{"Schedule"}
	fieldName__RetrievalTask_ScheduleLimit = _String{"ScheduleLimit"}
)
var _ ipld.Node = (RetrievalTask)(&_RetrievalTask{})
var _ schema.TypedNode = (RetrievalTask)(&_RetrievalTask{})
func (RetrievalTask) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n RetrievalTask) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Miner":
		return &n.Miner, nil
	case "PayloadCID":
		return &n.PayloadCID, nil
	case "CARExport":
		return &n.CARExport, nil
	case "Schedule":
		if n.Schedule.m == schema.Maybe_Absent {
			return ipld.Absent, nil
		}
		return n.Schedule.v, nil
	case "ScheduleLimit":
		if n.ScheduleLimit.m == schema.Maybe_Absent {
			return ipld.Absent, nil
		}
		return n.ScheduleLimit.v, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n RetrievalTask) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (RetrievalTask) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"tasks.RetrievalTask"}.LookupByIndex(0)
}
func (n RetrievalTask) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n RetrievalTask) MapIterator() ipld.MapIterator {
	return &_RetrievalTask__MapItr{n, 0}
}

type _RetrievalTask__MapItr struct {
	n RetrievalTask
	idx  int
}

func (itr *_RetrievalTask__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 5 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__RetrievalTask_Miner
		v = &itr.n.Miner
	case 1:
		k = &fieldName__RetrievalTask_PayloadCID
		v = &itr.n.PayloadCID
	case 2:
		k = &fieldName__RetrievalTask_CARExport
		v = &itr.n.CARExport
	case 3:
		k = &fieldName__RetrievalTask_Schedule
		if itr.n.Schedule.m == schema.Maybe_Absent {
			v = ipld.Absent
			break
		}
		v = itr.n.Schedule.v
	case 4:
		k = &fieldName__RetrievalTask_ScheduleLimit
		if itr.n.ScheduleLimit.m == schema.Maybe_Absent {
			v = ipld.Absent
			break
		}
		v = itr.n.ScheduleLimit.v
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_RetrievalTask__MapItr) Done() bool {
	return itr.idx >= 5
}

func (RetrievalTask) ListIterator() ipld.ListIterator {
	return nil
}
func (RetrievalTask) Length() int64 {
	return 5
}
func (RetrievalTask) IsAbsent() bool {
	return false
}
func (RetrievalTask) IsNull() bool {
	return false
}
func (RetrievalTask) AsBool() (bool, error) {
	return mixins.Map{"tasks.RetrievalTask"}.AsBool()
}
func (RetrievalTask) AsInt() (int64, error) {
	return mixins.Map{"tasks.RetrievalTask"}.AsInt()
}
func (RetrievalTask) AsFloat() (float64, error) {
	return mixins.Map{"tasks.RetrievalTask"}.AsFloat()
}
func (RetrievalTask) AsString() (string, error) {
	return mixins.Map{"tasks.RetrievalTask"}.AsString()
}
func (RetrievalTask) AsBytes() ([]byte, error) {
	return mixins.Map{"tasks.RetrievalTask"}.AsBytes()
}
func (RetrievalTask) AsLink() (ipld.Link, error) {
	return mixins.Map{"tasks.RetrievalTask"}.AsLink()
}
func (RetrievalTask) Prototype() ipld.NodePrototype {
	return _RetrievalTask__Prototype{}
}
type _RetrievalTask__Prototype struct{}

func (_RetrievalTask__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _RetrievalTask__Builder
	nb.Reset()
	return &nb
}
type _RetrievalTask__Builder struct {
	_RetrievalTask__Assembler
}
func (nb *_RetrievalTask__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_RetrievalTask__Builder) Reset() {
	var w _RetrievalTask
	var m schema.Maybe
	*nb = _RetrievalTask__Builder{_RetrievalTask__Assembler{w: &w, m: &m}}
}
type _RetrievalTask__Assembler struct {
	w *_RetrievalTask
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_Miner _String__Assembler
	ca_PayloadCID _String__Assembler
	ca_CARExport _Bool__Assembler
	ca_Schedule _String__Assembler
	ca_ScheduleLimit _String__Assembler
	}

func (na *_RetrievalTask__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Miner.reset()
	na.ca_PayloadCID.reset()
	na.ca_CARExport.reset()
	na.ca_Schedule.reset()
	na.ca_ScheduleLimit.reset()
}

var (
	fieldBit__RetrievalTask_Miner = 1 << 0
	fieldBit__RetrievalTask_PayloadCID = 1 << 1
	fieldBit__RetrievalTask_CARExport = 1 << 2
	fieldBit__RetrievalTask_Schedule = 1 << 3
	fieldBit__RetrievalTask_ScheduleLimit = 1 << 4
	fieldBits__RetrievalTask_sufficient = 0 + 1 << 0 + 1 << 1 + 1 << 2
)
func (na *_RetrievalTask__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_RetrievalTask{}
	}
	return na, nil
}
func (_RetrievalTask__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"tasks.RetrievalTask"}.BeginList(0)
}
func (na *_RetrievalTask__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"tasks.RetrievalTask"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_RetrievalTask__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"tasks.RetrievalTask"}.AssignBool(false)
}
func (_RetrievalTask__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"tasks.RetrievalTask"}.AssignInt(0)
}
func (_RetrievalTask__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"tasks.RetrievalTask"}.AssignFloat(0)
}
func (_RetrievalTask__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"tasks.RetrievalTask"}.AssignString("")
}
func (_RetrievalTask__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"tasks.RetrievalTask"}.AssignBytes(nil)
}
func (_RetrievalTask__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"tasks.RetrievalTask"}.AssignLink(nil)
}
func (na *_RetrievalTask__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_RetrievalTask); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "tasks.RetrievalTask", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_RetrievalTask__Assembler) Prototype() ipld.NodePrototype {
	return _RetrievalTask__Prototype{}
}
func (ma *_RetrievalTask__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Miner.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_PayloadCID.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_CARExport.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.w.Schedule.m {
		case schema.Maybe_Value:
			ma.w.Schedule.v = ma.ca_Schedule.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.w.ScheduleLimit.m {
		case schema.Maybe_Value:
			ma.w.ScheduleLimit.v = ma.ca_ScheduleLimit.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_RetrievalTask__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Miner":
		if ma.s & fieldBit__RetrievalTask_Miner != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__RetrievalTask_Miner}
		}
		ma.s += fieldBit__RetrievalTask_Miner
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Miner.w = &ma.w.Miner
		ma.ca_Miner.m = &ma.cm
		return &ma.ca_Miner, nil
	case "PayloadCID":
		if ma.s & fieldBit__RetrievalTask_PayloadCID != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__RetrievalTask_PayloadCID}
		}
		ma.s += fieldBit__RetrievalTask_PayloadCID
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_PayloadCID.w = &ma.w.PayloadCID
		ma.ca_PayloadCID.m = &ma.cm
		return &ma.ca_PayloadCID, nil
	case "CARExport":
		if ma.s & fieldBit__RetrievalTask_CARExport != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__RetrievalTask_CARExport}
		}
		ma.s += fieldBit__RetrievalTask_CARExport
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_CARExport.w = &ma.w.CARExport
		ma.ca_CARExport.m = &ma.cm
		return &ma.ca_CARExport, nil
	case "Schedule":
		if ma.s & fieldBit__RetrievalTask_Schedule != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__RetrievalTask_Schedule}
		}
		ma.s += fieldBit__RetrievalTask_Schedule
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_Schedule.w = ma.w.Schedule.v
		ma.ca_Schedule.m = &ma.w.Schedule.m
		return &ma.ca_Schedule, nil
	case "ScheduleLimit":
		if ma.s & fieldBit__RetrievalTask_ScheduleLimit != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__RetrievalTask_ScheduleLimit}
		}
		ma.s += fieldBit__RetrievalTask_ScheduleLimit
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_ScheduleLimit.w = ma.w.ScheduleLimit.v
		ma.ca_ScheduleLimit.m = &ma.w.ScheduleLimit.m
		return &ma.ca_ScheduleLimit, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"tasks.RetrievalTask", Key:&_String{k}}
	}
}
func (ma *_RetrievalTask__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_RetrievalTask__KeyAssembler)(ma)
}
func (ma *_RetrievalTask__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Miner.w = &ma.w.Miner
		ma.ca_Miner.m = &ma.cm
		return &ma.ca_Miner
	case 1:
		ma.ca_PayloadCID.w = &ma.w.PayloadCID
		ma.ca_PayloadCID.m = &ma.cm
		return &ma.ca_PayloadCID
	case 2:
		ma.ca_CARExport.w = &ma.w.CARExport
		ma.ca_CARExport.m = &ma.cm
		return &ma.ca_CARExport
	case 3:
		ma.ca_Schedule.w = ma.w.Schedule.v
		ma.ca_Schedule.m = &ma.w.Schedule.m
		return &ma.ca_Schedule
	case 4:
		ma.ca_ScheduleLimit.w = ma.w.ScheduleLimit.v
		ma.ca_ScheduleLimit.m = &ma.w.ScheduleLimit.m
		return &ma.ca_ScheduleLimit
	default:
		panic("unreachable")
	}
}
func (ma *_RetrievalTask__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s & fieldBits__RetrievalTask_sufficient != fieldBits__RetrievalTask_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s & fieldBit__RetrievalTask_Miner == 0 {
			err.Missing = append(err.Missing, "Miner")
		}
		if ma.s & fieldBit__RetrievalTask_PayloadCID == 0 {
			err.Missing = append(err.Missing, "PayloadCID")
		}
		if ma.s & fieldBit__RetrievalTask_CARExport == 0 {
			err.Missing = append(err.Missing, "CARExport")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_RetrievalTask__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_RetrievalTask__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}
type _RetrievalTask__KeyAssembler _RetrievalTask__Assembler
func (_RetrievalTask__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"tasks.RetrievalTask.KeyAssembler"}.BeginMap(0)
}
func (_RetrievalTask__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"tasks.RetrievalTask.KeyAssembler"}.BeginList(0)
}
func (na *_RetrievalTask__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"tasks.RetrievalTask.KeyAssembler"}.AssignNull()
}
func (_RetrievalTask__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"tasks.RetrievalTask.KeyAssembler"}.AssignBool(false)
}
func (_RetrievalTask__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"tasks.RetrievalTask.KeyAssembler"}.AssignInt(0)
}
func (_RetrievalTask__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"tasks.RetrievalTask.KeyAssembler"}.AssignFloat(0)
}
func (ka *_RetrievalTask__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Miner":
		if ka.s & fieldBit__RetrievalTask_Miner != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__RetrievalTask_Miner}
		}
		ka.s += fieldBit__RetrievalTask_Miner
		ka.state = maState_expectValue
		ka.f = 0
	case "PayloadCID":
		if ka.s & fieldBit__RetrievalTask_PayloadCID != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__RetrievalTask_PayloadCID}
		}
		ka.s += fieldBit__RetrievalTask_PayloadCID
		ka.state = maState_expectValue
		ka.f = 1
	case "CARExport":
		if ka.s & fieldBit__RetrievalTask_CARExport != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__RetrievalTask_CARExport}
		}
		ka.s += fieldBit__RetrievalTask_CARExport
		ka.state = maState_expectValue
		ka.f = 2
	case "Schedule":
		if ka.s & fieldBit__RetrievalTask_Schedule != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__RetrievalTask_Schedule}
		}
		ka.s += fieldBit__RetrievalTask_Schedule
		ka.state = maState_expectValue
		ka.f = 3
	case "ScheduleLimit":
		if ka.s & fieldBit__RetrievalTask_ScheduleLimit != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__RetrievalTask_ScheduleLimit}
		}
		ka.s += fieldBit__RetrievalTask_ScheduleLimit
		ka.state = maState_expectValue
		ka.f = 4
	default:
		return ipld.ErrInvalidKey{TypeName:"tasks.RetrievalTask", Key:&_String{k}}
	}
	return nil
}
func (_RetrievalTask__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"tasks.RetrievalTask.KeyAssembler"}.AssignBytes(nil)
}
func (_RetrievalTask__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"tasks.RetrievalTask.KeyAssembler"}.AssignLink(nil)
}
func (ka *_RetrievalTask__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_RetrievalTask__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (RetrievalTask) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n RetrievalTask) Representation() ipld.Node {
	return (*_RetrievalTask__Repr)(n)
}
type _RetrievalTask__Repr _RetrievalTask
var (
	fieldName__RetrievalTask_Miner_serial = _String{"Miner"}
	fieldName__RetrievalTask_PayloadCID_serial = _String{"PayloadCID"}
	fieldName__RetrievalTask_CARExport_serial = _String{"CARExport"}
	fieldName__RetrievalTask_Schedule_serial = _String{"Schedule"}
	fieldName__RetrievalTask_ScheduleLimit_serial = _String{"ScheduleLimit"}
)
var _ ipld.Node = &_RetrievalTask__Repr{}
func (_RetrievalTask__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_RetrievalTask__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Miner":
		return n.Miner.Representation(), nil
	case "PayloadCID":
		return n.PayloadCID.Representation(), nil
	case "CARExport":
		return n.CARExport.Representation(), nil
	case "Schedule":
		if n.Schedule.m == schema.Maybe_Absent {
			return ipld.Absent, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.Schedule.v.Representation(), nil
	case "ScheduleLimit":
		if n.ScheduleLimit.m == schema.Maybe_Absent {
			return ipld.Absent, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.ScheduleLimit.v.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_RetrievalTask__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_RetrievalTask__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"tasks.RetrievalTask.Repr"}.LookupByIndex(0)
}
func (n _RetrievalTask__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_RetrievalTask__Repr) MapIterator() ipld.MapIterator {
	end := 5
	if n.ScheduleLimit.m == schema.Maybe_Absent {
		end = 4
	} else {
		goto done
	}
	if n.Schedule.m == schema.Maybe_Absent {
		end = 3
	} else {
		goto done
	}
done:
	return &_RetrievalTask__ReprMapItr{n, 0, end}
}

type _RetrievalTask__ReprMapItr struct {
	n   *_RetrievalTask__Repr
	idx int
	end int
}

func (itr *_RetrievalTask__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
advance:if itr.idx >= 5 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__RetrievalTask_Miner_serial
		v = itr.n.Miner.Representation()
	case 1:
		k = &fieldName__RetrievalTask_PayloadCID_serial
		v = itr.n.PayloadCID.Representation()
	case 2:
		k = &fieldName__RetrievalTask_CARExport_serial
		v = itr.n.CARExport.Representation()
	case 3:
		k = &fieldName__RetrievalTask_Schedule_serial
		if itr.n.Schedule.m == schema.Maybe_Absent {
			itr.idx++
			goto advance
		}
		v = itr.n.Schedule.v.Representation()
	case 4:
		k = &fieldName__RetrievalTask_ScheduleLimit_serial
		if itr.n.ScheduleLimit.m == schema.Maybe_Absent {
			itr.idx++
			goto advance
		}
		v = itr.n.ScheduleLimit.v.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_RetrievalTask__ReprMapItr) Done() bool {
	return itr.idx >= itr.end
}
func (_RetrievalTask__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_RetrievalTask__Repr) Length() int64 {
	l := 5
	if rn.Schedule.m == schema.Maybe_Absent {
		l--
	}
	if rn.ScheduleLimit.m == schema.Maybe_Absent {
		l--
	}
	return int64(l)
}
func (_RetrievalTask__Repr) IsAbsent() bool {
	return false
}
func (_RetrievalTask__Repr) IsNull() bool {
	return false
}
func (_RetrievalTask__Repr) AsBool() (bool, error) {
	return mixins.Map{"tasks.RetrievalTask.Repr"}.AsBool()
}
func (_RetrievalTask__Repr) AsInt() (int64, error) {
	return mixins.Map{"tasks.RetrievalTask.Repr"}.AsInt()
}
func (_RetrievalTask__Repr) AsFloat() (float64, error) {
	return mixins.Map{"tasks.RetrievalTask.Repr"}.AsFloat()
}
func (_RetrievalTask__Repr) AsString() (string, error) {
	return mixins.Map{"tasks.RetrievalTask.Repr"}.AsString()
}
func (_RetrievalTask__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"tasks.RetrievalTask.Repr"}.AsBytes()
}
func (_RetrievalTask__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"tasks.RetrievalTask.Repr"}.AsLink()
}
func (_RetrievalTask__Repr) Prototype() ipld.NodePrototype {
	return _RetrievalTask__ReprPrototype{}
}
type _RetrievalTask__ReprPrototype struct{}

func (_RetrievalTask__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _RetrievalTask__ReprBuilder
	nb.Reset()
	return &nb
}
type _RetrievalTask__ReprBuilder struct {
	_RetrievalTask__ReprAssembler
}
func (nb *_RetrievalTask__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_RetrievalTask__ReprBuilder) Reset() {
	var w _RetrievalTask
	var m schema.Maybe
	*nb = _RetrievalTask__ReprBuilder{_RetrievalTask__ReprAssembler{w: &w, m: &m}}
}
type _RetrievalTask__ReprAssembler struct {
	w *_RetrievalTask
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_Miner _String__ReprAssembler
	ca_PayloadCID _String__ReprAssembler
	ca_CARExport _Bool__ReprAssembler
	ca_Schedule _String__ReprAssembler
	ca_ScheduleLimit _String__ReprAssembler
	}

func (na *_RetrievalTask__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Miner.reset()
	na.ca_PayloadCID.reset()
	na.ca_CARExport.reset()
	na.ca_Schedule.reset()
	na.ca_ScheduleLimit.reset()
}
func (na *_RetrievalTask__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_RetrievalTask{}
	}
	return na, nil
}
func (_RetrievalTask__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"tasks.RetrievalTask.Repr"}.BeginList(0)
}
func (na *_RetrievalTask__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"tasks.RetrievalTask.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_RetrievalTask__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"tasks.RetrievalTask.Repr"}.AssignBool(false)
}
func (_RetrievalTask__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"tasks.RetrievalTask.Repr"}.AssignInt(0)
}
func (_RetrievalTask__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"tasks.RetrievalTask.Repr"}.AssignFloat(0)
}
func (_RetrievalTask__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"tasks.RetrievalTask.Repr"}.AssignString("")
}
func (_RetrievalTask__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"tasks.RetrievalTask.Repr"}.AssignBytes(nil)
}
func (_RetrievalTask__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"tasks.RetrievalTask.Repr"}.AssignLink(nil)
}
func (na *_RetrievalTask__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_RetrievalTask); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "tasks.RetrievalTask.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_RetrievalTask__ReprAssembler) Prototype() ipld.NodePrototype {
	return _RetrievalTask__ReprPrototype{}
}
func (ma *_RetrievalTask__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.w.Schedule.m {
		case schema.Maybe_Value:
			ma.w.Schedule.v = ma.ca_Schedule.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.w.ScheduleLimit.m {
		case schema.Maybe_Value:
			ma.w.ScheduleLimit.v = ma.ca_ScheduleLimit.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_RetrievalTask__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Miner":
		if ma.s & fieldBit__RetrievalTask_Miner != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__RetrievalTask_Miner_serial}
		}
		ma.s += fieldBit__RetrievalTask_Miner
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Miner.w = &ma.w.Miner
		ma.ca_Miner.m = &ma.cm
		return &ma.ca_Miner, nil
	case "PayloadCID":
		if ma.s & fieldBit__RetrievalTask_PayloadCID != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__RetrievalTask_PayloadCID_serial}
		}
		ma.s += fieldBit__RetrievalTask_PayloadCID
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_PayloadCID.w = &ma.w.PayloadCID
		ma.ca_PayloadCID.m = &ma.cm
		return &ma.ca_PayloadCID, nil
	case "CARExport":
		if ma.s & fieldBit__RetrievalTask_CARExport != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__RetrievalTask_CARExport_serial}
		}
		ma.s += fieldBit__RetrievalTask_CARExport
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_CARExport.w = &ma.w.CARExport
		ma.ca_CARExport.m = &ma.cm
		return &ma.ca_CARExport, nil
	case "Schedule":
		if ma.s & fieldBit__RetrievalTask_Schedule != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__RetrievalTask_Schedule_serial}
		}
		ma.s += fieldBit__RetrievalTask_Schedule
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_Schedule.w = ma.w.Schedule.v
		ma.ca_Schedule.m = &ma.w.Schedule.m
		
		return &ma.ca_Schedule, nil
	case "ScheduleLimit":
		if ma.s & fieldBit__RetrievalTask_ScheduleLimit != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__RetrievalTask_ScheduleLimit_serial}
		}
		ma.s += fieldBit__RetrievalTask_ScheduleLimit
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_ScheduleLimit.w = ma.w.ScheduleLimit.v
		ma.ca_ScheduleLimit.m = &ma.w.ScheduleLimit.m
		
		return &ma.ca_ScheduleLimit, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"tasks.RetrievalTask.Repr", Key:&_String{k}}
	}
}
func (ma *_RetrievalTask__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_RetrievalTask__ReprKeyAssembler)(ma)
}
func (ma *_RetrievalTask__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Miner.w = &ma.w.Miner
		ma.ca_Miner.m = &ma.cm
		return &ma.ca_Miner
	case 1:
		ma.ca_PayloadCID.w = &ma.w.PayloadCID
		ma.ca_PayloadCID.m = &ma.cm
		return &ma.ca_PayloadCID
	case 2:
		ma.ca_CARExport.w = &ma.w.CARExport
		ma.ca_CARExport.m = &ma.cm
		return &ma.ca_CARExport
	case 3:
		ma.ca_Schedule.w = ma.w.Schedule.v
		ma.ca_Schedule.m = &ma.w.Schedule.m
		
		return &ma.ca_Schedule
	case 4:
		ma.ca_ScheduleLimit.w = ma.w.ScheduleLimit.v
		ma.ca_ScheduleLimit.m = &ma.w.ScheduleLimit.m
		
		return &ma.ca_ScheduleLimit
	default:
		panic("unreachable")
	}
}
func (ma *_RetrievalTask__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s & fieldBits__RetrievalTask_sufficient != fieldBits__RetrievalTask_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s & fieldBit__RetrievalTask_Miner == 0 {
			err.Missing = append(err.Missing, "Miner")
		}
		if ma.s & fieldBit__RetrievalTask_PayloadCID == 0 {
			err.Missing = append(err.Missing, "PayloadCID")
		}
		if ma.s & fieldBit__RetrievalTask_CARExport == 0 {
			err.Missing = append(err.Missing, "CARExport")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_RetrievalTask__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_RetrievalTask__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}
type _RetrievalTask__ReprKeyAssembler _RetrievalTask__ReprAssembler
func (_RetrievalTask__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"tasks.RetrievalTask.Repr.KeyAssembler"}.BeginMap(0)
}
func (_RetrievalTask__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"tasks.RetrievalTask.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_RetrievalTask__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"tasks.RetrievalTask.Repr.KeyAssembler"}.AssignNull()
}
func (_RetrievalTask__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"tasks.RetrievalTask.Repr.KeyAssembler"}.AssignBool(false)
}
func (_RetrievalTask__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"tasks.RetrievalTask.Repr.KeyAssembler"}.AssignInt(0)
}
func (_RetrievalTask__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"tasks.RetrievalTask.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_RetrievalTask__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Miner":
		if ka.s & fieldBit__RetrievalTask_Miner != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__RetrievalTask_Miner_serial}
		}
		ka.s += fieldBit__RetrievalTask_Miner
		ka.state = maState_expectValue
		ka.f = 0
	case "PayloadCID":
		if ka.s & fieldBit__RetrievalTask_PayloadCID != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__RetrievalTask_PayloadCID_serial}
		}
		ka.s += fieldBit__RetrievalTask_PayloadCID
		ka.state = maState_expectValue
		ka.f = 1
	case "CARExport":
		if ka.s & fieldBit__RetrievalTask_CARExport != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__RetrievalTask_CARExport_serial}
		}
		ka.s += fieldBit__RetrievalTask_CARExport
		ka.state = maState_expectValue
		ka.f = 2
	case "Schedule":
		if ka.s & fieldBit__RetrievalTask_Schedule != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__RetrievalTask_Schedule_serial}
		}
		ka.s += fieldBit__RetrievalTask_Schedule
		ka.state = maState_expectValue
		ka.f = 3
	case "ScheduleLimit":
		if ka.s & fieldBit__RetrievalTask_ScheduleLimit != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__RetrievalTask_ScheduleLimit_serial}
		}
		ka.s += fieldBit__RetrievalTask_ScheduleLimit
		ka.state = maState_expectValue
		ka.f = 4
	default:
		return ipld.ErrInvalidKey{TypeName:"tasks.RetrievalTask.Repr", Key:&_String{k}}
	}
	return nil
}
func (_RetrievalTask__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"tasks.RetrievalTask.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_RetrievalTask__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"tasks.RetrievalTask.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_RetrievalTask__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_RetrievalTask__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}


func (n _StageDetails) FieldDescription() MaybeString {
	return &n.Description
}
func (n _StageDetails) FieldExpectedDuration() MaybeString {
	return &n.ExpectedDuration
}
func (n _StageDetails) FieldLogs() List_Logs {
	return &n.Logs
}
func (n _StageDetails) FieldUpdatedAt() MaybeTime {
	return &n.UpdatedAt
}
type _StageDetails__Maybe struct {
	m schema.Maybe
	v StageDetails
}
type MaybeStageDetails = *_StageDetails__Maybe

func (m MaybeStageDetails) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeStageDetails) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeStageDetails) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeStageDetails) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeStageDetails) Must() StageDetails {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
	fieldName__StageDetails_Description = _String{"Description"}
	fieldName__StageDetails_ExpectedDuration = _String{"ExpectedDuration"}
	fieldName__StageDetails_Logs = _String{"Logs"}
	fieldName__StageDetails_UpdatedAt = _String{"UpdatedAt"}
)
var _ ipld.Node = (StageDetails)(&_StageDetails{})
var _ schema.TypedNode = (StageDetails)(&_StageDetails{})
func (StageDetails) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n StageDetails) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Description":
		if n.Description.m == schema.Maybe_Absent {
			return ipld.Absent, nil
		}
		return n.Description.v, nil
	case "ExpectedDuration":
		if n.ExpectedDuration.m == schema.Maybe_Absent {
			return ipld.Absent, nil
		}
		return n.ExpectedDuration.v, nil
	case "Logs":
		return &n.Logs, nil
	case "UpdatedAt":
		if n.UpdatedAt.m == schema.Maybe_Absent {
			return ipld.Absent, nil
		}
		return n.UpdatedAt.v, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n StageDetails) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (StageDetails) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"tasks.StageDetails"}.LookupByIndex(0)
}
func (n StageDetails) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n StageDetails) MapIterator() ipld.MapIterator {
	return &_StageDetails__MapItr{n, 0}
}

type _StageDetails__MapItr struct {
	n StageDetails
	idx  int
}

func (itr *_StageDetails__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 4 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__StageDetails_Description
		if itr.n.Description.m == schema.Maybe_Absent {
			v = ipld.Absent
			break
		}
		v = itr.n.Description.v
	case 1:
		k = &fieldName__StageDetails_ExpectedDuration
		if itr.n.ExpectedDuration.m == schema.Maybe_Absent {
			v = ipld.Absent
			break
		}
		v = itr.n.ExpectedDuration.v
	case 2:
		k = &fieldName__StageDetails_Logs
		v = &itr.n.Logs
	case 3:
		k = &fieldName__StageDetails_UpdatedAt
		if itr.n.UpdatedAt.m == schema.Maybe_Absent {
			v = ipld.Absent
			break
		}
		v = itr.n.UpdatedAt.v
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_StageDetails__MapItr) Done() bool {
	return itr.idx >= 4
}

func (StageDetails) ListIterator() ipld.ListIterator {
	return nil
}
func (StageDetails) Length() int64 {
	return 4
}
func (StageDetails) IsAbsent() bool {
	return false
}
func (StageDetails) IsNull() bool {
	return false
}
func (StageDetails) AsBool() (bool, error) {
	return mixins.Map{"tasks.StageDetails"}.AsBool()
}
func (StageDetails) AsInt() (int64, error) {
	return mixins.Map{"tasks.StageDetails"}.AsInt()
}
func (StageDetails) AsFloat() (float64, error) {
	return mixins.Map{"tasks.StageDetails"}.AsFloat()
}
func (StageDetails) AsString() (string, error) {
	return mixins.Map{"tasks.StageDetails"}.AsString()
}
func (StageDetails) AsBytes() ([]byte, error) {
	return mixins.Map{"tasks.StageDetails"}.AsBytes()
}
func (StageDetails) AsLink() (ipld.Link, error) {
	return mixins.Map{"tasks.StageDetails"}.AsLink()
}
func (StageDetails) Prototype() ipld.NodePrototype {
	return _StageDetails__Prototype{}
}
type _StageDetails__Prototype struct{}

func (_StageDetails__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _StageDetails__Builder
	nb.Reset()
	return &nb
}
type _StageDetails__Builder struct {
	_StageDetails__Assembler
}
func (nb *_StageDetails__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_StageDetails__Builder) Reset() {
	var w _StageDetails
	var m schema.Maybe
	*nb = _StageDetails__Builder{_StageDetails__Assembler{w: &w, m: &m}}
}
type _StageDetails__Assembler struct {
	w *_StageDetails
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_Description _String__Assembler
	ca_ExpectedDuration _String__Assembler
	ca_Logs _List_Logs__Assembler
	ca_UpdatedAt _Time__Assembler
	}

func (na *_StageDetails__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Description.reset()
	na.ca_ExpectedDuration.reset()
	na.ca_Logs.reset()
	na.ca_UpdatedAt.reset()
}

var (
	fieldBit__StageDetails_Description = 1 << 0
	fieldBit__StageDetails_ExpectedDuration = 1 << 1
	fieldBit__StageDetails_Logs = 1 << 2
	fieldBit__StageDetails_UpdatedAt = 1 << 3
	fieldBits__StageDetails_sufficient = 0 + 1 << 2
)
func (na *_StageDetails__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_StageDetails{}
	}
	return na, nil
}
func (_StageDetails__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"tasks.StageDetails"}.BeginList(0)
}
func (na *_StageDetails__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"tasks.StageDetails"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_StageDetails__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"tasks.StageDetails"}.AssignBool(false)
}
func (_StageDetails__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"tasks.StageDetails"}.AssignInt(0)
}
func (_StageDetails__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"tasks.StageDetails"}.AssignFloat(0)
}
func (_StageDetails__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"tasks.StageDetails"}.AssignString("")
}
func (_StageDetails__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"tasks.StageDetails"}.AssignBytes(nil)
}
func (_StageDetails__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"tasks.StageDetails"}.AssignLink(nil)
}
func (na *_StageDetails__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_StageDetails); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "tasks.StageDetails", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_StageDetails__Assembler) Prototype() ipld.NodePrototype {
	return _StageDetails__Prototype{}
}
func (ma *_StageDetails__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.w.Description.m {
		case schema.Maybe_Value:
			ma.w.Description.v = ma.ca_Description.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.w.ExpectedDuration.m {
		case schema.Maybe_Value:
			ma.w.ExpectedDuration.v = ma.ca_ExpectedDuration.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Logs.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.w.UpdatedAt.m {
		case schema.Maybe_Value:
			ma.w.UpdatedAt.v = ma.ca_UpdatedAt.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_StageDetails__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Description":
		if ma.s & fieldBit__StageDetails_Description != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__StageDetails_Description}
		}
		ma.s += fieldBit__StageDetails_Description
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Description.w = ma.w.Description.v
		ma.ca_Description.m = &ma.w.Description.m
		return &ma.ca_Description, nil
	case "ExpectedDuration":
		if ma.s & fieldBit__StageDetails_ExpectedDuration != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__StageDetails_ExpectedDuration}
		}
		ma.s += fieldBit__StageDetails_ExpectedDuration
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_ExpectedDuration.w = ma.w.ExpectedDuration.v
		ma.ca_ExpectedDuration.m = &ma.w.ExpectedDuration.m
		return &ma.ca_ExpectedDuration, nil
	case "Logs":
		if ma.s & fieldBit__StageDetails_Logs != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__StageDetails_Logs}
		}
		ma.s += fieldBit__StageDetails_Logs
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Logs.w = &ma.w.Logs
		ma.ca_Logs.m = &ma.cm
		return &ma.ca_Logs, nil
	case "UpdatedAt":
		if ma.s & fieldBit__StageDetails_UpdatedAt != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__StageDetails_UpdatedAt}
		}
		ma.s += fieldBit__StageDetails_UpdatedAt
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_UpdatedAt.w = ma.w.UpdatedAt.v
		ma.ca_UpdatedAt.m = &ma.w.UpdatedAt.m
		return &ma.ca_UpdatedAt, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"tasks.StageDetails", Key:&_String{k}}
	}
}
func (ma *_StageDetails__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_StageDetails__KeyAssembler)(ma)
}
func (ma *_StageDetails__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Description.w = ma.w.Description.v
		ma.ca_Description.m = &ma.w.Description.m
		return &ma.ca_Description
	case 1:
		ma.ca_ExpectedDuration.w = ma.w.ExpectedDuration.v
		ma.ca_ExpectedDuration.m = &ma.w.ExpectedDuration.m
		return &ma.ca_ExpectedDuration
	case 2:
		ma.ca_Logs.w = &ma.w.Logs
		ma.ca_Logs.m = &ma.cm
		return &ma.ca_Logs
	case 3:
		ma.ca_UpdatedAt.w = ma.w.UpdatedAt.v
		ma.ca_UpdatedAt.m = &ma.w.UpdatedAt.m
		return &ma.ca_UpdatedAt
	default:
		panic("unreachable")
	}
}
func (ma *_StageDetails__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s & fieldBits__StageDetails_sufficient != fieldBits__StageDetails_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s & fieldBit__StageDetails_Logs == 0 {
			err.Missing = append(err.Missing, "Logs")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_StageDetails__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_StageDetails__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}
type _StageDetails__KeyAssembler _StageDetails__Assembler
func (_StageDetails__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"tasks.StageDetails.KeyAssembler"}.BeginMap(0)
}
func (_StageDetails__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"tasks.StageDetails.KeyAssembler"}.BeginList(0)
}
func (na *_StageDetails__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"tasks.StageDetails.KeyAssembler"}.AssignNull()
}
func (_StageDetails__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"tasks.StageDetails.KeyAssembler"}.AssignBool(false)
}
func (_StageDetails__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"tasks.StageDetails.KeyAssembler"}.AssignInt(0)
}
func (_StageDetails__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"tasks.StageDetails.KeyAssembler"}.AssignFloat(0)
}
func (ka *_StageDetails__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Description":
		if ka.s & fieldBit__StageDetails_Description != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__StageDetails_Description}
		}
		ka.s += fieldBit__StageDetails_Description
		ka.state = maState_expectValue
		ka.f = 0
	case "ExpectedDuration":
		if ka.s & fieldBit__StageDetails_ExpectedDuration != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__StageDetails_ExpectedDuration}
		}
		ka.s += fieldBit__StageDetails_ExpectedDuration
		ka.state = maState_expectValue
		ka.f = 1
	case "Logs":
		if ka.s & fieldBit__StageDetails_Logs != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__StageDetails_Logs}
		}
		ka.s += fieldBit__StageDetails_Logs
		ka.state = maState_expectValue
		ka.f = 2
	case "UpdatedAt":
		if ka.s & fieldBit__StageDetails_UpdatedAt != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__StageDetails_UpdatedAt}
		}
		ka.s += fieldBit__StageDetails_UpdatedAt
		ka.state = maState_expectValue
		ka.f = 3
	default:
		return ipld.ErrInvalidKey{TypeName:"tasks.StageDetails", Key:&_String{k}}
	}
	return nil
}
func (_StageDetails__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"tasks.StageDetails.KeyAssembler"}.AssignBytes(nil)
}
func (_StageDetails__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"tasks.StageDetails.KeyAssembler"}.AssignLink(nil)
}
func (ka *_StageDetails__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_StageDetails__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (StageDetails) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n StageDetails) Representation() ipld.Node {
	return (*_StageDetails__Repr)(n)
}
type _StageDetails__Repr _StageDetails
var (
	fieldName__StageDetails_Description_serial = _String{"Description"}
	fieldName__StageDetails_ExpectedDuration_serial = _String{"ExpectedDuration"}
	fieldName__StageDetails_Logs_serial = _String{"Logs"}
	fieldName__StageDetails_UpdatedAt_serial = _String{"UpdatedAt"}
)
var _ ipld.Node = &_StageDetails__Repr{}
func (_StageDetails__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_StageDetails__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Description":
		if n.Description.m == schema.Maybe_Absent {
			return ipld.Absent, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.Description.v.Representation(), nil
	case "ExpectedDuration":
		if n.ExpectedDuration.m == schema.Maybe_Absent {
			return ipld.Absent, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.ExpectedDuration.v.Representation(), nil
	case "Logs":
		return n.Logs.Representation(), nil
	case "UpdatedAt":
		if n.UpdatedAt.m == schema.Maybe_Absent {
			return ipld.Absent, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.UpdatedAt.v.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_StageDetails__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_StageDetails__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"tasks.StageDetails.Repr"}.LookupByIndex(0)
}
func (n _StageDetails__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_StageDetails__Repr) MapIterator() ipld.MapIterator {
	end := 4
	if n.UpdatedAt.m == schema.Maybe_Absent {
		end = 3
	} else {
		goto done
	}
done:
	return &_StageDetails__ReprMapItr{n, 0, end}
}

type _StageDetails__ReprMapItr struct {
	n   *_StageDetails__Repr
	idx int
	end int
}

func (itr *_StageDetails__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
advance:if itr.idx >= 4 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__StageDetails_Description_serial
		if itr.n.Description.m == schema.Maybe_Absent {
			itr.idx++
			goto advance
		}
		v = itr.n.Description.v.Representation()
	case 1:
		k = &fieldName__StageDetails_ExpectedDuration_serial
		if itr.n.ExpectedDuration.m == schema.Maybe_Absent {
			itr.idx++
			goto advance
		}
		v = itr.n.ExpectedDuration.v.Representation()
	case 2:
		k = &fieldName__StageDetails_Logs_serial
		v = itr.n.Logs.Representation()
	case 3:
		k = &fieldName__StageDetails_UpdatedAt_serial
		if itr.n.UpdatedAt.m == schema.Maybe_Absent {
			itr.idx++
			goto advance
		}
		v = itr.n.UpdatedAt.v.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_StageDetails__ReprMapItr) Done() bool {
	return itr.idx >= itr.end
}
func (_StageDetails__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_StageDetails__Repr) Length() int64 {
	l := 4
	if rn.Description.m == schema.Maybe_Absent {
		l--
	}
	if rn.ExpectedDuration.m == schema.Maybe_Absent {
		l--
	}
	if rn.UpdatedAt.m == schema.Maybe_Absent {
		l--
	}
	return int64(l)
}
func (_StageDetails__Repr) IsAbsent() bool {
	return false
}
func (_StageDetails__Repr) IsNull() bool {
	return false
}
func (_StageDetails__Repr) AsBool() (bool, error) {
	return mixins.Map{"tasks.StageDetails.Repr"}.AsBool()
}
func (_StageDetails__Repr) AsInt() (int64, error) {
	return mixins.Map{"tasks.StageDetails.Repr"}.AsInt()
}
func (_StageDetails__Repr) AsFloat() (float64, error) {
	return mixins.Map{"tasks.StageDetails.Repr"}.AsFloat()
}
func (_StageDetails__Repr) AsString() (string, error) {
	return mixins.Map{"tasks.StageDetails.Repr"}.AsString()
}
func (_StageDetails__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"tasks.StageDetails.Repr"}.AsBytes()
}
func (_StageDetails__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"tasks.StageDetails.Repr"}.AsLink()
}
func (_StageDetails__Repr) Prototype() ipld.NodePrototype {
	return _StageDetails__ReprPrototype{}
}
type _StageDetails__ReprPrototype struct{}

func (_StageDetails__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _StageDetails__ReprBuilder
	nb.Reset()
	return &nb
}
type _StageDetails__ReprBuilder struct {
	_StageDetails__ReprAssembler
}
func (nb *_StageDetails__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_StageDetails__ReprBuilder) Reset() {
	var w _StageDetails
	var m schema.Maybe
	*nb = _StageDetails__ReprBuilder{_StageDetails__ReprAssembler{w: &w, m: &m}}
}
type _StageDetails__ReprAssembler struct {
	w *_StageDetails
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_Description _String__ReprAssembler
	ca_ExpectedDuration _String__ReprAssembler
	ca_Logs _List_Logs__ReprAssembler
	ca_UpdatedAt _Time__ReprAssembler
	}

func (na *_StageDetails__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Description.reset()
	na.ca_ExpectedDuration.reset()
	na.ca_Logs.reset()
	na.ca_UpdatedAt.reset()
}
func (na *_StageDetails__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_StageDetails{}
	}
	return na, nil
}
func (_StageDetails__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"tasks.StageDetails.Repr"}.BeginList(0)
}
func (na *_StageDetails__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"tasks.StageDetails.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_StageDetails__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"tasks.StageDetails.Repr"}.AssignBool(false)
}
func (_StageDetails__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"tasks.StageDetails.Repr"}.AssignInt(0)
}
func (_StageDetails__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"tasks.StageDetails.Repr"}.AssignFloat(0)
}
func (_StageDetails__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"tasks.StageDetails.Repr"}.AssignString("")
}
func (_StageDetails__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"tasks.StageDetails.Repr"}.AssignBytes(nil)
}
func (_StageDetails__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"tasks.StageDetails.Repr"}.AssignLink(nil)
}
func (na *_StageDetails__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_StageDetails); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "tasks.StageDetails.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_StageDetails__ReprAssembler) Prototype() ipld.NodePrototype {
	return _StageDetails__ReprPrototype{}
}
func (ma *_StageDetails__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.w.Description.m {
		case schema.Maybe_Value:
			ma.w.Description.v = ma.ca_Description.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.w.ExpectedDuration.m {
		case schema.Maybe_Value:
			ma.w.ExpectedDuration.v = ma.ca_ExpectedDuration.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.w.UpdatedAt.m {
		case schema.Maybe_Value:
			ma.w.UpdatedAt.v = ma.ca_UpdatedAt.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_StageDetails__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Description":
		if ma.s & fieldBit__StageDetails_Description != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__StageDetails_Description_serial}
		}
		ma.s += fieldBit__StageDetails_Description
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Description.w = ma.w.Description.v
		ma.ca_Description.m = &ma.w.Description.m
		
		return &ma.ca_Description, nil
	case "ExpectedDuration":
		if ma.s & fieldBit__StageDetails_ExpectedDuration != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__StageDetails_ExpectedDuration_serial}
		}
		ma.s += fieldBit__StageDetails_ExpectedDuration
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_ExpectedDuration.w = ma.w.ExpectedDuration.v
		ma.ca_ExpectedDuration.m = &ma.w.ExpectedDuration.m
		
		return &ma.ca_ExpectedDuration, nil
	case "Logs":
		if ma.s & fieldBit__StageDetails_Logs != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__StageDetails_Logs_serial}
		}
		ma.s += fieldBit__StageDetails_Logs
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Logs.w = &ma.w.Logs
		ma.ca_Logs.m = &ma.cm
		return &ma.ca_Logs, nil
	case "UpdatedAt":
		if ma.s & fieldBit__StageDetails_UpdatedAt != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__StageDetails_UpdatedAt_serial}
		}
		ma.s += fieldBit__StageDetails_UpdatedAt
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_UpdatedAt.w = ma.w.UpdatedAt.v
		ma.ca_UpdatedAt.m = &ma.w.UpdatedAt.m
		
		return &ma.ca_UpdatedAt, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"tasks.StageDetails.Repr", Key:&_String{k}}
	}
}
func (ma *_StageDetails__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_StageDetails__ReprKeyAssembler)(ma)
}
func (ma *_StageDetails__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Description.w = ma.w.Description.v
		ma.ca_Description.m = &ma.w.Description.m
		
		return &ma.ca_Description
	case 1:
		ma.ca_ExpectedDuration.w = ma.w.ExpectedDuration.v
		ma.ca_ExpectedDuration.m = &ma.w.ExpectedDuration.m
		
		return &ma.ca_ExpectedDuration
	case 2:
		ma.ca_Logs.w = &ma.w.Logs
		ma.ca_Logs.m = &ma.cm
		return &ma.ca_Logs
	case 3:
		ma.ca_UpdatedAt.w = ma.w.UpdatedAt.v
		ma.ca_UpdatedAt.m = &ma.w.UpdatedAt.m
		
		return &ma.ca_UpdatedAt
	default:
		panic("unreachable")
	}
}
func (ma *_StageDetails__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s & fieldBits__StageDetails_sufficient != fieldBits__StageDetails_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s & fieldBit__StageDetails_Logs == 0 {
			err.Missing = append(err.Missing, "Logs")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_StageDetails__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_StageDetails__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}
type _StageDetails__ReprKeyAssembler _StageDetails__ReprAssembler
func (_StageDetails__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"tasks.StageDetails.Repr.KeyAssembler"}.BeginMap(0)
}
func (_StageDetails__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"tasks.StageDetails.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_StageDetails__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"tasks.StageDetails.Repr.KeyAssembler"}.AssignNull()
}
func (_StageDetails__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"tasks.StageDetails.Repr.KeyAssembler"}.AssignBool(false)
}
func (_StageDetails__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"tasks.StageDetails.Repr.KeyAssembler"}.AssignInt(0)
}
func (_StageDetails__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"tasks.StageDetails.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_StageDetails__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Description":
		if ka.s & fieldBit__StageDetails_Description != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__StageDetails_Description_serial}
		}
		ka.s += fieldBit__StageDetails_Description
		ka.state = maState_expectValue
		ka.f = 0
	case "ExpectedDuration":
		if ka.s & fieldBit__StageDetails_ExpectedDuration != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__StageDetails_ExpectedDuration_serial}
		}
		ka.s += fieldBit__StageDetails_ExpectedDuration
		ka.state = maState_expectValue
		ka.f = 1
	case "Logs":
		if ka.s & fieldBit__StageDetails_Logs != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__StageDetails_Logs_serial}
		}
		ka.s += fieldBit__StageDetails_Logs
		ka.state = maState_expectValue
		ka.f = 2
	case "UpdatedAt":
		if ka.s & fieldBit__StageDetails_UpdatedAt != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__StageDetails_UpdatedAt_serial}
		}
		ka.s += fieldBit__StageDetails_UpdatedAt
		ka.state = maState_expectValue
		ka.f = 3
	default:
		return ipld.ErrInvalidKey{TypeName:"tasks.StageDetails.Repr", Key:&_String{k}}
	}
	return nil
}
func (_StageDetails__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"tasks.StageDetails.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_StageDetails__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"tasks.StageDetails.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_StageDetails__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_StageDetails__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n Status) Int() int64 {
	return n.x
}
func (_Status__Prototype) FromInt(v int64) (Status, error) {
	n := _Status{v}
	return &n, nil
}
type _Status__Maybe struct {
	m schema.Maybe
	v Status
}
type MaybeStatus = *_Status__Maybe

func (m MaybeStatus) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeStatus) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeStatus) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeStatus) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeStatus) Must() Status {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var _ ipld.Node = (Status)(&_Status{})
var _ schema.TypedNode = (Status)(&_Status{})
func (Status) Kind() ipld.Kind {
	return ipld.Kind_Int
}
func (Status) LookupByString(string) (ipld.Node, error) {
	return mixins.Int{"tasks.Status"}.LookupByString("")
}
func (Status) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Int{"tasks.Status"}.LookupByNode(nil)
}
func (Status) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Int{"tasks.Status"}.LookupByIndex(0)
}
func (Status) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Int{"tasks.Status"}.LookupBySegment(seg)
}
func (Status) MapIterator() ipld.MapIterator {
	return nil
}
func (Status) ListIterator() ipld.ListIterator {
	return nil
}
func (Status) Length() int64 {
	return -1
}
func (Status) IsAbsent() bool {
	return false
}
func (Status) IsNull() bool {
	return false
}
func (Status) AsBool() (bool, error) {
	return mixins.Int{"tasks.Status"}.AsBool()
}
func (n Status) AsInt() (int64, error) {
	return n.x, nil
}
func (Status) AsFloat() (float64, error) {
	return mixins.Int{"tasks.Status"}.AsFloat()
}
func (Status) AsString() (string, error) {
	return mixins.Int{"tasks.Status"}.AsString()
}
func (Status) AsBytes() ([]byte, error) {
	return mixins.Int{"tasks.Status"}.AsBytes()
}
func (Status) AsLink() (ipld.Link, error) {
	return mixins.Int{"tasks.Status"}.AsLink()
}
func (Status) Prototype() ipld.NodePrototype {
	return _Status__Prototype{}
}
type _Status__Prototype struct{}

func (_Status__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Status__Builder
	nb.Reset()
	return &nb
}
type _Status__Builder struct {
	_Status__Assembler
}
func (nb *_Status__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Status__Builder) Reset() {
	var w _Status
	var m schema.Maybe
	*nb = _Status__Builder{_Status__Assembler{w: &w, m: &m}}
}
type _Status__Assembler struct {
	w *_Status
	m *schema.Maybe
}

func (na *_Status__Assembler) reset() {}
func (_Status__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.IntAssembler{"tasks.Status"}.BeginMap(0)
}
func (_Status__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.IntAssembler{"tasks.Status"}.BeginList(0)
}
func (na *_Status__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.IntAssembler{"tasks.Status"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_Status__Assembler) AssignBool(bool) error {
	return mixins.IntAssembler{"tasks.Status"}.AssignBool(false)
}
func (na *_Status__Assembler) AssignInt(v int64) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_Status{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_Status__Assembler) AssignFloat(float64) error {
	return mixins.IntAssembler{"tasks.Status"}.AssignFloat(0)
}
func (_Status__Assembler) AssignString(string) error {
	return mixins.IntAssembler{"tasks.Status"}.AssignString("")
}
func (_Status__Assembler) AssignBytes([]byte) error {
	return mixins.IntAssembler{"tasks.Status"}.AssignBytes(nil)
}
func (_Status__Assembler) AssignLink(ipld.Link) error {
	return mixins.IntAssembler{"tasks.Status"}.AssignLink(nil)
}
func (na *_Status__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Status); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsInt(); err != nil {
		return err
	} else {
		return na.AssignInt(v2)
	}
}
func (_Status__Assembler) Prototype() ipld.NodePrototype {
	return _Status__Prototype{}
}
func (Status) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Status) Representation() ipld.Node {
	return (*_Status__Repr)(n)
}
type _Status__Repr = _Status
var _ ipld.Node = &_Status__Repr{}
type _Status__ReprPrototype = _Status__Prototype
type _Status__ReprAssembler = _Status__Assembler


func (n _StorageTask) FieldMiner() String {
	return &n.Miner
}
func (n _StorageTask) FieldMaxPriceAttoFIL() Int {
	return &n.MaxPriceAttoFIL
}
func (n _StorageTask) FieldSize() Int {
	return &n.Size
}
func (n _StorageTask) FieldStartOffset() Int {
	return &n.StartOffset
}
func (n _StorageTask) FieldFastRetrieval() Bool {
	return &n.FastRetrieval
}
func (n _StorageTask) FieldVerified() Bool {
	return &n.Verified
}
func (n _StorageTask) FieldSchedule() MaybeString {
	return &n.Schedule
}
func (n _StorageTask) FieldScheduleLimit() MaybeString {
	return &n.ScheduleLimit
}
type _StorageTask__Maybe struct {
	m schema.Maybe
	v StorageTask
}
type MaybeStorageTask = *_StorageTask__Maybe

func (m MaybeStorageTask) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeStorageTask) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeStorageTask) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeStorageTask) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeStorageTask) Must() StorageTask {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
	fieldName__StorageTask_Miner = _String{"Miner"}
	fieldName__StorageTask_MaxPriceAttoFIL = _String{"MaxPriceAttoFIL"}
	fieldName__StorageTask_Size = _String{"Size"}
	fieldName__StorageTask_StartOffset = _String{"StartOffset"}
	fieldName__StorageTask_FastRetrieval = _String{"FastRetrieval"}
	fieldName__StorageTask_Verified = _String{"Verified"}
	fieldName__StorageTask_Schedule = _String{"Schedule"}
	fieldName__StorageTask_ScheduleLimit = _String{"ScheduleLimit"}
)
var _ ipld.Node = (StorageTask)(&_StorageTask{})
var _ schema.TypedNode = (StorageTask)(&_StorageTask{})
func (StorageTask) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n StorageTask) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Miner":
		return &n.Miner, nil
	case "MaxPriceAttoFIL":
		return &n.MaxPriceAttoFIL, nil
	case "Size":
		return &n.Size, nil
	case "StartOffset":
		return &n.StartOffset, nil
	case "FastRetrieval":
		return &n.FastRetrieval, nil
	case "Verified":
		return &n.Verified, nil
	case "Schedule":
		if n.Schedule.m == schema.Maybe_Absent {
			return ipld.Absent, nil
		}
		return n.Schedule.v, nil
	case "ScheduleLimit":
		if n.ScheduleLimit.m == schema.Maybe_Absent {
			return ipld.Absent, nil
		}
		return n.ScheduleLimit.v, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n StorageTask) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (StorageTask) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"tasks.StorageTask"}.LookupByIndex(0)
}
func (n StorageTask) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n StorageTask) MapIterator() ipld.MapIterator {
	return &_StorageTask__MapItr{n, 0}
}

type _StorageTask__MapItr struct {
	n StorageTask
	idx  int
}

func (itr *_StorageTask__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 8 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__StorageTask_Miner
		v = &itr.n.Miner
	case 1:
		k = &fieldName__StorageTask_MaxPriceAttoFIL
		v = &itr.n.MaxPriceAttoFIL
	case 2:
		k = &fieldName__StorageTask_Size
		v = &itr.n.Size
	case 3:
		k = &fieldName__StorageTask_StartOffset
		v = &itr.n.StartOffset
	case 4:
		k = &fieldName__StorageTask_FastRetrieval
		v = &itr.n.FastRetrieval
	case 5:
		k = &fieldName__StorageTask_Verified
		v = &itr.n.Verified
	case 6:
		k = &fieldName__StorageTask_Schedule
		if itr.n.Schedule.m == schema.Maybe_Absent {
			v = ipld.Absent
			break
		}
		v = itr.n.Schedule.v
	case 7:
		k = &fieldName__StorageTask_ScheduleLimit
		if itr.n.ScheduleLimit.m == schema.Maybe_Absent {
			v = ipld.Absent
			break
		}
		v = itr.n.ScheduleLimit.v
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_StorageTask__MapItr) Done() bool {
	return itr.idx >= 8
}

func (StorageTask) ListIterator() ipld.ListIterator {
	return nil
}
func (StorageTask) Length() int64 {
	return 8
}
func (StorageTask) IsAbsent() bool {
	return false
}
func (StorageTask) IsNull() bool {
	return false
}
func (StorageTask) AsBool() (bool, error) {
	return mixins.Map{"tasks.StorageTask"}.AsBool()
}
func (StorageTask) AsInt() (int64, error) {
	return mixins.Map{"tasks.StorageTask"}.AsInt()
}
func (StorageTask) AsFloat() (float64, error) {
	return mixins.Map{"tasks.StorageTask"}.AsFloat()
}
func (StorageTask) AsString() (string, error) {
	return mixins.Map{"tasks.StorageTask"}.AsString()
}
func (StorageTask) AsBytes() ([]byte, error) {
	return mixins.Map{"tasks.StorageTask"}.AsBytes()
}
func (StorageTask) AsLink() (ipld.Link, error) {
	return mixins.Map{"tasks.StorageTask"}.AsLink()
}
func (StorageTask) Prototype() ipld.NodePrototype {
	return _StorageTask__Prototype{}
}
type _StorageTask__Prototype struct{}

func (_StorageTask__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _StorageTask__Builder
	nb.Reset()
	return &nb
}
type _StorageTask__Builder struct {
	_StorageTask__Assembler
}
func (nb *_StorageTask__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_StorageTask__Builder) Reset() {
	var w _StorageTask
	var m schema.Maybe
	*nb = _StorageTask__Builder{_StorageTask__Assembler{w: &w, m: &m}}
}
type _StorageTask__Assembler struct {
	w *_StorageTask
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_Miner _String__Assembler
	ca_MaxPriceAttoFIL _Int__Assembler
	ca_Size _Int__Assembler
	ca_StartOffset _Int__Assembler
	ca_FastRetrieval _Bool__Assembler
	ca_Verified _Bool__Assembler
	ca_Schedule _String__Assembler
	ca_ScheduleLimit _String__Assembler
	}

func (na *_StorageTask__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Miner.reset()
	na.ca_MaxPriceAttoFIL.reset()
	na.ca_Size.reset()
	na.ca_StartOffset.reset()
	na.ca_FastRetrieval.reset()
	na.ca_Verified.reset()
	na.ca_Schedule.reset()
	na.ca_ScheduleLimit.reset()
}

var (
	fieldBit__StorageTask_Miner = 1 << 0
	fieldBit__StorageTask_MaxPriceAttoFIL = 1 << 1
	fieldBit__StorageTask_Size = 1 << 2
	fieldBit__StorageTask_StartOffset = 1 << 3
	fieldBit__StorageTask_FastRetrieval = 1 << 4
	fieldBit__StorageTask_Verified = 1 << 5
	fieldBit__StorageTask_Schedule = 1 << 6
	fieldBit__StorageTask_ScheduleLimit = 1 << 7
	fieldBits__StorageTask_sufficient = 0 + 1 << 0 + 1 << 1 + 1 << 2 + 1 << 3 + 1 << 4 + 1 << 5
)
func (na *_StorageTask__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_StorageTask{}
	}
	return na, nil
}
func (_StorageTask__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"tasks.StorageTask"}.BeginList(0)
}
func (na *_StorageTask__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"tasks.StorageTask"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_StorageTask__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"tasks.StorageTask"}.AssignBool(false)
}
func (_StorageTask__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"tasks.StorageTask"}.AssignInt(0)
}
func (_StorageTask__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"tasks.StorageTask"}.AssignFloat(0)
}
func (_StorageTask__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"tasks.StorageTask"}.AssignString("")
}
func (_StorageTask__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"tasks.StorageTask"}.AssignBytes(nil)
}
func (_StorageTask__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"tasks.StorageTask"}.AssignLink(nil)
}
func (na *_StorageTask__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_StorageTask); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "tasks.StorageTask", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_StorageTask__Assembler) Prototype() ipld.NodePrototype {
	return _StorageTask__Prototype{}
}
func (ma *_StorageTask__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Miner.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_MaxPriceAttoFIL.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Size.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_StartOffset.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_FastRetrieval.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 5:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Verified.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 6:
		switch ma.w.Schedule.m {
		case schema.Maybe_Value:
			ma.w.Schedule.v = ma.ca_Schedule.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 7:
		switch ma.w.ScheduleLimit.m {
		case schema.Maybe_Value:
			ma.w.ScheduleLimit.v = ma.ca_ScheduleLimit.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_StorageTask__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Miner":
		if ma.s & fieldBit__StorageTask_Miner != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__StorageTask_Miner}
		}
		ma.s += fieldBit__StorageTask_Miner
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Miner.w = &ma.w.Miner
		ma.ca_Miner.m = &ma.cm
		return &ma.ca_Miner, nil
	case "MaxPriceAttoFIL":
		if ma.s & fieldBit__StorageTask_MaxPriceAttoFIL != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__StorageTask_MaxPriceAttoFIL}
		}
		ma.s += fieldBit__StorageTask_MaxPriceAttoFIL
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_MaxPriceAttoFIL.w = &ma.w.MaxPriceAttoFIL
		ma.ca_MaxPriceAttoFIL.m = &ma.cm
		return &ma.ca_MaxPriceAttoFIL, nil
	case "Size":
		if ma.s & fieldBit__StorageTask_Size != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__StorageTask_Size}
		}
		ma.s += fieldBit__StorageTask_Size
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Size.w = &ma.w.Size
		ma.ca_Size.m = &ma.cm
		return &ma.ca_Size, nil
	case "StartOffset":
		if ma.s & fieldBit__StorageTask_StartOffset != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__StorageTask_StartOffset}
		}
		ma.s += fieldBit__StorageTask_StartOffset
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_StartOffset.w = &ma.w.StartOffset
		ma.ca_StartOffset.m = &ma.cm
		return &ma.ca_StartOffset, nil
	case "FastRetrieval":
		if ma.s & fieldBit__StorageTask_FastRetrieval != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__StorageTask_FastRetrieval}
		}
		ma.s += fieldBit__StorageTask_FastRetrieval
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_FastRetrieval.w = &ma.w.FastRetrieval
		ma.ca_FastRetrieval.m = &ma.cm
		return &ma.ca_FastRetrieval, nil
	case "Verified":
		if ma.s & fieldBit__StorageTask_Verified != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__StorageTask_Verified}
		}
		ma.s += fieldBit__StorageTask_Verified
		ma.state = maState_midValue
		ma.f = 5
		ma.ca_Verified.w = &ma.w.Verified
		ma.ca_Verified.m = &ma.cm
		return &ma.ca_Verified, nil
	case "Schedule":
		if ma.s & fieldBit__StorageTask_Schedule != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__StorageTask_Schedule}
		}
		ma.s += fieldBit__StorageTask_Schedule
		ma.state = maState_midValue
		ma.f = 6
		ma.ca_Schedule.w = ma.w.Schedule.v
		ma.ca_Schedule.m = &ma.w.Schedule.m
		return &ma.ca_Schedule, nil
	case "ScheduleLimit":
		if ma.s & fieldBit__StorageTask_ScheduleLimit != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__StorageTask_ScheduleLimit}
		}
		ma.s += fieldBit__StorageTask_ScheduleLimit
		ma.state = maState_midValue
		ma.f = 7
		ma.ca_ScheduleLimit.w = ma.w.ScheduleLimit.v
		ma.ca_ScheduleLimit.m = &ma.w.ScheduleLimit.m
		return &ma.ca_ScheduleLimit, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"tasks.StorageTask", Key:&_String{k}}
	}
}
func (ma *_StorageTask__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_StorageTask__KeyAssembler)(ma)
}
func (ma *_StorageTask__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Miner.w = &ma.w.Miner
		ma.ca_Miner.m = &ma.cm
		return &ma.ca_Miner
	case 1:
		ma.ca_MaxPriceAttoFIL.w = &ma.w.MaxPriceAttoFIL
		ma.ca_MaxPriceAttoFIL.m = &ma.cm
		return &ma.ca_MaxPriceAttoFIL
	case 2:
		ma.ca_Size.w = &ma.w.Size
		ma.ca_Size.m = &ma.cm
		return &ma.ca_Size
	case 3:
		ma.ca_StartOffset.w = &ma.w.StartOffset
		ma.ca_StartOffset.m = &ma.cm
		return &ma.ca_StartOffset
	case 4:
		ma.ca_FastRetrieval.w = &ma.w.FastRetrieval
		ma.ca_FastRetrieval.m = &ma.cm
		return &ma.ca_FastRetrieval
	case 5:
		ma.ca_Verified.w = &ma.w.Verified
		ma.ca_Verified.m = &ma.cm
		return &ma.ca_Verified
	case 6:
		ma.ca_Schedule.w = ma.w.Schedule.v
		ma.ca_Schedule.m = &ma.w.Schedule.m
		return &ma.ca_Schedule
	case 7:
		ma.ca_ScheduleLimit.w = ma.w.ScheduleLimit.v
		ma.ca_ScheduleLimit.m = &ma.w.ScheduleLimit.m
		return &ma.ca_ScheduleLimit
	default:
		panic("unreachable")
	}
}
func (ma *_StorageTask__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s & fieldBits__StorageTask_sufficient != fieldBits__StorageTask_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s & fieldBit__StorageTask_Miner == 0 {
			err.Missing = append(err.Missing, "Miner")
		}
		if ma.s & fieldBit__StorageTask_MaxPriceAttoFIL == 0 {
			err.Missing = append(err.Missing, "MaxPriceAttoFIL")
		}
		if ma.s & fieldBit__StorageTask_Size == 0 {
			err.Missing = append(err.Missing, "Size")
		}
		if ma.s & fieldBit__StorageTask_StartOffset == 0 {
			err.Missing = append(err.Missing, "StartOffset")
		}
		if ma.s & fieldBit__StorageTask_FastRetrieval == 0 {
			err.Missing = append(err.Missing, "FastRetrieval")
		}
		if ma.s & fieldBit__StorageTask_Verified == 0 {
			err.Missing = append(err.Missing, "Verified")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_StorageTask__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_StorageTask__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}
type _StorageTask__KeyAssembler _StorageTask__Assembler
func (_StorageTask__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"tasks.StorageTask.KeyAssembler"}.BeginMap(0)
}
func (_StorageTask__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"tasks.StorageTask.KeyAssembler"}.BeginList(0)
}
func (na *_StorageTask__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"tasks.StorageTask.KeyAssembler"}.AssignNull()
}
func (_StorageTask__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"tasks.StorageTask.KeyAssembler"}.AssignBool(false)
}
func (_StorageTask__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"tasks.StorageTask.KeyAssembler"}.AssignInt(0)
}
func (_StorageTask__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"tasks.StorageTask.KeyAssembler"}.AssignFloat(0)
}
func (ka *_StorageTask__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Miner":
		if ka.s & fieldBit__StorageTask_Miner != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__StorageTask_Miner}
		}
		ka.s += fieldBit__StorageTask_Miner
		ka.state = maState_expectValue
		ka.f = 0
	case "MaxPriceAttoFIL":
		if ka.s & fieldBit__StorageTask_MaxPriceAttoFIL != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__StorageTask_MaxPriceAttoFIL}
		}
		ka.s += fieldBit__StorageTask_MaxPriceAttoFIL
		ka.state = maState_expectValue
		ka.f = 1
	case "Size":
		if ka.s & fieldBit__StorageTask_Size != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__StorageTask_Size}
		}
		ka.s += fieldBit__StorageTask_Size
		ka.state = maState_expectValue
		ka.f = 2
	case "StartOffset":
		if ka.s & fieldBit__StorageTask_StartOffset != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__StorageTask_StartOffset}
		}
		ka.s += fieldBit__StorageTask_StartOffset
		ka.state = maState_expectValue
		ka.f = 3
	case "FastRetrieval":
		if ka.s & fieldBit__StorageTask_FastRetrieval != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__StorageTask_FastRetrieval}
		}
		ka.s += fieldBit__StorageTask_FastRetrieval
		ka.state = maState_expectValue
		ka.f = 4
	case "Verified":
		if ka.s & fieldBit__StorageTask_Verified != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__StorageTask_Verified}
		}
		ka.s += fieldBit__StorageTask_Verified
		ka.state = maState_expectValue
		ka.f = 5
	case "Schedule":
		if ka.s & fieldBit__StorageTask_Schedule != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__StorageTask_Schedule}
		}
		ka.s += fieldBit__StorageTask_Schedule
		ka.state = maState_expectValue
		ka.f = 6
	case "ScheduleLimit":
		if ka.s & fieldBit__StorageTask_ScheduleLimit != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__StorageTask_ScheduleLimit}
		}
		ka.s += fieldBit__StorageTask_ScheduleLimit
		ka.state = maState_expectValue
		ka.f = 7
	default:
		return ipld.ErrInvalidKey{TypeName:"tasks.StorageTask", Key:&_String{k}}
	}
	return nil
}
func (_StorageTask__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"tasks.StorageTask.KeyAssembler"}.AssignBytes(nil)
}
func (_StorageTask__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"tasks.StorageTask.KeyAssembler"}.AssignLink(nil)
}
func (ka *_StorageTask__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_StorageTask__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (StorageTask) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n StorageTask) Representation() ipld.Node {
	return (*_StorageTask__Repr)(n)
}
type _StorageTask__Repr _StorageTask
var (
	fieldName__StorageTask_Miner_serial = _String{"Miner"}
	fieldName__StorageTask_MaxPriceAttoFIL_serial = _String{"MaxPriceAttoFIL"}
	fieldName__StorageTask_Size_serial = _String{"Size"}
	fieldName__StorageTask_StartOffset_serial = _String{"StartOffset"}
	fieldName__StorageTask_FastRetrieval_serial = _String{"FastRetrieval"}
	fieldName__StorageTask_Verified_serial = _String{"Verified"}
	fieldName__StorageTask_Schedule_serial = _String{"Schedule"}
	fieldName__StorageTask_ScheduleLimit_serial = _String{"ScheduleLimit"}
)
var _ ipld.Node = &_StorageTask__Repr{}
func (_StorageTask__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_StorageTask__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Miner":
		return n.Miner.Representation(), nil
	case "MaxPriceAttoFIL":
		return n.MaxPriceAttoFIL.Representation(), nil
	case "Size":
		return n.Size.Representation(), nil
	case "StartOffset":
		return n.StartOffset.Representation(), nil
	case "FastRetrieval":
		return n.FastRetrieval.Representation(), nil
	case "Verified":
		return n.Verified.Representation(), nil
	case "Schedule":
		if n.Schedule.m == schema.Maybe_Absent {
			return ipld.Absent, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.Schedule.v.Representation(), nil
	case "ScheduleLimit":
		if n.ScheduleLimit.m == schema.Maybe_Absent {
			return ipld.Absent, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.ScheduleLimit.v.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_StorageTask__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_StorageTask__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"tasks.StorageTask.Repr"}.LookupByIndex(0)
}
func (n _StorageTask__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_StorageTask__Repr) MapIterator() ipld.MapIterator {
	end := 8
	if n.ScheduleLimit.m == schema.Maybe_Absent {
		end = 7
	} else {
		goto done
	}
	if n.Schedule.m == schema.Maybe_Absent {
		end = 6
	} else {
		goto done
	}
done:
	return &_StorageTask__ReprMapItr{n, 0, end}
}

type _StorageTask__ReprMapItr struct {
	n   *_StorageTask__Repr
	idx int
	end int
}

func (itr *_StorageTask__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
advance:if itr.idx >= 8 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__StorageTask_Miner_serial
		v = itr.n.Miner.Representation()
	case 1:
		k = &fieldName__StorageTask_MaxPriceAttoFIL_serial
		v = itr.n.MaxPriceAttoFIL.Representation()
	case 2:
		k = &fieldName__StorageTask_Size_serial
		v = itr.n.Size.Representation()
	case 3:
		k = &fieldName__StorageTask_StartOffset_serial
		v = itr.n.StartOffset.Representation()
	case 4:
		k = &fieldName__StorageTask_FastRetrieval_serial
		v = itr.n.FastRetrieval.Representation()
	case 5:
		k = &fieldName__StorageTask_Verified_serial
		v = itr.n.Verified.Representation()
	case 6:
		k = &fieldName__StorageTask_Schedule_serial
		if itr.n.Schedule.m == schema.Maybe_Absent {
			itr.idx++
			goto advance
		}
		v = itr.n.Schedule.v.Representation()
	case 7:
		k = &fieldName__StorageTask_ScheduleLimit_serial
		if itr.n.ScheduleLimit.m == schema.Maybe_Absent {
			itr.idx++
			goto advance
		}
		v = itr.n.ScheduleLimit.v.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_StorageTask__ReprMapItr) Done() bool {
	return itr.idx >= itr.end
}
func (_StorageTask__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_StorageTask__Repr) Length() int64 {
	l := 8
	if rn.Schedule.m == schema.Maybe_Absent {
		l--
	}
	if rn.ScheduleLimit.m == schema.Maybe_Absent {
		l--
	}
	return int64(l)
}
func (_StorageTask__Repr) IsAbsent() bool {
	return false
}
func (_StorageTask__Repr) IsNull() bool {
	return false
}
func (_StorageTask__Repr) AsBool() (bool, error) {
	return mixins.Map{"tasks.StorageTask.Repr"}.AsBool()
}
func (_StorageTask__Repr) AsInt() (int64, error) {
	return mixins.Map{"tasks.StorageTask.Repr"}.AsInt()
}
func (_StorageTask__Repr) AsFloat() (float64, error) {
	return mixins.Map{"tasks.StorageTask.Repr"}.AsFloat()
}
func (_StorageTask__Repr) AsString() (string, error) {
	return mixins.Map{"tasks.StorageTask.Repr"}.AsString()
}
func (_StorageTask__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"tasks.StorageTask.Repr"}.AsBytes()
}
func (_StorageTask__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"tasks.StorageTask.Repr"}.AsLink()
}
func (_StorageTask__Repr) Prototype() ipld.NodePrototype {
	return _StorageTask__ReprPrototype{}
}
type _StorageTask__ReprPrototype struct{}

func (_StorageTask__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _StorageTask__ReprBuilder
	nb.Reset()
	return &nb
}
type _StorageTask__ReprBuilder struct {
	_StorageTask__ReprAssembler
}
func (nb *_StorageTask__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_StorageTask__ReprBuilder) Reset() {
	var w _StorageTask
	var m schema.Maybe
	*nb = _StorageTask__ReprBuilder{_StorageTask__ReprAssembler{w: &w, m: &m}}
}
type _StorageTask__ReprAssembler struct {
	w *_StorageTask
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_Miner _String__ReprAssembler
	ca_MaxPriceAttoFIL _Int__ReprAssembler
	ca_Size _Int__ReprAssembler
	ca_StartOffset _Int__ReprAssembler
	ca_FastRetrieval _Bool__ReprAssembler
	ca_Verified _Bool__ReprAssembler
	ca_Schedule _String__ReprAssembler
	ca_ScheduleLimit _String__ReprAssembler
	}

func (na *_StorageTask__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Miner.reset()
	na.ca_MaxPriceAttoFIL.reset()
	na.ca_Size.reset()
	na.ca_StartOffset.reset()
	na.ca_FastRetrieval.reset()
	na.ca_Verified.reset()
	na.ca_Schedule.reset()
	na.ca_ScheduleLimit.reset()
}
func (na *_StorageTask__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_StorageTask{}
	}
	return na, nil
}
func (_StorageTask__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"tasks.StorageTask.Repr"}.BeginList(0)
}
func (na *_StorageTask__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"tasks.StorageTask.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_StorageTask__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"tasks.StorageTask.Repr"}.AssignBool(false)
}
func (_StorageTask__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"tasks.StorageTask.Repr"}.AssignInt(0)
}
func (_StorageTask__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"tasks.StorageTask.Repr"}.AssignFloat(0)
}
func (_StorageTask__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"tasks.StorageTask.Repr"}.AssignString("")
}
func (_StorageTask__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"tasks.StorageTask.Repr"}.AssignBytes(nil)
}
func (_StorageTask__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"tasks.StorageTask.Repr"}.AssignLink(nil)
}
func (na *_StorageTask__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_StorageTask); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "tasks.StorageTask.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_StorageTask__ReprAssembler) Prototype() ipld.NodePrototype {
	return _StorageTask__ReprPrototype{}
}
func (ma *_StorageTask__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 5:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 6:
		switch ma.w.Schedule.m {
		case schema.Maybe_Value:
			ma.w.Schedule.v = ma.ca_Schedule.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 7:
		switch ma.w.ScheduleLimit.m {
		case schema.Maybe_Value:
			ma.w.ScheduleLimit.v = ma.ca_ScheduleLimit.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_StorageTask__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Miner":
		if ma.s & fieldBit__StorageTask_Miner != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__StorageTask_Miner_serial}
		}
		ma.s += fieldBit__StorageTask_Miner
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Miner.w = &ma.w.Miner
		ma.ca_Miner.m = &ma.cm
		return &ma.ca_Miner, nil
	case "MaxPriceAttoFIL":
		if ma.s & fieldBit__StorageTask_MaxPriceAttoFIL != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__StorageTask_MaxPriceAttoFIL_serial}
		}
		ma.s += fieldBit__StorageTask_MaxPriceAttoFIL
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_MaxPriceAttoFIL.w = &ma.w.MaxPriceAttoFIL
		ma.ca_MaxPriceAttoFIL.m = &ma.cm
		return &ma.ca_MaxPriceAttoFIL, nil
	case "Size":
		if ma.s & fieldBit__StorageTask_Size != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__StorageTask_Size_serial}
		}
		ma.s += fieldBit__StorageTask_Size
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Size.w = &ma.w.Size
		ma.ca_Size.m = &ma.cm
		return &ma.ca_Size, nil
	case "StartOffset":
		if ma.s & fieldBit__StorageTask_StartOffset != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__StorageTask_StartOffset_serial}
		}
		ma.s += fieldBit__StorageTask_StartOffset
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_StartOffset.w = &ma.w.StartOffset
		ma.ca_StartOffset.m = &ma.cm
		return &ma.ca_StartOffset, nil
	case "FastRetrieval":
		if ma.s & fieldBit__StorageTask_FastRetrieval != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__StorageTask_FastRetrieval_serial}
		}
		ma.s += fieldBit__StorageTask_FastRetrieval
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_FastRetrieval.w = &ma.w.FastRetrieval
		ma.ca_FastRetrieval.m = &ma.cm
		return &ma.ca_FastRetrieval, nil
	case "Verified":
		if ma.s & fieldBit__StorageTask_Verified != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__StorageTask_Verified_serial}
		}
		ma.s += fieldBit__StorageTask_Verified
		ma.state = maState_midValue
		ma.f = 5
		ma.ca_Verified.w = &ma.w.Verified
		ma.ca_Verified.m = &ma.cm
		return &ma.ca_Verified, nil
	case "Schedule":
		if ma.s & fieldBit__StorageTask_Schedule != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__StorageTask_Schedule_serial}
		}
		ma.s += fieldBit__StorageTask_Schedule
		ma.state = maState_midValue
		ma.f = 6
		ma.ca_Schedule.w = ma.w.Schedule.v
		ma.ca_Schedule.m = &ma.w.Schedule.m
		
		return &ma.ca_Schedule, nil
	case "ScheduleLimit":
		if ma.s & fieldBit__StorageTask_ScheduleLimit != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__StorageTask_ScheduleLimit_serial}
		}
		ma.s += fieldBit__StorageTask_ScheduleLimit
		ma.state = maState_midValue
		ma.f = 7
		ma.ca_ScheduleLimit.w = ma.w.ScheduleLimit.v
		ma.ca_ScheduleLimit.m = &ma.w.ScheduleLimit.m
		
		return &ma.ca_ScheduleLimit, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"tasks.StorageTask.Repr", Key:&_String{k}}
	}
}
func (ma *_StorageTask__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_StorageTask__ReprKeyAssembler)(ma)
}
func (ma *_StorageTask__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Miner.w = &ma.w.Miner
		ma.ca_Miner.m = &ma.cm
		return &ma.ca_Miner
	case 1:
		ma.ca_MaxPriceAttoFIL.w = &ma.w.MaxPriceAttoFIL
		ma.ca_MaxPriceAttoFIL.m = &ma.cm
		return &ma.ca_MaxPriceAttoFIL
	case 2:
		ma.ca_Size.w = &ma.w.Size
		ma.ca_Size.m = &ma.cm
		return &ma.ca_Size
	case 3:
		ma.ca_StartOffset.w = &ma.w.StartOffset
		ma.ca_StartOffset.m = &ma.cm
		return &ma.ca_StartOffset
	case 4:
		ma.ca_FastRetrieval.w = &ma.w.FastRetrieval
		ma.ca_FastRetrieval.m = &ma.cm
		return &ma.ca_FastRetrieval
	case 5:
		ma.ca_Verified.w = &ma.w.Verified
		ma.ca_Verified.m = &ma.cm
		return &ma.ca_Verified
	case 6:
		ma.ca_Schedule.w = ma.w.Schedule.v
		ma.ca_Schedule.m = &ma.w.Schedule.m
		
		return &ma.ca_Schedule
	case 7:
		ma.ca_ScheduleLimit.w = ma.w.ScheduleLimit.v
		ma.ca_ScheduleLimit.m = &ma.w.ScheduleLimit.m
		
		return &ma.ca_ScheduleLimit
	default:
		panic("unreachable")
	}
}
func (ma *_StorageTask__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s & fieldBits__StorageTask_sufficient != fieldBits__StorageTask_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s & fieldBit__StorageTask_Miner == 0 {
			err.Missing = append(err.Missing, "Miner")
		}
		if ma.s & fieldBit__StorageTask_MaxPriceAttoFIL == 0 {
			err.Missing = append(err.Missing, "MaxPriceAttoFIL")
		}
		if ma.s & fieldBit__StorageTask_Size == 0 {
			err.Missing = append(err.Missing, "Size")
		}
		if ma.s & fieldBit__StorageTask_StartOffset == 0 {
			err.Missing = append(err.Missing, "StartOffset")
		}
		if ma.s & fieldBit__StorageTask_FastRetrieval == 0 {
			err.Missing = append(err.Missing, "FastRetrieval")
		}
		if ma.s & fieldBit__StorageTask_Verified == 0 {
			err.Missing = append(err.Missing, "Verified")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_StorageTask__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_StorageTask__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}
type _StorageTask__ReprKeyAssembler _StorageTask__ReprAssembler
func (_StorageTask__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"tasks.StorageTask.Repr.KeyAssembler"}.BeginMap(0)
}
func (_StorageTask__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"tasks.StorageTask.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_StorageTask__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"tasks.StorageTask.Repr.KeyAssembler"}.AssignNull()
}
func (_StorageTask__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"tasks.StorageTask.Repr.KeyAssembler"}.AssignBool(false)
}
func (_StorageTask__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"tasks.StorageTask.Repr.KeyAssembler"}.AssignInt(0)
}
func (_StorageTask__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"tasks.StorageTask.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_StorageTask__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Miner":
		if ka.s & fieldBit__StorageTask_Miner != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__StorageTask_Miner_serial}
		}
		ka.s += fieldBit__StorageTask_Miner
		ka.state = maState_expectValue
		ka.f = 0
	case "MaxPriceAttoFIL":
		if ka.s & fieldBit__StorageTask_MaxPriceAttoFIL != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__StorageTask_MaxPriceAttoFIL_serial}
		}
		ka.s += fieldBit__StorageTask_MaxPriceAttoFIL
		ka.state = maState_expectValue
		ka.f = 1
	case "Size":
		if ka.s & fieldBit__StorageTask_Size != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__StorageTask_Size_serial}
		}
		ka.s += fieldBit__StorageTask_Size
		ka.state = maState_expectValue
		ka.f = 2
	case "StartOffset":
		if ka.s & fieldBit__StorageTask_StartOffset != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__StorageTask_StartOffset_serial}
		}
		ka.s += fieldBit__StorageTask_StartOffset
		ka.state = maState_expectValue
		ka.f = 3
	case "FastRetrieval":
		if ka.s & fieldBit__StorageTask_FastRetrieval != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__StorageTask_FastRetrieval_serial}
		}
		ka.s += fieldBit__StorageTask_FastRetrieval
		ka.state = maState_expectValue
		ka.f = 4
	case "Verified":
		if ka.s & fieldBit__StorageTask_Verified != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__StorageTask_Verified_serial}
		}
		ka.s += fieldBit__StorageTask_Verified
		ka.state = maState_expectValue
		ka.f = 5
	case "Schedule":
		if ka.s & fieldBit__StorageTask_Schedule != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__StorageTask_Schedule_serial}
		}
		ka.s += fieldBit__StorageTask_Schedule
		ka.state = maState_expectValue
		ka.f = 6
	case "ScheduleLimit":
		if ka.s & fieldBit__StorageTask_ScheduleLimit != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__StorageTask_ScheduleLimit_serial}
		}
		ka.s += fieldBit__StorageTask_ScheduleLimit
		ka.state = maState_expectValue
		ka.f = 7
	default:
		return ipld.ErrInvalidKey{TypeName:"tasks.StorageTask.Repr", Key:&_String{k}}
	}
	return nil
}
func (_StorageTask__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"tasks.StorageTask.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_StorageTask__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"tasks.StorageTask.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_StorageTask__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_StorageTask__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n String) String() string {
	return n.x
}
func (_String__Prototype) fromString(w *_String, v string) error {
	*w = _String{v}
	return nil
}
func (_String__Prototype) FromString(v string) (String, error) {
	n := _String{v}
	return &n, nil
}
type _String__Maybe struct {
	m schema.Maybe
	v String
}
type MaybeString = *_String__Maybe

func (m MaybeString) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeString) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeString) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeString) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeString) Must() String {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var _ ipld.Node = (String)(&_String{})
var _ schema.TypedNode = (String)(&_String{})
func (String) Kind() ipld.Kind {
	return ipld.Kind_String
}
func (String) LookupByString(string) (ipld.Node, error) {
	return mixins.String{"tasks.String"}.LookupByString("")
}
func (String) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.String{"tasks.String"}.LookupByNode(nil)
}
func (String) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.String{"tasks.String"}.LookupByIndex(0)
}
func (String) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.String{"tasks.String"}.LookupBySegment(seg)
}
func (String) MapIterator() ipld.MapIterator {
	return nil
}
func (String) ListIterator() ipld.ListIterator {
	return nil
}
func (String) Length() int64 {
	return -1
}
func (String) IsAbsent() bool {
	return false
}
func (String) IsNull() bool {
	return false
}
func (String) AsBool() (bool, error) {
	return mixins.String{"tasks.String"}.AsBool()
}
func (String) AsInt() (int64, error) {
	return mixins.String{"tasks.String"}.AsInt()
}
func (String) AsFloat() (float64, error) {
	return mixins.String{"tasks.String"}.AsFloat()
}
func (n String) AsString() (string, error) {
	return n.x, nil
}
func (String) AsBytes() ([]byte, error) {
	return mixins.String{"tasks.String"}.AsBytes()
}
func (String) AsLink() (ipld.Link, error) {
	return mixins.String{"tasks.String"}.AsLink()
}
func (String) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
type _String__Prototype struct{}

func (_String__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _String__Builder
	nb.Reset()
	return &nb
}
type _String__Builder struct {
	_String__Assembler
}
func (nb *_String__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_String__Builder) Reset() {
	var w _String
	var m schema.Maybe
	*nb = _String__Builder{_String__Assembler{w: &w, m: &m}}
}
type _String__Assembler struct {
	w *_String
	m *schema.Maybe
}

func (na *_String__Assembler) reset() {}
func (_String__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"tasks.String"}.BeginMap(0)
}
func (_String__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"tasks.String"}.BeginList(0)
}
func (na *_String__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.StringAssembler{"tasks.String"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_String__Assembler) AssignBool(bool) error {
	return mixins.StringAssembler{"tasks.String"}.AssignBool(false)
}
func (_String__Assembler) AssignInt(int64) error {
	return mixins.StringAssembler{"tasks.String"}.AssignInt(0)
}
func (_String__Assembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"tasks.String"}.AssignFloat(0)
}
func (na *_String__Assembler) AssignString(v string) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_String{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_String__Assembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"tasks.String"}.AssignBytes(nil)
}
func (_String__Assembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"tasks.String"}.AssignLink(nil)
}
func (na *_String__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_String); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return na.AssignString(v2)
	}
}
func (_String__Assembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (String) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n String) Representation() ipld.Node {
	return (*_String__Repr)(n)
}
type _String__Repr = _String
var _ ipld.Node = &_String__Repr{}
type _String__ReprPrototype = _String__Prototype
type _String__ReprAssembler = _String__Assembler


func (n _Task) FieldUUID() String {
	return &n.UUID
}
func (n _Task) FieldStatus() Status {
	return &n.Status
}
func (n _Task) FieldWorkedBy() MaybeString {
	return &n.WorkedBy
}
func (n _Task) FieldStage() String {
	return &n.Stage
}
func (n _Task) FieldCurrentStageDetails() MaybeStageDetails {
	return &n.CurrentStageDetails
}
func (n _Task) FieldPastStageDetails() MaybeList_StageDetails {
	return &n.PastStageDetails
}
func (n _Task) FieldStartedAt() MaybeTime {
	return &n.StartedAt
}
func (n _Task) FieldRunCount() Int {
	return &n.RunCount
}
func (n _Task) FieldErrorMessage() MaybeString {
	return &n.ErrorMessage
}
func (n _Task) FieldRetrievalTask() MaybeRetrievalTask {
	return &n.RetrievalTask
}
func (n _Task) FieldStorageTask() MaybeStorageTask {
	return &n.StorageTask
}
type _Task__Maybe struct {
	m schema.Maybe
	v Task
}
type MaybeTask = *_Task__Maybe

func (m MaybeTask) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeTask) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeTask) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeTask) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeTask) Must() Task {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
	fieldName__Task_UUID = _String{"UUID"}
	fieldName__Task_Status = _String{"Status"}
	fieldName__Task_WorkedBy = _String{"WorkedBy"}
	fieldName__Task_Stage = _String{"Stage"}
	fieldName__Task_CurrentStageDetails = _String{"CurrentStageDetails"}
	fieldName__Task_PastStageDetails = _String{"PastStageDetails"}
	fieldName__Task_StartedAt = _String{"StartedAt"}
	fieldName__Task_RunCount = _String{"RunCount"}
	fieldName__Task_ErrorMessage = _String{"ErrorMessage"}
	fieldName__Task_RetrievalTask = _String{"RetrievalTask"}
	fieldName__Task_StorageTask = _String{"StorageTask"}
)
var _ ipld.Node = (Task)(&_Task{})
var _ schema.TypedNode = (Task)(&_Task{})
func (Task) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n Task) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "UUID":
		return &n.UUID, nil
	case "Status":
		return &n.Status, nil
	case "WorkedBy":
		if n.WorkedBy.m == schema.Maybe_Absent {
			return ipld.Absent, nil
		}
		return n.WorkedBy.v, nil
	case "Stage":
		return &n.Stage, nil
	case "CurrentStageDetails":
		if n.CurrentStageDetails.m == schema.Maybe_Absent {
			return ipld.Absent, nil
		}
		return n.CurrentStageDetails.v, nil
	case "PastStageDetails":
		if n.PastStageDetails.m == schema.Maybe_Absent {
			return ipld.Absent, nil
		}
		return n.PastStageDetails.v, nil
	case "StartedAt":
		if n.StartedAt.m == schema.Maybe_Absent {
			return ipld.Absent, nil
		}
		return n.StartedAt.v, nil
	case "RunCount":
		return &n.RunCount, nil
	case "ErrorMessage":
		if n.ErrorMessage.m == schema.Maybe_Absent {
			return ipld.Absent, nil
		}
		return n.ErrorMessage.v, nil
	case "RetrievalTask":
		if n.RetrievalTask.m == schema.Maybe_Absent {
			return ipld.Absent, nil
		}
		return n.RetrievalTask.v, nil
	case "StorageTask":
		if n.StorageTask.m == schema.Maybe_Absent {
			return ipld.Absent, nil
		}
		return n.StorageTask.v, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n Task) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (Task) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"tasks.Task"}.LookupByIndex(0)
}
func (n Task) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n Task) MapIterator() ipld.MapIterator {
	return &_Task__MapItr{n, 0}
}

type _Task__MapItr struct {
	n Task
	idx  int
}

func (itr *_Task__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 11 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Task_UUID
		v = &itr.n.UUID
	case 1:
		k = &fieldName__Task_Status
		v = &itr.n.Status
	case 2:
		k = &fieldName__Task_WorkedBy
		if itr.n.WorkedBy.m == schema.Maybe_Absent {
			v = ipld.Absent
			break
		}
		v = itr.n.WorkedBy.v
	case 3:
		k = &fieldName__Task_Stage
		v = &itr.n.Stage
	case 4:
		k = &fieldName__Task_CurrentStageDetails
		if itr.n.CurrentStageDetails.m == schema.Maybe_Absent {
			v = ipld.Absent
			break
		}
		v = itr.n.CurrentStageDetails.v
	case 5:
		k = &fieldName__Task_PastStageDetails
		if itr.n.PastStageDetails.m == schema.Maybe_Absent {
			v = ipld.Absent
			break
		}
		v = itr.n.PastStageDetails.v
	case 6:
		k = &fieldName__Task_StartedAt
		if itr.n.StartedAt.m == schema.Maybe_Absent {
			v = ipld.Absent
			break
		}
		v = itr.n.StartedAt.v
	case 7:
		k = &fieldName__Task_RunCount
		v = &itr.n.RunCount
	case 8:
		k = &fieldName__Task_ErrorMessage
		if itr.n.ErrorMessage.m == schema.Maybe_Absent {
			v = ipld.Absent
			break
		}
		v = itr.n.ErrorMessage.v
	case 9:
		k = &fieldName__Task_RetrievalTask
		if itr.n.RetrievalTask.m == schema.Maybe_Absent {
			v = ipld.Absent
			break
		}
		v = itr.n.RetrievalTask.v
	case 10:
		k = &fieldName__Task_StorageTask
		if itr.n.StorageTask.m == schema.Maybe_Absent {
			v = ipld.Absent
			break
		}
		v = itr.n.StorageTask.v
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Task__MapItr) Done() bool {
	return itr.idx >= 11
}

func (Task) ListIterator() ipld.ListIterator {
	return nil
}
func (Task) Length() int64 {
	return 11
}
func (Task) IsAbsent() bool {
	return false
}
func (Task) IsNull() bool {
	return false
}
func (Task) AsBool() (bool, error) {
	return mixins.Map{"tasks.Task"}.AsBool()
}
func (Task) AsInt() (int64, error) {
	return mixins.Map{"tasks.Task"}.AsInt()
}
func (Task) AsFloat() (float64, error) {
	return mixins.Map{"tasks.Task"}.AsFloat()
}
func (Task) AsString() (string, error) {
	return mixins.Map{"tasks.Task"}.AsString()
}
func (Task) AsBytes() ([]byte, error) {
	return mixins.Map{"tasks.Task"}.AsBytes()
}
func (Task) AsLink() (ipld.Link, error) {
	return mixins.Map{"tasks.Task"}.AsLink()
}
func (Task) Prototype() ipld.NodePrototype {
	return _Task__Prototype{}
}
type _Task__Prototype struct{}

func (_Task__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Task__Builder
	nb.Reset()
	return &nb
}
type _Task__Builder struct {
	_Task__Assembler
}
func (nb *_Task__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Task__Builder) Reset() {
	var w _Task
	var m schema.Maybe
	*nb = _Task__Builder{_Task__Assembler{w: &w, m: &m}}
}
type _Task__Assembler struct {
	w *_Task
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_UUID _String__Assembler
	ca_Status _Status__Assembler
	ca_WorkedBy _String__Assembler
	ca_Stage _String__Assembler
	ca_CurrentStageDetails _StageDetails__Assembler
	ca_PastStageDetails _List_StageDetails__Assembler
	ca_StartedAt _Time__Assembler
	ca_RunCount _Int__Assembler
	ca_ErrorMessage _String__Assembler
	ca_RetrievalTask _RetrievalTask__Assembler
	ca_StorageTask _StorageTask__Assembler
	}

func (na *_Task__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_UUID.reset()
	na.ca_Status.reset()
	na.ca_WorkedBy.reset()
	na.ca_Stage.reset()
	na.ca_CurrentStageDetails.reset()
	na.ca_PastStageDetails.reset()
	na.ca_StartedAt.reset()
	na.ca_RunCount.reset()
	na.ca_ErrorMessage.reset()
	na.ca_RetrievalTask.reset()
	na.ca_StorageTask.reset()
}

var (
	fieldBit__Task_UUID = 1 << 0
	fieldBit__Task_Status = 1 << 1
	fieldBit__Task_WorkedBy = 1 << 2
	fieldBit__Task_Stage = 1 << 3
	fieldBit__Task_CurrentStageDetails = 1 << 4
	fieldBit__Task_PastStageDetails = 1 << 5
	fieldBit__Task_StartedAt = 1 << 6
	fieldBit__Task_RunCount = 1 << 7
	fieldBit__Task_ErrorMessage = 1 << 8
	fieldBit__Task_RetrievalTask = 1 << 9
	fieldBit__Task_StorageTask = 1 << 10
	fieldBits__Task_sufficient = 0 + 1 << 0 + 1 << 1 + 1 << 3 + 1 << 7
)
func (na *_Task__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Task{}
	}
	return na, nil
}
func (_Task__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"tasks.Task"}.BeginList(0)
}
func (na *_Task__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"tasks.Task"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Task__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"tasks.Task"}.AssignBool(false)
}
func (_Task__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"tasks.Task"}.AssignInt(0)
}
func (_Task__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"tasks.Task"}.AssignFloat(0)
}
func (_Task__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"tasks.Task"}.AssignString("")
}
func (_Task__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"tasks.Task"}.AssignBytes(nil)
}
func (_Task__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"tasks.Task"}.AssignLink(nil)
}
func (na *_Task__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Task); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "tasks.Task", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Task__Assembler) Prototype() ipld.NodePrototype {
	return _Task__Prototype{}
}
func (ma *_Task__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_UUID.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Status.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.w.WorkedBy.m {
		case schema.Maybe_Value:
			ma.w.WorkedBy.v = ma.ca_WorkedBy.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Stage.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.w.CurrentStageDetails.m {
		case schema.Maybe_Value:
			ma.w.CurrentStageDetails.v = ma.ca_CurrentStageDetails.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 5:
		switch ma.w.PastStageDetails.m {
		case schema.Maybe_Value:
			ma.w.PastStageDetails.v = ma.ca_PastStageDetails.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 6:
		switch ma.w.StartedAt.m {
		case schema.Maybe_Value:
			ma.w.StartedAt.v = ma.ca_StartedAt.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 7:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_RunCount.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 8:
		switch ma.w.ErrorMessage.m {
		case schema.Maybe_Value:
			ma.w.ErrorMessage.v = ma.ca_ErrorMessage.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 9:
		switch ma.w.RetrievalTask.m {
		case schema.Maybe_Value:
			ma.w.RetrievalTask.v = ma.ca_RetrievalTask.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 10:
		switch ma.w.StorageTask.m {
		case schema.Maybe_Value:
			ma.w.StorageTask.v = ma.ca_StorageTask.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Task__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "UUID":
		if ma.s & fieldBit__Task_UUID != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__Task_UUID}
		}
		ma.s += fieldBit__Task_UUID
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_UUID.w = &ma.w.UUID
		ma.ca_UUID.m = &ma.cm
		return &ma.ca_UUID, nil
	case "Status":
		if ma.s & fieldBit__Task_Status != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__Task_Status}
		}
		ma.s += fieldBit__Task_Status
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Status.w = &ma.w.Status
		ma.ca_Status.m = &ma.cm
		return &ma.ca_Status, nil
	case "WorkedBy":
		if ma.s & fieldBit__Task_WorkedBy != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__Task_WorkedBy}
		}
		ma.s += fieldBit__Task_WorkedBy
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_WorkedBy.w = ma.w.WorkedBy.v
		ma.ca_WorkedBy.m = &ma.w.WorkedBy.m
		return &ma.ca_WorkedBy, nil
	case "Stage":
		if ma.s & fieldBit__Task_Stage != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__Task_Stage}
		}
		ma.s += fieldBit__Task_Stage
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_Stage.w = &ma.w.Stage
		ma.ca_Stage.m = &ma.cm
		return &ma.ca_Stage, nil
	case "CurrentStageDetails":
		if ma.s & fieldBit__Task_CurrentStageDetails != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__Task_CurrentStageDetails}
		}
		ma.s += fieldBit__Task_CurrentStageDetails
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_CurrentStageDetails.w = ma.w.CurrentStageDetails.v
		ma.ca_CurrentStageDetails.m = &ma.w.CurrentStageDetails.m
		return &ma.ca_CurrentStageDetails, nil
	case "PastStageDetails":
		if ma.s & fieldBit__Task_PastStageDetails != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__Task_PastStageDetails}
		}
		ma.s += fieldBit__Task_PastStageDetails
		ma.state = maState_midValue
		ma.f = 5
		ma.ca_PastStageDetails.w = ma.w.PastStageDetails.v
		ma.ca_PastStageDetails.m = &ma.w.PastStageDetails.m
		return &ma.ca_PastStageDetails, nil
	case "StartedAt":
		if ma.s & fieldBit__Task_StartedAt != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__Task_StartedAt}
		}
		ma.s += fieldBit__Task_StartedAt
		ma.state = maState_midValue
		ma.f = 6
		ma.ca_StartedAt.w = ma.w.StartedAt.v
		ma.ca_StartedAt.m = &ma.w.StartedAt.m
		return &ma.ca_StartedAt, nil
	case "RunCount":
		if ma.s & fieldBit__Task_RunCount != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__Task_RunCount}
		}
		ma.s += fieldBit__Task_RunCount
		ma.state = maState_midValue
		ma.f = 7
		ma.ca_RunCount.w = &ma.w.RunCount
		ma.ca_RunCount.m = &ma.cm
		return &ma.ca_RunCount, nil
	case "ErrorMessage":
		if ma.s & fieldBit__Task_ErrorMessage != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__Task_ErrorMessage}
		}
		ma.s += fieldBit__Task_ErrorMessage
		ma.state = maState_midValue
		ma.f = 8
		ma.ca_ErrorMessage.w = ma.w.ErrorMessage.v
		ma.ca_ErrorMessage.m = &ma.w.ErrorMessage.m
		return &ma.ca_ErrorMessage, nil
	case "RetrievalTask":
		if ma.s & fieldBit__Task_RetrievalTask != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__Task_RetrievalTask}
		}
		ma.s += fieldBit__Task_RetrievalTask
		ma.state = maState_midValue
		ma.f = 9
		ma.ca_RetrievalTask.w = ma.w.RetrievalTask.v
		ma.ca_RetrievalTask.m = &ma.w.RetrievalTask.m
		return &ma.ca_RetrievalTask, nil
	case "StorageTask":
		if ma.s & fieldBit__Task_StorageTask != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__Task_StorageTask}
		}
		ma.s += fieldBit__Task_StorageTask
		ma.state = maState_midValue
		ma.f = 10
		ma.ca_StorageTask.w = ma.w.StorageTask.v
		ma.ca_StorageTask.m = &ma.w.StorageTask.m
		return &ma.ca_StorageTask, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"tasks.Task", Key:&_String{k}}
	}
}
func (ma *_Task__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Task__KeyAssembler)(ma)
}
func (ma *_Task__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_UUID.w = &ma.w.UUID
		ma.ca_UUID.m = &ma.cm
		return &ma.ca_UUID
	case 1:
		ma.ca_Status.w = &ma.w.Status
		ma.ca_Status.m = &ma.cm
		return &ma.ca_Status
	case 2:
		ma.ca_WorkedBy.w = ma.w.WorkedBy.v
		ma.ca_WorkedBy.m = &ma.w.WorkedBy.m
		return &ma.ca_WorkedBy
	case 3:
		ma.ca_Stage.w = &ma.w.Stage
		ma.ca_Stage.m = &ma.cm
		return &ma.ca_Stage
	case 4:
		ma.ca_CurrentStageDetails.w = ma.w.CurrentStageDetails.v
		ma.ca_CurrentStageDetails.m = &ma.w.CurrentStageDetails.m
		return &ma.ca_CurrentStageDetails
	case 5:
		ma.ca_PastStageDetails.w = ma.w.PastStageDetails.v
		ma.ca_PastStageDetails.m = &ma.w.PastStageDetails.m
		return &ma.ca_PastStageDetails
	case 6:
		ma.ca_StartedAt.w = ma.w.StartedAt.v
		ma.ca_StartedAt.m = &ma.w.StartedAt.m
		return &ma.ca_StartedAt
	case 7:
		ma.ca_RunCount.w = &ma.w.RunCount
		ma.ca_RunCount.m = &ma.cm
		return &ma.ca_RunCount
	case 8:
		ma.ca_ErrorMessage.w = ma.w.ErrorMessage.v
		ma.ca_ErrorMessage.m = &ma.w.ErrorMessage.m
		return &ma.ca_ErrorMessage
	case 9:
		ma.ca_RetrievalTask.w = ma.w.RetrievalTask.v
		ma.ca_RetrievalTask.m = &ma.w.RetrievalTask.m
		return &ma.ca_RetrievalTask
	case 10:
		ma.ca_StorageTask.w = ma.w.StorageTask.v
		ma.ca_StorageTask.m = &ma.w.StorageTask.m
		return &ma.ca_StorageTask
	default:
		panic("unreachable")
	}
}
func (ma *_Task__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s & fieldBits__Task_sufficient != fieldBits__Task_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s & fieldBit__Task_UUID == 0 {
			err.Missing = append(err.Missing, "UUID")
		}
		if ma.s & fieldBit__Task_Status == 0 {
			err.Missing = append(err.Missing, "Status")
		}
		if ma.s & fieldBit__Task_Stage == 0 {
			err.Missing = append(err.Missing, "Stage")
		}
		if ma.s & fieldBit__Task_RunCount == 0 {
			err.Missing = append(err.Missing, "RunCount")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Task__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Task__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}
type _Task__KeyAssembler _Task__Assembler
func (_Task__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"tasks.Task.KeyAssembler"}.BeginMap(0)
}
func (_Task__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"tasks.Task.KeyAssembler"}.BeginList(0)
}
func (na *_Task__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"tasks.Task.KeyAssembler"}.AssignNull()
}
func (_Task__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"tasks.Task.KeyAssembler"}.AssignBool(false)
}
func (_Task__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"tasks.Task.KeyAssembler"}.AssignInt(0)
}
func (_Task__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"tasks.Task.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Task__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "UUID":
		if ka.s & fieldBit__Task_UUID != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__Task_UUID}
		}
		ka.s += fieldBit__Task_UUID
		ka.state = maState_expectValue
		ka.f = 0
	case "Status":
		if ka.s & fieldBit__Task_Status != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__Task_Status}
		}
		ka.s += fieldBit__Task_Status
		ka.state = maState_expectValue
		ka.f = 1
	case "WorkedBy":
		if ka.s & fieldBit__Task_WorkedBy != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__Task_WorkedBy}
		}
		ka.s += fieldBit__Task_WorkedBy
		ka.state = maState_expectValue
		ka.f = 2
	case "Stage":
		if ka.s & fieldBit__Task_Stage != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__Task_Stage}
		}
		ka.s += fieldBit__Task_Stage
		ka.state = maState_expectValue
		ka.f = 3
	case "CurrentStageDetails":
		if ka.s & fieldBit__Task_CurrentStageDetails != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__Task_CurrentStageDetails}
		}
		ka.s += fieldBit__Task_CurrentStageDetails
		ka.state = maState_expectValue
		ka.f = 4
	case "PastStageDetails":
		if ka.s & fieldBit__Task_PastStageDetails != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__Task_PastStageDetails}
		}
		ka.s += fieldBit__Task_PastStageDetails
		ka.state = maState_expectValue
		ka.f = 5
	case "StartedAt":
		if ka.s & fieldBit__Task_StartedAt != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__Task_StartedAt}
		}
		ka.s += fieldBit__Task_StartedAt
		ka.state = maState_expectValue
		ka.f = 6
	case "RunCount":
		if ka.s & fieldBit__Task_RunCount != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__Task_RunCount}
		}
		ka.s += fieldBit__Task_RunCount
		ka.state = maState_expectValue
		ka.f = 7
	case "ErrorMessage":
		if ka.s & fieldBit__Task_ErrorMessage != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__Task_ErrorMessage}
		}
		ka.s += fieldBit__Task_ErrorMessage
		ka.state = maState_expectValue
		ka.f = 8
	case "RetrievalTask":
		if ka.s & fieldBit__Task_RetrievalTask != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__Task_RetrievalTask}
		}
		ka.s += fieldBit__Task_RetrievalTask
		ka.state = maState_expectValue
		ka.f = 9
	case "StorageTask":
		if ka.s & fieldBit__Task_StorageTask != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__Task_StorageTask}
		}
		ka.s += fieldBit__Task_StorageTask
		ka.state = maState_expectValue
		ka.f = 10
	default:
		return ipld.ErrInvalidKey{TypeName:"tasks.Task", Key:&_String{k}}
	}
	return nil
}
func (_Task__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"tasks.Task.KeyAssembler"}.AssignBytes(nil)
}
func (_Task__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"tasks.Task.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Task__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Task__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (Task) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Task) Representation() ipld.Node {
	return (*_Task__Repr)(n)
}
type _Task__Repr _Task
var (
	fieldName__Task_UUID_serial = _String{"UUID"}
	fieldName__Task_Status_serial = _String{"Status"}
	fieldName__Task_WorkedBy_serial = _String{"WorkedBy"}
	fieldName__Task_Stage_serial = _String{"Stage"}
	fieldName__Task_CurrentStageDetails_serial = _String{"CurrentStageDetails"}
	fieldName__Task_PastStageDetails_serial = _String{"PastStageDetails"}
	fieldName__Task_StartedAt_serial = _String{"StartedAt"}
	fieldName__Task_RunCount_serial = _String{"RunCount"}
	fieldName__Task_ErrorMessage_serial = _String{"ErrorMessage"}
	fieldName__Task_RetrievalTask_serial = _String{"RetrievalTask"}
	fieldName__Task_StorageTask_serial = _String{"StorageTask"}
)
var _ ipld.Node = &_Task__Repr{}
func (_Task__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_Task__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "UUID":
		return n.UUID.Representation(), nil
	case "Status":
		return n.Status.Representation(), nil
	case "WorkedBy":
		if n.WorkedBy.m == schema.Maybe_Absent {
			return ipld.Absent, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.WorkedBy.v.Representation(), nil
	case "Stage":
		return n.Stage.Representation(), nil
	case "CurrentStageDetails":
		if n.CurrentStageDetails.m == schema.Maybe_Absent {
			return ipld.Absent, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.CurrentStageDetails.v.Representation(), nil
	case "PastStageDetails":
		if n.PastStageDetails.m == schema.Maybe_Absent {
			return ipld.Absent, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.PastStageDetails.v.Representation(), nil
	case "StartedAt":
		if n.StartedAt.m == schema.Maybe_Absent {
			return ipld.Absent, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.StartedAt.v.Representation(), nil
	case "RunCount":
		return n.RunCount.Representation(), nil
	case "ErrorMessage":
		if n.ErrorMessage.m == schema.Maybe_Absent {
			return ipld.Absent, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.ErrorMessage.v.Representation(), nil
	case "RetrievalTask":
		if n.RetrievalTask.m == schema.Maybe_Absent {
			return ipld.Absent, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.RetrievalTask.v.Representation(), nil
	case "StorageTask":
		if n.StorageTask.m == schema.Maybe_Absent {
			return ipld.Absent, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.StorageTask.v.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_Task__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_Task__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"tasks.Task.Repr"}.LookupByIndex(0)
}
func (n _Task__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_Task__Repr) MapIterator() ipld.MapIterator {
	end := 11
	if n.StorageTask.m == schema.Maybe_Absent {
		end = 10
	} else {
		goto done
	}
	if n.RetrievalTask.m == schema.Maybe_Absent {
		end = 9
	} else {
		goto done
	}
	if n.ErrorMessage.m == schema.Maybe_Absent {
		end = 8
	} else {
		goto done
	}
done:
	return &_Task__ReprMapItr{n, 0, end}
}

type _Task__ReprMapItr struct {
	n   *_Task__Repr
	idx int
	end int
}

func (itr *_Task__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
advance:if itr.idx >= 11 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__Task_UUID_serial
		v = itr.n.UUID.Representation()
	case 1:
		k = &fieldName__Task_Status_serial
		v = itr.n.Status.Representation()
	case 2:
		k = &fieldName__Task_WorkedBy_serial
		if itr.n.WorkedBy.m == schema.Maybe_Absent {
			itr.idx++
			goto advance
		}
		v = itr.n.WorkedBy.v.Representation()
	case 3:
		k = &fieldName__Task_Stage_serial
		v = itr.n.Stage.Representation()
	case 4:
		k = &fieldName__Task_CurrentStageDetails_serial
		if itr.n.CurrentStageDetails.m == schema.Maybe_Absent {
			itr.idx++
			goto advance
		}
		v = itr.n.CurrentStageDetails.v.Representation()
	case 5:
		k = &fieldName__Task_PastStageDetails_serial
		if itr.n.PastStageDetails.m == schema.Maybe_Absent {
			itr.idx++
			goto advance
		}
		v = itr.n.PastStageDetails.v.Representation()
	case 6:
		k = &fieldName__Task_StartedAt_serial
		if itr.n.StartedAt.m == schema.Maybe_Absent {
			itr.idx++
			goto advance
		}
		v = itr.n.StartedAt.v.Representation()
	case 7:
		k = &fieldName__Task_RunCount_serial
		v = itr.n.RunCount.Representation()
	case 8:
		k = &fieldName__Task_ErrorMessage_serial
		if itr.n.ErrorMessage.m == schema.Maybe_Absent {
			itr.idx++
			goto advance
		}
		v = itr.n.ErrorMessage.v.Representation()
	case 9:
		k = &fieldName__Task_RetrievalTask_serial
		if itr.n.RetrievalTask.m == schema.Maybe_Absent {
			itr.idx++
			goto advance
		}
		v = itr.n.RetrievalTask.v.Representation()
	case 10:
		k = &fieldName__Task_StorageTask_serial
		if itr.n.StorageTask.m == schema.Maybe_Absent {
			itr.idx++
			goto advance
		}
		v = itr.n.StorageTask.v.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_Task__ReprMapItr) Done() bool {
	return itr.idx >= itr.end
}
func (_Task__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_Task__Repr) Length() int64 {
	l := 11
	if rn.WorkedBy.m == schema.Maybe_Absent {
		l--
	}
	if rn.CurrentStageDetails.m == schema.Maybe_Absent {
		l--
	}
	if rn.PastStageDetails.m == schema.Maybe_Absent {
		l--
	}
	if rn.StartedAt.m == schema.Maybe_Absent {
		l--
	}
	if rn.ErrorMessage.m == schema.Maybe_Absent {
		l--
	}
	if rn.RetrievalTask.m == schema.Maybe_Absent {
		l--
	}
	if rn.StorageTask.m == schema.Maybe_Absent {
		l--
	}
	return int64(l)
}
func (_Task__Repr) IsAbsent() bool {
	return false
}
func (_Task__Repr) IsNull() bool {
	return false
}
func (_Task__Repr) AsBool() (bool, error) {
	return mixins.Map{"tasks.Task.Repr"}.AsBool()
}
func (_Task__Repr) AsInt() (int64, error) {
	return mixins.Map{"tasks.Task.Repr"}.AsInt()
}
func (_Task__Repr) AsFloat() (float64, error) {
	return mixins.Map{"tasks.Task.Repr"}.AsFloat()
}
func (_Task__Repr) AsString() (string, error) {
	return mixins.Map{"tasks.Task.Repr"}.AsString()
}
func (_Task__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"tasks.Task.Repr"}.AsBytes()
}
func (_Task__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"tasks.Task.Repr"}.AsLink()
}
func (_Task__Repr) Prototype() ipld.NodePrototype {
	return _Task__ReprPrototype{}
}
type _Task__ReprPrototype struct{}

func (_Task__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Task__ReprBuilder
	nb.Reset()
	return &nb
}
type _Task__ReprBuilder struct {
	_Task__ReprAssembler
}
func (nb *_Task__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Task__ReprBuilder) Reset() {
	var w _Task
	var m schema.Maybe
	*nb = _Task__ReprBuilder{_Task__ReprAssembler{w: &w, m: &m}}
}
type _Task__ReprAssembler struct {
	w *_Task
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_UUID _String__ReprAssembler
	ca_Status _Status__ReprAssembler
	ca_WorkedBy _String__ReprAssembler
	ca_Stage _String__ReprAssembler
	ca_CurrentStageDetails _StageDetails__ReprAssembler
	ca_PastStageDetails _List_StageDetails__ReprAssembler
	ca_StartedAt _Time__ReprAssembler
	ca_RunCount _Int__ReprAssembler
	ca_ErrorMessage _String__ReprAssembler
	ca_RetrievalTask _RetrievalTask__ReprAssembler
	ca_StorageTask _StorageTask__ReprAssembler
	}

func (na *_Task__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_UUID.reset()
	na.ca_Status.reset()
	na.ca_WorkedBy.reset()
	na.ca_Stage.reset()
	na.ca_CurrentStageDetails.reset()
	na.ca_PastStageDetails.reset()
	na.ca_StartedAt.reset()
	na.ca_RunCount.reset()
	na.ca_ErrorMessage.reset()
	na.ca_RetrievalTask.reset()
	na.ca_StorageTask.reset()
}
func (na *_Task__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_Task{}
	}
	return na, nil
}
func (_Task__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"tasks.Task.Repr"}.BeginList(0)
}
func (na *_Task__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"tasks.Task.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Task__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"tasks.Task.Repr"}.AssignBool(false)
}
func (_Task__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"tasks.Task.Repr"}.AssignInt(0)
}
func (_Task__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"tasks.Task.Repr"}.AssignFloat(0)
}
func (_Task__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"tasks.Task.Repr"}.AssignString("")
}
func (_Task__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"tasks.Task.Repr"}.AssignBytes(nil)
}
func (_Task__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"tasks.Task.Repr"}.AssignLink(nil)
}
func (na *_Task__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Task); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "tasks.Task.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Task__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Task__ReprPrototype{}
}
func (ma *_Task__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.w.WorkedBy.m {
		case schema.Maybe_Value:
			ma.w.WorkedBy.v = ma.ca_WorkedBy.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.w.CurrentStageDetails.m {
		case schema.Maybe_Value:
			ma.w.CurrentStageDetails.v = ma.ca_CurrentStageDetails.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 5:
		switch ma.w.PastStageDetails.m {
		case schema.Maybe_Value:
			ma.w.PastStageDetails.v = ma.ca_PastStageDetails.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 6:
		switch ma.w.StartedAt.m {
		case schema.Maybe_Value:
			ma.w.StartedAt.v = ma.ca_StartedAt.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 7:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 8:
		switch ma.w.ErrorMessage.m {
		case schema.Maybe_Value:
			ma.w.ErrorMessage.v = ma.ca_ErrorMessage.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 9:
		switch ma.w.RetrievalTask.m {
		case schema.Maybe_Value:
			ma.w.RetrievalTask.v = ma.ca_RetrievalTask.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 10:
		switch ma.w.StorageTask.m {
		case schema.Maybe_Value:
			ma.w.StorageTask.v = ma.ca_StorageTask.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_Task__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "UUID":
		if ma.s & fieldBit__Task_UUID != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__Task_UUID_serial}
		}
		ma.s += fieldBit__Task_UUID
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_UUID.w = &ma.w.UUID
		ma.ca_UUID.m = &ma.cm
		return &ma.ca_UUID, nil
	case "Status":
		if ma.s & fieldBit__Task_Status != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__Task_Status_serial}
		}
		ma.s += fieldBit__Task_Status
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_Status.w = &ma.w.Status
		ma.ca_Status.m = &ma.cm
		return &ma.ca_Status, nil
	case "WorkedBy":
		if ma.s & fieldBit__Task_WorkedBy != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__Task_WorkedBy_serial}
		}
		ma.s += fieldBit__Task_WorkedBy
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_WorkedBy.w = ma.w.WorkedBy.v
		ma.ca_WorkedBy.m = &ma.w.WorkedBy.m
		
		return &ma.ca_WorkedBy, nil
	case "Stage":
		if ma.s & fieldBit__Task_Stage != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__Task_Stage_serial}
		}
		ma.s += fieldBit__Task_Stage
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_Stage.w = &ma.w.Stage
		ma.ca_Stage.m = &ma.cm
		return &ma.ca_Stage, nil
	case "CurrentStageDetails":
		if ma.s & fieldBit__Task_CurrentStageDetails != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__Task_CurrentStageDetails_serial}
		}
		ma.s += fieldBit__Task_CurrentStageDetails
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_CurrentStageDetails.w = ma.w.CurrentStageDetails.v
		ma.ca_CurrentStageDetails.m = &ma.w.CurrentStageDetails.m
		
		return &ma.ca_CurrentStageDetails, nil
	case "PastStageDetails":
		if ma.s & fieldBit__Task_PastStageDetails != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__Task_PastStageDetails_serial}
		}
		ma.s += fieldBit__Task_PastStageDetails
		ma.state = maState_midValue
		ma.f = 5
		ma.ca_PastStageDetails.w = ma.w.PastStageDetails.v
		ma.ca_PastStageDetails.m = &ma.w.PastStageDetails.m
		
		return &ma.ca_PastStageDetails, nil
	case "StartedAt":
		if ma.s & fieldBit__Task_StartedAt != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__Task_StartedAt_serial}
		}
		ma.s += fieldBit__Task_StartedAt
		ma.state = maState_midValue
		ma.f = 6
		ma.ca_StartedAt.w = ma.w.StartedAt.v
		ma.ca_StartedAt.m = &ma.w.StartedAt.m
		
		return &ma.ca_StartedAt, nil
	case "RunCount":
		if ma.s & fieldBit__Task_RunCount != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__Task_RunCount_serial}
		}
		ma.s += fieldBit__Task_RunCount
		ma.state = maState_midValue
		ma.f = 7
		ma.ca_RunCount.w = &ma.w.RunCount
		ma.ca_RunCount.m = &ma.cm
		return &ma.ca_RunCount, nil
	case "ErrorMessage":
		if ma.s & fieldBit__Task_ErrorMessage != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__Task_ErrorMessage_serial}
		}
		ma.s += fieldBit__Task_ErrorMessage
		ma.state = maState_midValue
		ma.f = 8
		ma.ca_ErrorMessage.w = ma.w.ErrorMessage.v
		ma.ca_ErrorMessage.m = &ma.w.ErrorMessage.m
		
		return &ma.ca_ErrorMessage, nil
	case "RetrievalTask":
		if ma.s & fieldBit__Task_RetrievalTask != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__Task_RetrievalTask_serial}
		}
		ma.s += fieldBit__Task_RetrievalTask
		ma.state = maState_midValue
		ma.f = 9
		ma.ca_RetrievalTask.w = ma.w.RetrievalTask.v
		ma.ca_RetrievalTask.m = &ma.w.RetrievalTask.m
		
		return &ma.ca_RetrievalTask, nil
	case "StorageTask":
		if ma.s & fieldBit__Task_StorageTask != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__Task_StorageTask_serial}
		}
		ma.s += fieldBit__Task_StorageTask
		ma.state = maState_midValue
		ma.f = 10
		ma.ca_StorageTask.w = ma.w.StorageTask.v
		ma.ca_StorageTask.m = &ma.w.StorageTask.m
		
		return &ma.ca_StorageTask, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"tasks.Task.Repr", Key:&_String{k}}
	}
}
func (ma *_Task__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_Task__ReprKeyAssembler)(ma)
}
func (ma *_Task__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_UUID.w = &ma.w.UUID
		ma.ca_UUID.m = &ma.cm
		return &ma.ca_UUID
	case 1:
		ma.ca_Status.w = &ma.w.Status
		ma.ca_Status.m = &ma.cm
		return &ma.ca_Status
	case 2:
		ma.ca_WorkedBy.w = ma.w.WorkedBy.v
		ma.ca_WorkedBy.m = &ma.w.WorkedBy.m
		
		return &ma.ca_WorkedBy
	case 3:
		ma.ca_Stage.w = &ma.w.Stage
		ma.ca_Stage.m = &ma.cm
		return &ma.ca_Stage
	case 4:
		ma.ca_CurrentStageDetails.w = ma.w.CurrentStageDetails.v
		ma.ca_CurrentStageDetails.m = &ma.w.CurrentStageDetails.m
		
		return &ma.ca_CurrentStageDetails
	case 5:
		ma.ca_PastStageDetails.w = ma.w.PastStageDetails.v
		ma.ca_PastStageDetails.m = &ma.w.PastStageDetails.m
		
		return &ma.ca_PastStageDetails
	case 6:
		ma.ca_StartedAt.w = ma.w.StartedAt.v
		ma.ca_StartedAt.m = &ma.w.StartedAt.m
		
		return &ma.ca_StartedAt
	case 7:
		ma.ca_RunCount.w = &ma.w.RunCount
		ma.ca_RunCount.m = &ma.cm
		return &ma.ca_RunCount
	case 8:
		ma.ca_ErrorMessage.w = ma.w.ErrorMessage.v
		ma.ca_ErrorMessage.m = &ma.w.ErrorMessage.m
		
		return &ma.ca_ErrorMessage
	case 9:
		ma.ca_RetrievalTask.w = ma.w.RetrievalTask.v
		ma.ca_RetrievalTask.m = &ma.w.RetrievalTask.m
		
		return &ma.ca_RetrievalTask
	case 10:
		ma.ca_StorageTask.w = ma.w.StorageTask.v
		ma.ca_StorageTask.m = &ma.w.StorageTask.m
		
		return &ma.ca_StorageTask
	default:
		panic("unreachable")
	}
}
func (ma *_Task__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s & fieldBits__Task_sufficient != fieldBits__Task_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s & fieldBit__Task_UUID == 0 {
			err.Missing = append(err.Missing, "UUID")
		}
		if ma.s & fieldBit__Task_Status == 0 {
			err.Missing = append(err.Missing, "Status")
		}
		if ma.s & fieldBit__Task_Stage == 0 {
			err.Missing = append(err.Missing, "Stage")
		}
		if ma.s & fieldBit__Task_RunCount == 0 {
			err.Missing = append(err.Missing, "RunCount")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_Task__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_Task__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}
type _Task__ReprKeyAssembler _Task__ReprAssembler
func (_Task__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"tasks.Task.Repr.KeyAssembler"}.BeginMap(0)
}
func (_Task__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"tasks.Task.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_Task__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"tasks.Task.Repr.KeyAssembler"}.AssignNull()
}
func (_Task__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"tasks.Task.Repr.KeyAssembler"}.AssignBool(false)
}
func (_Task__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"tasks.Task.Repr.KeyAssembler"}.AssignInt(0)
}
func (_Task__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"tasks.Task.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_Task__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "UUID":
		if ka.s & fieldBit__Task_UUID != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__Task_UUID_serial}
		}
		ka.s += fieldBit__Task_UUID
		ka.state = maState_expectValue
		ka.f = 0
	case "Status":
		if ka.s & fieldBit__Task_Status != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__Task_Status_serial}
		}
		ka.s += fieldBit__Task_Status
		ka.state = maState_expectValue
		ka.f = 1
	case "WorkedBy":
		if ka.s & fieldBit__Task_WorkedBy != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__Task_WorkedBy_serial}
		}
		ka.s += fieldBit__Task_WorkedBy
		ka.state = maState_expectValue
		ka.f = 2
	case "Stage":
		if ka.s & fieldBit__Task_Stage != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__Task_Stage_serial}
		}
		ka.s += fieldBit__Task_Stage
		ka.state = maState_expectValue
		ka.f = 3
	case "CurrentStageDetails":
		if ka.s & fieldBit__Task_CurrentStageDetails != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__Task_CurrentStageDetails_serial}
		}
		ka.s += fieldBit__Task_CurrentStageDetails
		ka.state = maState_expectValue
		ka.f = 4
	case "PastStageDetails":
		if ka.s & fieldBit__Task_PastStageDetails != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__Task_PastStageDetails_serial}
		}
		ka.s += fieldBit__Task_PastStageDetails
		ka.state = maState_expectValue
		ka.f = 5
	case "StartedAt":
		if ka.s & fieldBit__Task_StartedAt != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__Task_StartedAt_serial}
		}
		ka.s += fieldBit__Task_StartedAt
		ka.state = maState_expectValue
		ka.f = 6
	case "RunCount":
		if ka.s & fieldBit__Task_RunCount != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__Task_RunCount_serial}
		}
		ka.s += fieldBit__Task_RunCount
		ka.state = maState_expectValue
		ka.f = 7
	case "ErrorMessage":
		if ka.s & fieldBit__Task_ErrorMessage != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__Task_ErrorMessage_serial}
		}
		ka.s += fieldBit__Task_ErrorMessage
		ka.state = maState_expectValue
		ka.f = 8
	case "RetrievalTask":
		if ka.s & fieldBit__Task_RetrievalTask != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__Task_RetrievalTask_serial}
		}
		ka.s += fieldBit__Task_RetrievalTask
		ka.state = maState_expectValue
		ka.f = 9
	case "StorageTask":
		if ka.s & fieldBit__Task_StorageTask != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__Task_StorageTask_serial}
		}
		ka.s += fieldBit__Task_StorageTask
		ka.state = maState_expectValue
		ka.f = 10
	default:
		return ipld.ErrInvalidKey{TypeName:"tasks.Task.Repr", Key:&_String{k}}
	}
	return nil
}
func (_Task__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"tasks.Task.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_Task__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"tasks.Task.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_Task__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_Task__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

func (n *_Tasks) Lookup(idx int64) Task {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return v
}
func (n *_Tasks) LookupMaybe(idx int64) MaybeTask {
	if n.Length() <= idx {
		return nil
	}
	v := &n.x[idx]
	return &_Task__Maybe{
		m: schema.Maybe_Value,
		v: v,
	}
}

var _Tasks__valueAbsent = _Task__Maybe{m:schema.Maybe_Absent}
func (n Tasks) Iterator() *Tasks__Itr {
	return &Tasks__Itr{n, 0}
}

type Tasks__Itr struct {
	n Tasks
	idx  int
}

func (itr *Tasks__Itr) Next() (idx int64, v Task) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil
	}
	idx = int64(itr.idx)
	v = &itr.n.x[itr.idx]
	itr.idx++
	return
}
func (itr *Tasks__Itr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

type _Tasks__Maybe struct {
	m schema.Maybe
	v Tasks
}
type MaybeTasks = *_Tasks__Maybe

func (m MaybeTasks) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeTasks) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeTasks) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeTasks) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeTasks) Must() Tasks {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var _ ipld.Node = (Tasks)(&_Tasks{})
var _ schema.TypedNode = (Tasks)(&_Tasks{})
func (Tasks) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (Tasks) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"tasks.Tasks"}.LookupByString("")
}
func (n Tasks) LookupByNode(k ipld.Node) (ipld.Node, error) {
	idx, err := k.AsInt()
	if err != nil {
		return nil, err
	}
	return n.LookupByIndex(idx)
}
func (n Tasks) LookupByIndex(idx int64) (ipld.Node, error) {
	if n.Length() <= idx {
		return nil, ipld.ErrNotExists{ipld.PathSegmentOfInt(idx)}
	}
	v := &n.x[idx]
	return v, nil
}
func (n Tasks) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "tasks.Tasks", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (Tasks) MapIterator() ipld.MapIterator {
	return nil
}
func (n Tasks) ListIterator() ipld.ListIterator {
	return &_Tasks__ListItr{n, 0}
}

type _Tasks__ListItr struct {
	n Tasks
	idx  int
}

func (itr *_Tasks__ListItr) Next() (idx int64, v ipld.Node, _ error) {
	if itr.idx >= len(itr.n.x) {
		return -1, nil, ipld.ErrIteratorOverread{}
	}
	idx = int64(itr.idx)
	x := &itr.n.x[itr.idx]
	v = x
	itr.idx++
	return
}
func (itr *_Tasks__ListItr) Done() bool {
	return itr.idx >= len(itr.n.x)
}

func (n Tasks) Length() int64 {
	return int64(len(n.x))
}
func (Tasks) IsAbsent() bool {
	return false
}
func (Tasks) IsNull() bool {
	return false
}
func (Tasks) AsBool() (bool, error) {
	return mixins.List{"tasks.Tasks"}.AsBool()
}
func (Tasks) AsInt() (int64, error) {
	return mixins.List{"tasks.Tasks"}.AsInt()
}
func (Tasks) AsFloat() (float64, error) {
	return mixins.List{"tasks.Tasks"}.AsFloat()
}
func (Tasks) AsString() (string, error) {
	return mixins.List{"tasks.Tasks"}.AsString()
}
func (Tasks) AsBytes() ([]byte, error) {
	return mixins.List{"tasks.Tasks"}.AsBytes()
}
func (Tasks) AsLink() (ipld.Link, error) {
	return mixins.List{"tasks.Tasks"}.AsLink()
}
func (Tasks) Prototype() ipld.NodePrototype {
	return _Tasks__Prototype{}
}
type _Tasks__Prototype struct{}

func (_Tasks__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Tasks__Builder
	nb.Reset()
	return &nb
}
type _Tasks__Builder struct {
	_Tasks__Assembler
}
func (nb *_Tasks__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Tasks__Builder) Reset() {
	var w _Tasks
	var m schema.Maybe
	*nb = _Tasks__Builder{_Tasks__Assembler{w: &w, m: &m}}
}
type _Tasks__Assembler struct {
	w *_Tasks
	m *schema.Maybe
	state laState

	cm schema.Maybe
	va _Task__Assembler
}

func (na *_Tasks__Assembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_Tasks__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"tasks.Tasks"}.BeginMap(0)
}
func (na *_Tasks__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_Tasks{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_Task, 0, sizeHint)
	}
	return na, nil
}
func (na *_Tasks__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"tasks.Tasks"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Tasks__Assembler) AssignBool(bool) error {
	return mixins.ListAssembler{"tasks.Tasks"}.AssignBool(false)
}
func (_Tasks__Assembler) AssignInt(int64) error {
	return mixins.ListAssembler{"tasks.Tasks"}.AssignInt(0)
}
func (_Tasks__Assembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"tasks.Tasks"}.AssignFloat(0)
}
func (_Tasks__Assembler) AssignString(string) error {
	return mixins.ListAssembler{"tasks.Tasks"}.AssignString("")
}
func (_Tasks__Assembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"tasks.Tasks"}.AssignBytes(nil)
}
func (_Tasks__Assembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"tasks.Tasks"}.AssignLink(nil)
}
func (na *_Tasks__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Tasks); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "tasks.Tasks", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Tasks__Assembler) Prototype() ipld.NodePrototype {
	return _Tasks__Prototype{}
}
func (la *_Tasks__Assembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_Tasks__Assembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Task{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_Tasks__Assembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_Tasks__Assembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Task__Prototype{}
}
func (Tasks) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Tasks) Representation() ipld.Node {
	return (*_Tasks__Repr)(n)
}
type _Tasks__Repr _Tasks
var _ ipld.Node = &_Tasks__Repr{}
func (_Tasks__Repr) Kind() ipld.Kind {
	return ipld.Kind_List
}
func (_Tasks__Repr) LookupByString(string) (ipld.Node, error) {
	return mixins.List{"tasks.Tasks.Repr"}.LookupByString("")
}
func (nr *_Tasks__Repr) LookupByNode(k ipld.Node) (ipld.Node, error) {
	v, err := (Tasks)(nr).LookupByNode(k)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Task).Representation(), nil
}
func (nr *_Tasks__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	v, err := (Tasks)(nr).LookupByIndex(idx)
	if err != nil || v == ipld.Null {
		return v, err
	}
	return v.(Task).Representation(), nil
}
func (n _Tasks__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	i, err := seg.Index()
	if err != nil {
		return nil, ipld.ErrInvalidSegmentForList{TypeName: "tasks.Tasks.Repr", TroubleSegment: seg, Reason: err}
	}
	return n.LookupByIndex(i)
}
func (_Tasks__Repr) MapIterator() ipld.MapIterator {
	return nil
}
func (nr *_Tasks__Repr) ListIterator() ipld.ListIterator {
	return &_Tasks__ReprListItr{(Tasks)(nr), 0}
}

type _Tasks__ReprListItr _Tasks__ListItr

func (itr *_Tasks__ReprListItr) Next() (idx int64, v ipld.Node, err error) {
	idx, v, err = (*_Tasks__ListItr)(itr).Next()
	if err != nil || v == ipld.Null {
		return
	}
	return idx, v.(Task).Representation(), nil
}
func (itr *_Tasks__ReprListItr) Done() bool {
	return (*_Tasks__ListItr)(itr).Done()
}

func (rn *_Tasks__Repr) Length() int64 {
	return int64(len(rn.x))
}
func (_Tasks__Repr) IsAbsent() bool {
	return false
}
func (_Tasks__Repr) IsNull() bool {
	return false
}
func (_Tasks__Repr) AsBool() (bool, error) {
	return mixins.List{"tasks.Tasks.Repr"}.AsBool()
}
func (_Tasks__Repr) AsInt() (int64, error) {
	return mixins.List{"tasks.Tasks.Repr"}.AsInt()
}
func (_Tasks__Repr) AsFloat() (float64, error) {
	return mixins.List{"tasks.Tasks.Repr"}.AsFloat()
}
func (_Tasks__Repr) AsString() (string, error) {
	return mixins.List{"tasks.Tasks.Repr"}.AsString()
}
func (_Tasks__Repr) AsBytes() ([]byte, error) {
	return mixins.List{"tasks.Tasks.Repr"}.AsBytes()
}
func (_Tasks__Repr) AsLink() (ipld.Link, error) {
	return mixins.List{"tasks.Tasks.Repr"}.AsLink()
}
func (_Tasks__Repr) Prototype() ipld.NodePrototype {
	return _Tasks__ReprPrototype{}
}
type _Tasks__ReprPrototype struct{}

func (_Tasks__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _Tasks__ReprBuilder
	nb.Reset()
	return &nb
}
type _Tasks__ReprBuilder struct {
	_Tasks__ReprAssembler
}
func (nb *_Tasks__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Tasks__ReprBuilder) Reset() {
	var w _Tasks
	var m schema.Maybe
	*nb = _Tasks__ReprBuilder{_Tasks__ReprAssembler{w: &w, m: &m}}
}
type _Tasks__ReprAssembler struct {
	w *_Tasks
	m *schema.Maybe
	state laState

	cm schema.Maybe
	va _Task__ReprAssembler
}

func (na *_Tasks__ReprAssembler) reset() {
	na.state = laState_initial
	na.va.reset()
}
func (_Tasks__ReprAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.ListAssembler{"tasks.Tasks.Repr"}.BeginMap(0)
}
func (na *_Tasks__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if sizeHint < 0 {
		sizeHint = 0
	}
	if na.w == nil {
		na.w = &_Tasks{}
	}
	if sizeHint > 0 {
		na.w.x = make([]_Task, 0, sizeHint)
	}
	return na, nil
}
func (na *_Tasks__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.ListAssembler{"tasks.Tasks.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_Tasks__ReprAssembler) AssignBool(bool) error {
	return mixins.ListAssembler{"tasks.Tasks.Repr"}.AssignBool(false)
}
func (_Tasks__ReprAssembler) AssignInt(int64) error {
	return mixins.ListAssembler{"tasks.Tasks.Repr"}.AssignInt(0)
}
func (_Tasks__ReprAssembler) AssignFloat(float64) error {
	return mixins.ListAssembler{"tasks.Tasks.Repr"}.AssignFloat(0)
}
func (_Tasks__ReprAssembler) AssignString(string) error {
	return mixins.ListAssembler{"tasks.Tasks.Repr"}.AssignString("")
}
func (_Tasks__ReprAssembler) AssignBytes([]byte) error {
	return mixins.ListAssembler{"tasks.Tasks.Repr"}.AssignBytes(nil)
}
func (_Tasks__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.ListAssembler{"tasks.Tasks.Repr"}.AssignLink(nil)
}
func (na *_Tasks__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Tasks); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_List {
		return ipld.ErrWrongKind{TypeName: "tasks.Tasks.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustList, ActualKind: v.Kind()}
	}
	itr := v.ListIterator()
	for !itr.Done() {
		_, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_Tasks__ReprAssembler) Prototype() ipld.NodePrototype {
	return _Tasks__ReprPrototype{}
}
func (la *_Tasks__ReprAssembler) valueFinishTidy() bool {
	switch la.cm {
	case schema.Maybe_Value:
		la.va.w = nil
		la.cm = schema.Maybe_Absent
		la.state = laState_initial
		la.va.reset()
		return true
	default:
		return false
	}
}
func (la *_Tasks__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: AssembleValue cannot be called when still in the middle of assembling the previous value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	la.w.x = append(la.w.x, _Task{})
	la.state = laState_midValue
	row := &la.w.x[len(la.w.x)-1]
	la.va.w = row
	la.va.m = &la.cm
	return &la.va
}
func (la *_Tasks__ReprAssembler) Finish() error {
	switch la.state {
	case laState_initial:
		// carry on
	case laState_midValue:
		if !la.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case laState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	la.state = laState_finished
	*la.m = schema.Maybe_Value
	return nil
}
func (la *_Tasks__ReprAssembler) ValuePrototype(_ int64) ipld.NodePrototype {
	return _Task__ReprPrototype{}
}

func (n Time) Int() int64 {
	return n.x
}
func (_Time__Prototype) FromInt(v int64) (Time, error) {
	n := _Time{v}
	return &n, nil
}
type _Time__Maybe struct {
	m schema.Maybe
	v Time
}
type MaybeTime = *_Time__Maybe

func (m MaybeTime) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeTime) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeTime) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeTime) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeTime) Must() Time {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var _ ipld.Node = (Time)(&_Time{})
var _ schema.TypedNode = (Time)(&_Time{})
func (Time) Kind() ipld.Kind {
	return ipld.Kind_Int
}
func (Time) LookupByString(string) (ipld.Node, error) {
	return mixins.Int{"tasks.Time"}.LookupByString("")
}
func (Time) LookupByNode(ipld.Node) (ipld.Node, error) {
	return mixins.Int{"tasks.Time"}.LookupByNode(nil)
}
func (Time) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Int{"tasks.Time"}.LookupByIndex(0)
}
func (Time) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return mixins.Int{"tasks.Time"}.LookupBySegment(seg)
}
func (Time) MapIterator() ipld.MapIterator {
	return nil
}
func (Time) ListIterator() ipld.ListIterator {
	return nil
}
func (Time) Length() int64 {
	return -1
}
func (Time) IsAbsent() bool {
	return false
}
func (Time) IsNull() bool {
	return false
}
func (Time) AsBool() (bool, error) {
	return mixins.Int{"tasks.Time"}.AsBool()
}
func (n Time) AsInt() (int64, error) {
	return n.x, nil
}
func (Time) AsFloat() (float64, error) {
	return mixins.Int{"tasks.Time"}.AsFloat()
}
func (Time) AsString() (string, error) {
	return mixins.Int{"tasks.Time"}.AsString()
}
func (Time) AsBytes() ([]byte, error) {
	return mixins.Int{"tasks.Time"}.AsBytes()
}
func (Time) AsLink() (ipld.Link, error) {
	return mixins.Int{"tasks.Time"}.AsLink()
}
func (Time) Prototype() ipld.NodePrototype {
	return _Time__Prototype{}
}
type _Time__Prototype struct{}

func (_Time__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _Time__Builder
	nb.Reset()
	return &nb
}
type _Time__Builder struct {
	_Time__Assembler
}
func (nb *_Time__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_Time__Builder) Reset() {
	var w _Time
	var m schema.Maybe
	*nb = _Time__Builder{_Time__Assembler{w: &w, m: &m}}
}
type _Time__Assembler struct {
	w *_Time
	m *schema.Maybe
}

func (na *_Time__Assembler) reset() {}
func (_Time__Assembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.IntAssembler{"tasks.Time"}.BeginMap(0)
}
func (_Time__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.IntAssembler{"tasks.Time"}.BeginList(0)
}
func (na *_Time__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.IntAssembler{"tasks.Time"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	panic("unreachable")
}
func (_Time__Assembler) AssignBool(bool) error {
	return mixins.IntAssembler{"tasks.Time"}.AssignBool(false)
}
func (na *_Time__Assembler) AssignInt(v int64) error {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	}
	if na.w == nil {
		na.w = &_Time{}
	}
	na.w.x = v
	*na.m = schema.Maybe_Value
	return nil
}
func (_Time__Assembler) AssignFloat(float64) error {
	return mixins.IntAssembler{"tasks.Time"}.AssignFloat(0)
}
func (_Time__Assembler) AssignString(string) error {
	return mixins.IntAssembler{"tasks.Time"}.AssignString("")
}
func (_Time__Assembler) AssignBytes([]byte) error {
	return mixins.IntAssembler{"tasks.Time"}.AssignBytes(nil)
}
func (_Time__Assembler) AssignLink(ipld.Link) error {
	return mixins.IntAssembler{"tasks.Time"}.AssignLink(nil)
}
func (na *_Time__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_Time); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v2, err := v.AsInt(); err != nil {
		return err
	} else {
		return na.AssignInt(v2)
	}
}
func (_Time__Assembler) Prototype() ipld.NodePrototype {
	return _Time__Prototype{}
}
func (Time) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n Time) Representation() ipld.Node {
	return (*_Time__Repr)(n)
}
type _Time__Repr = _Time
var _ ipld.Node = &_Time__Repr{}
type _Time__ReprPrototype = _Time__Prototype
type _Time__ReprAssembler = _Time__Assembler


func (n _UpdateTask) FieldStatus() Status {
	return &n.Status
}
func (n _UpdateTask) FieldErrorMessage() MaybeString {
	return &n.ErrorMessage
}
func (n _UpdateTask) FieldStage() MaybeString {
	return &n.Stage
}
func (n _UpdateTask) FieldCurrentStageDetails() MaybeStageDetails {
	return &n.CurrentStageDetails
}
func (n _UpdateTask) FieldWorkedBy() String {
	return &n.WorkedBy
}
func (n _UpdateTask) FieldRunCount() Int {
	return &n.RunCount
}
type _UpdateTask__Maybe struct {
	m schema.Maybe
	v UpdateTask
}
type MaybeUpdateTask = *_UpdateTask__Maybe

func (m MaybeUpdateTask) IsNull() bool {
	return m.m == schema.Maybe_Null
}
func (m MaybeUpdateTask) IsAbsent() bool {
	return m.m == schema.Maybe_Absent
}
func (m MaybeUpdateTask) Exists() bool {
	return m.m == schema.Maybe_Value
}
func (m MaybeUpdateTask) AsNode() ipld.Node {
	switch m.m {
		case schema.Maybe_Absent:
			return ipld.Absent
		case schema.Maybe_Null:
			return ipld.Null
		case schema.Maybe_Value:
			return m.v
		default:
			panic("unreachable")
	}
}
func (m MaybeUpdateTask) Must() UpdateTask {
	if !m.Exists() {
		panic("unbox of a maybe rejected")
	}
	return m.v
}
var (
	fieldName__UpdateTask_Status = _String{"Status"}
	fieldName__UpdateTask_ErrorMessage = _String{"ErrorMessage"}
	fieldName__UpdateTask_Stage = _String{"Stage"}
	fieldName__UpdateTask_CurrentStageDetails = _String{"CurrentStageDetails"}
	fieldName__UpdateTask_WorkedBy = _String{"WorkedBy"}
	fieldName__UpdateTask_RunCount = _String{"RunCount"}
)
var _ ipld.Node = (UpdateTask)(&_UpdateTask{})
var _ schema.TypedNode = (UpdateTask)(&_UpdateTask{})
func (UpdateTask) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n UpdateTask) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Status":
		return &n.Status, nil
	case "ErrorMessage":
		if n.ErrorMessage.m == schema.Maybe_Absent {
			return ipld.Absent, nil
		}
		return n.ErrorMessage.v, nil
	case "Stage":
		if n.Stage.m == schema.Maybe_Absent {
			return ipld.Absent, nil
		}
		return n.Stage.v, nil
	case "CurrentStageDetails":
		if n.CurrentStageDetails.m == schema.Maybe_Absent {
			return ipld.Absent, nil
		}
		return n.CurrentStageDetails.v, nil
	case "WorkedBy":
		return &n.WorkedBy, nil
	case "RunCount":
		return &n.RunCount, nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n UpdateTask) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (UpdateTask) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"tasks.UpdateTask"}.LookupByIndex(0)
}
func (n UpdateTask) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n UpdateTask) MapIterator() ipld.MapIterator {
	return &_UpdateTask__MapItr{n, 0}
}

type _UpdateTask__MapItr struct {
	n UpdateTask
	idx  int
}

func (itr *_UpdateTask__MapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
	if itr.idx >= 6 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__UpdateTask_Status
		v = &itr.n.Status
	case 1:
		k = &fieldName__UpdateTask_ErrorMessage
		if itr.n.ErrorMessage.m == schema.Maybe_Absent {
			v = ipld.Absent
			break
		}
		v = itr.n.ErrorMessage.v
	case 2:
		k = &fieldName__UpdateTask_Stage
		if itr.n.Stage.m == schema.Maybe_Absent {
			v = ipld.Absent
			break
		}
		v = itr.n.Stage.v
	case 3:
		k = &fieldName__UpdateTask_CurrentStageDetails
		if itr.n.CurrentStageDetails.m == schema.Maybe_Absent {
			v = ipld.Absent
			break
		}
		v = itr.n.CurrentStageDetails.v
	case 4:
		k = &fieldName__UpdateTask_WorkedBy
		v = &itr.n.WorkedBy
	case 5:
		k = &fieldName__UpdateTask_RunCount
		v = &itr.n.RunCount
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_UpdateTask__MapItr) Done() bool {
	return itr.idx >= 6
}

func (UpdateTask) ListIterator() ipld.ListIterator {
	return nil
}
func (UpdateTask) Length() int64 {
	return 6
}
func (UpdateTask) IsAbsent() bool {
	return false
}
func (UpdateTask) IsNull() bool {
	return false
}
func (UpdateTask) AsBool() (bool, error) {
	return mixins.Map{"tasks.UpdateTask"}.AsBool()
}
func (UpdateTask) AsInt() (int64, error) {
	return mixins.Map{"tasks.UpdateTask"}.AsInt()
}
func (UpdateTask) AsFloat() (float64, error) {
	return mixins.Map{"tasks.UpdateTask"}.AsFloat()
}
func (UpdateTask) AsString() (string, error) {
	return mixins.Map{"tasks.UpdateTask"}.AsString()
}
func (UpdateTask) AsBytes() ([]byte, error) {
	return mixins.Map{"tasks.UpdateTask"}.AsBytes()
}
func (UpdateTask) AsLink() (ipld.Link, error) {
	return mixins.Map{"tasks.UpdateTask"}.AsLink()
}
func (UpdateTask) Prototype() ipld.NodePrototype {
	return _UpdateTask__Prototype{}
}
type _UpdateTask__Prototype struct{}

func (_UpdateTask__Prototype) NewBuilder() ipld.NodeBuilder {
	var nb _UpdateTask__Builder
	nb.Reset()
	return &nb
}
type _UpdateTask__Builder struct {
	_UpdateTask__Assembler
}
func (nb *_UpdateTask__Builder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_UpdateTask__Builder) Reset() {
	var w _UpdateTask
	var m schema.Maybe
	*nb = _UpdateTask__Builder{_UpdateTask__Assembler{w: &w, m: &m}}
}
type _UpdateTask__Assembler struct {
	w *_UpdateTask
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_Status _Status__Assembler
	ca_ErrorMessage _String__Assembler
	ca_Stage _String__Assembler
	ca_CurrentStageDetails _StageDetails__Assembler
	ca_WorkedBy _String__Assembler
	ca_RunCount _Int__Assembler
	}

func (na *_UpdateTask__Assembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Status.reset()
	na.ca_ErrorMessage.reset()
	na.ca_Stage.reset()
	na.ca_CurrentStageDetails.reset()
	na.ca_WorkedBy.reset()
	na.ca_RunCount.reset()
}

var (
	fieldBit__UpdateTask_Status = 1 << 0
	fieldBit__UpdateTask_ErrorMessage = 1 << 1
	fieldBit__UpdateTask_Stage = 1 << 2
	fieldBit__UpdateTask_CurrentStageDetails = 1 << 3
	fieldBit__UpdateTask_WorkedBy = 1 << 4
	fieldBit__UpdateTask_RunCount = 1 << 5
	fieldBits__UpdateTask_sufficient = 0 + 1 << 0 + 1 << 4 + 1 << 5
)
func (na *_UpdateTask__Assembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_UpdateTask{}
	}
	return na, nil
}
func (_UpdateTask__Assembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"tasks.UpdateTask"}.BeginList(0)
}
func (na *_UpdateTask__Assembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"tasks.UpdateTask"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_UpdateTask__Assembler) AssignBool(bool) error {
	return mixins.MapAssembler{"tasks.UpdateTask"}.AssignBool(false)
}
func (_UpdateTask__Assembler) AssignInt(int64) error {
	return mixins.MapAssembler{"tasks.UpdateTask"}.AssignInt(0)
}
func (_UpdateTask__Assembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"tasks.UpdateTask"}.AssignFloat(0)
}
func (_UpdateTask__Assembler) AssignString(string) error {
	return mixins.MapAssembler{"tasks.UpdateTask"}.AssignString("")
}
func (_UpdateTask__Assembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"tasks.UpdateTask"}.AssignBytes(nil)
}
func (_UpdateTask__Assembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"tasks.UpdateTask"}.AssignLink(nil)
}
func (na *_UpdateTask__Assembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_UpdateTask); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "tasks.UpdateTask", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_UpdateTask__Assembler) Prototype() ipld.NodePrototype {
	return _UpdateTask__Prototype{}
}
func (ma *_UpdateTask__Assembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_Status.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.w.ErrorMessage.m {
		case schema.Maybe_Value:
			ma.w.ErrorMessage.v = ma.ca_ErrorMessage.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.w.Stage.m {
		case schema.Maybe_Value:
			ma.w.Stage.v = ma.ca_Stage.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.w.CurrentStageDetails.m {
		case schema.Maybe_Value:
			ma.w.CurrentStageDetails.v = ma.ca_CurrentStageDetails.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_WorkedBy.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 5:
		switch ma.cm {
		case schema.Maybe_Value:
			ma.ca_RunCount.w = nil
			ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_UpdateTask__Assembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Status":
		if ma.s & fieldBit__UpdateTask_Status != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__UpdateTask_Status}
		}
		ma.s += fieldBit__UpdateTask_Status
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Status.w = &ma.w.Status
		ma.ca_Status.m = &ma.cm
		return &ma.ca_Status, nil
	case "ErrorMessage":
		if ma.s & fieldBit__UpdateTask_ErrorMessage != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__UpdateTask_ErrorMessage}
		}
		ma.s += fieldBit__UpdateTask_ErrorMessage
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_ErrorMessage.w = ma.w.ErrorMessage.v
		ma.ca_ErrorMessage.m = &ma.w.ErrorMessage.m
		return &ma.ca_ErrorMessage, nil
	case "Stage":
		if ma.s & fieldBit__UpdateTask_Stage != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__UpdateTask_Stage}
		}
		ma.s += fieldBit__UpdateTask_Stage
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Stage.w = ma.w.Stage.v
		ma.ca_Stage.m = &ma.w.Stage.m
		return &ma.ca_Stage, nil
	case "CurrentStageDetails":
		if ma.s & fieldBit__UpdateTask_CurrentStageDetails != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__UpdateTask_CurrentStageDetails}
		}
		ma.s += fieldBit__UpdateTask_CurrentStageDetails
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_CurrentStageDetails.w = ma.w.CurrentStageDetails.v
		ma.ca_CurrentStageDetails.m = &ma.w.CurrentStageDetails.m
		return &ma.ca_CurrentStageDetails, nil
	case "WorkedBy":
		if ma.s & fieldBit__UpdateTask_WorkedBy != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__UpdateTask_WorkedBy}
		}
		ma.s += fieldBit__UpdateTask_WorkedBy
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_WorkedBy.w = &ma.w.WorkedBy
		ma.ca_WorkedBy.m = &ma.cm
		return &ma.ca_WorkedBy, nil
	case "RunCount":
		if ma.s & fieldBit__UpdateTask_RunCount != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__UpdateTask_RunCount}
		}
		ma.s += fieldBit__UpdateTask_RunCount
		ma.state = maState_midValue
		ma.f = 5
		ma.ca_RunCount.w = &ma.w.RunCount
		ma.ca_RunCount.m = &ma.cm
		return &ma.ca_RunCount, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"tasks.UpdateTask", Key:&_String{k}}
	}
}
func (ma *_UpdateTask__Assembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_UpdateTask__KeyAssembler)(ma)
}
func (ma *_UpdateTask__Assembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Status.w = &ma.w.Status
		ma.ca_Status.m = &ma.cm
		return &ma.ca_Status
	case 1:
		ma.ca_ErrorMessage.w = ma.w.ErrorMessage.v
		ma.ca_ErrorMessage.m = &ma.w.ErrorMessage.m
		return &ma.ca_ErrorMessage
	case 2:
		ma.ca_Stage.w = ma.w.Stage.v
		ma.ca_Stage.m = &ma.w.Stage.m
		return &ma.ca_Stage
	case 3:
		ma.ca_CurrentStageDetails.w = ma.w.CurrentStageDetails.v
		ma.ca_CurrentStageDetails.m = &ma.w.CurrentStageDetails.m
		return &ma.ca_CurrentStageDetails
	case 4:
		ma.ca_WorkedBy.w = &ma.w.WorkedBy
		ma.ca_WorkedBy.m = &ma.cm
		return &ma.ca_WorkedBy
	case 5:
		ma.ca_RunCount.w = &ma.w.RunCount
		ma.ca_RunCount.m = &ma.cm
		return &ma.ca_RunCount
	default:
		panic("unreachable")
	}
}
func (ma *_UpdateTask__Assembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s & fieldBits__UpdateTask_sufficient != fieldBits__UpdateTask_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s & fieldBit__UpdateTask_Status == 0 {
			err.Missing = append(err.Missing, "Status")
		}
		if ma.s & fieldBit__UpdateTask_WorkedBy == 0 {
			err.Missing = append(err.Missing, "WorkedBy")
		}
		if ma.s & fieldBit__UpdateTask_RunCount == 0 {
			err.Missing = append(err.Missing, "RunCount")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_UpdateTask__Assembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_UpdateTask__Assembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler valueprototype")
}
type _UpdateTask__KeyAssembler _UpdateTask__Assembler
func (_UpdateTask__KeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"tasks.UpdateTask.KeyAssembler"}.BeginMap(0)
}
func (_UpdateTask__KeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"tasks.UpdateTask.KeyAssembler"}.BeginList(0)
}
func (na *_UpdateTask__KeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"tasks.UpdateTask.KeyAssembler"}.AssignNull()
}
func (_UpdateTask__KeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"tasks.UpdateTask.KeyAssembler"}.AssignBool(false)
}
func (_UpdateTask__KeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"tasks.UpdateTask.KeyAssembler"}.AssignInt(0)
}
func (_UpdateTask__KeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"tasks.UpdateTask.KeyAssembler"}.AssignFloat(0)
}
func (ka *_UpdateTask__KeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Status":
		if ka.s & fieldBit__UpdateTask_Status != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__UpdateTask_Status}
		}
		ka.s += fieldBit__UpdateTask_Status
		ka.state = maState_expectValue
		ka.f = 0
	case "ErrorMessage":
		if ka.s & fieldBit__UpdateTask_ErrorMessage != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__UpdateTask_ErrorMessage}
		}
		ka.s += fieldBit__UpdateTask_ErrorMessage
		ka.state = maState_expectValue
		ka.f = 1
	case "Stage":
		if ka.s & fieldBit__UpdateTask_Stage != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__UpdateTask_Stage}
		}
		ka.s += fieldBit__UpdateTask_Stage
		ka.state = maState_expectValue
		ka.f = 2
	case "CurrentStageDetails":
		if ka.s & fieldBit__UpdateTask_CurrentStageDetails != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__UpdateTask_CurrentStageDetails}
		}
		ka.s += fieldBit__UpdateTask_CurrentStageDetails
		ka.state = maState_expectValue
		ka.f = 3
	case "WorkedBy":
		if ka.s & fieldBit__UpdateTask_WorkedBy != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__UpdateTask_WorkedBy}
		}
		ka.s += fieldBit__UpdateTask_WorkedBy
		ka.state = maState_expectValue
		ka.f = 4
	case "RunCount":
		if ka.s & fieldBit__UpdateTask_RunCount != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__UpdateTask_RunCount}
		}
		ka.s += fieldBit__UpdateTask_RunCount
		ka.state = maState_expectValue
		ka.f = 5
	default:
		return ipld.ErrInvalidKey{TypeName:"tasks.UpdateTask", Key:&_String{k}}
	}
	return nil
}
func (_UpdateTask__KeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"tasks.UpdateTask.KeyAssembler"}.AssignBytes(nil)
}
func (_UpdateTask__KeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"tasks.UpdateTask.KeyAssembler"}.AssignLink(nil)
}
func (ka *_UpdateTask__KeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_UpdateTask__KeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (UpdateTask) Type() schema.Type {
	return nil /*TODO:typelit*/
}
func (n UpdateTask) Representation() ipld.Node {
	return (*_UpdateTask__Repr)(n)
}
type _UpdateTask__Repr _UpdateTask
var (
	fieldName__UpdateTask_Status_serial = _String{"Status"}
	fieldName__UpdateTask_ErrorMessage_serial = _String{"ErrorMessage"}
	fieldName__UpdateTask_Stage_serial = _String{"Stage"}
	fieldName__UpdateTask_CurrentStageDetails_serial = _String{"CurrentStageDetails"}
	fieldName__UpdateTask_WorkedBy_serial = _String{"WorkedBy"}
	fieldName__UpdateTask_RunCount_serial = _String{"RunCount"}
)
var _ ipld.Node = &_UpdateTask__Repr{}
func (_UpdateTask__Repr) Kind() ipld.Kind {
	return ipld.Kind_Map
}
func (n *_UpdateTask__Repr) LookupByString(key string) (ipld.Node, error) {
	switch key {
	case "Status":
		return n.Status.Representation(), nil
	case "ErrorMessage":
		if n.ErrorMessage.m == schema.Maybe_Absent {
			return ipld.Absent, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.ErrorMessage.v.Representation(), nil
	case "Stage":
		if n.Stage.m == schema.Maybe_Absent {
			return ipld.Absent, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.Stage.v.Representation(), nil
	case "CurrentStageDetails":
		if n.CurrentStageDetails.m == schema.Maybe_Absent {
			return ipld.Absent, ipld.ErrNotExists{ipld.PathSegmentOfString(key)}
		}
		return n.CurrentStageDetails.v.Representation(), nil
	case "WorkedBy":
		return n.WorkedBy.Representation(), nil
	case "RunCount":
		return n.RunCount.Representation(), nil
	default:
		return nil, schema.ErrNoSuchField{Type: nil /*TODO*/, Field: ipld.PathSegmentOfString(key)}
	}
}
func (n *_UpdateTask__Repr) LookupByNode(key ipld.Node) (ipld.Node, error) {
	ks, err := key.AsString()
	if err != nil {
		return nil, err
	}
	return n.LookupByString(ks)
}
func (_UpdateTask__Repr) LookupByIndex(idx int64) (ipld.Node, error) {
	return mixins.Map{"tasks.UpdateTask.Repr"}.LookupByIndex(0)
}
func (n _UpdateTask__Repr) LookupBySegment(seg ipld.PathSegment) (ipld.Node, error) {
	return n.LookupByString(seg.String())
}
func (n *_UpdateTask__Repr) MapIterator() ipld.MapIterator {
	return &_UpdateTask__ReprMapItr{n, 0}
}

type _UpdateTask__ReprMapItr struct {
	n   *_UpdateTask__Repr
	idx int
	
}

func (itr *_UpdateTask__ReprMapItr) Next() (k ipld.Node, v ipld.Node, _ error) {
advance:if itr.idx >= 6 {
		return nil, nil, ipld.ErrIteratorOverread{}
	}
	switch itr.idx {
	case 0:
		k = &fieldName__UpdateTask_Status_serial
		v = itr.n.Status.Representation()
	case 1:
		k = &fieldName__UpdateTask_ErrorMessage_serial
		if itr.n.ErrorMessage.m == schema.Maybe_Absent {
			itr.idx++
			goto advance
		}
		v = itr.n.ErrorMessage.v.Representation()
	case 2:
		k = &fieldName__UpdateTask_Stage_serial
		if itr.n.Stage.m == schema.Maybe_Absent {
			itr.idx++
			goto advance
		}
		v = itr.n.Stage.v.Representation()
	case 3:
		k = &fieldName__UpdateTask_CurrentStageDetails_serial
		if itr.n.CurrentStageDetails.m == schema.Maybe_Absent {
			itr.idx++
			goto advance
		}
		v = itr.n.CurrentStageDetails.v.Representation()
	case 4:
		k = &fieldName__UpdateTask_WorkedBy_serial
		v = itr.n.WorkedBy.Representation()
	case 5:
		k = &fieldName__UpdateTask_RunCount_serial
		v = itr.n.RunCount.Representation()
	default:
		panic("unreachable")
	}
	itr.idx++
	return
}
func (itr *_UpdateTask__ReprMapItr) Done() bool {
	return itr.idx >= 6
}
func (_UpdateTask__Repr) ListIterator() ipld.ListIterator {
	return nil
}
func (rn *_UpdateTask__Repr) Length() int64 {
	l := 6
	if rn.ErrorMessage.m == schema.Maybe_Absent {
		l--
	}
	if rn.Stage.m == schema.Maybe_Absent {
		l--
	}
	if rn.CurrentStageDetails.m == schema.Maybe_Absent {
		l--
	}
	return int64(l)
}
func (_UpdateTask__Repr) IsAbsent() bool {
	return false
}
func (_UpdateTask__Repr) IsNull() bool {
	return false
}
func (_UpdateTask__Repr) AsBool() (bool, error) {
	return mixins.Map{"tasks.UpdateTask.Repr"}.AsBool()
}
func (_UpdateTask__Repr) AsInt() (int64, error) {
	return mixins.Map{"tasks.UpdateTask.Repr"}.AsInt()
}
func (_UpdateTask__Repr) AsFloat() (float64, error) {
	return mixins.Map{"tasks.UpdateTask.Repr"}.AsFloat()
}
func (_UpdateTask__Repr) AsString() (string, error) {
	return mixins.Map{"tasks.UpdateTask.Repr"}.AsString()
}
func (_UpdateTask__Repr) AsBytes() ([]byte, error) {
	return mixins.Map{"tasks.UpdateTask.Repr"}.AsBytes()
}
func (_UpdateTask__Repr) AsLink() (ipld.Link, error) {
	return mixins.Map{"tasks.UpdateTask.Repr"}.AsLink()
}
func (_UpdateTask__Repr) Prototype() ipld.NodePrototype {
	return _UpdateTask__ReprPrototype{}
}
type _UpdateTask__ReprPrototype struct{}

func (_UpdateTask__ReprPrototype) NewBuilder() ipld.NodeBuilder {
	var nb _UpdateTask__ReprBuilder
	nb.Reset()
	return &nb
}
type _UpdateTask__ReprBuilder struct {
	_UpdateTask__ReprAssembler
}
func (nb *_UpdateTask__ReprBuilder) Build() ipld.Node {
	if *nb.m != schema.Maybe_Value {
		panic("invalid state: cannot call Build on an assembler that's not finished")
	}
	return nb.w
}
func (nb *_UpdateTask__ReprBuilder) Reset() {
	var w _UpdateTask
	var m schema.Maybe
	*nb = _UpdateTask__ReprBuilder{_UpdateTask__ReprAssembler{w: &w, m: &m}}
}
type _UpdateTask__ReprAssembler struct {
	w *_UpdateTask
	m *schema.Maybe
	state maState
	s int
	f int

	cm schema.Maybe
	ca_Status _Status__ReprAssembler
	ca_ErrorMessage _String__ReprAssembler
	ca_Stage _String__ReprAssembler
	ca_CurrentStageDetails _StageDetails__ReprAssembler
	ca_WorkedBy _String__ReprAssembler
	ca_RunCount _Int__ReprAssembler
	}

func (na *_UpdateTask__ReprAssembler) reset() {
	na.state = maState_initial
	na.s = 0
	na.ca_Status.reset()
	na.ca_ErrorMessage.reset()
	na.ca_Stage.reset()
	na.ca_CurrentStageDetails.reset()
	na.ca_WorkedBy.reset()
	na.ca_RunCount.reset()
}
func (na *_UpdateTask__ReprAssembler) BeginMap(int64) (ipld.MapAssembler, error) {
	switch *na.m {
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: it makes no sense to 'begin' twice on the same assembler!")
	}
	*na.m = midvalue
	if na.w == nil {
		na.w = &_UpdateTask{}
	}
	return na, nil
}
func (_UpdateTask__ReprAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.MapAssembler{"tasks.UpdateTask.Repr"}.BeginList(0)
}
func (na *_UpdateTask__ReprAssembler) AssignNull() error {
	switch *na.m {
	case allowNull:
		*na.m = schema.Maybe_Null
		return nil
	case schema.Maybe_Absent:
		return mixins.MapAssembler{"tasks.UpdateTask.Repr.Repr"}.AssignNull()
	case schema.Maybe_Value, schema.Maybe_Null:
		panic("invalid state: cannot assign into assembler that's already finished")
	case midvalue:
		panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
	}
	panic("unreachable")
}
func (_UpdateTask__ReprAssembler) AssignBool(bool) error {
	return mixins.MapAssembler{"tasks.UpdateTask.Repr"}.AssignBool(false)
}
func (_UpdateTask__ReprAssembler) AssignInt(int64) error {
	return mixins.MapAssembler{"tasks.UpdateTask.Repr"}.AssignInt(0)
}
func (_UpdateTask__ReprAssembler) AssignFloat(float64) error {
	return mixins.MapAssembler{"tasks.UpdateTask.Repr"}.AssignFloat(0)
}
func (_UpdateTask__ReprAssembler) AssignString(string) error {
	return mixins.MapAssembler{"tasks.UpdateTask.Repr"}.AssignString("")
}
func (_UpdateTask__ReprAssembler) AssignBytes([]byte) error {
	return mixins.MapAssembler{"tasks.UpdateTask.Repr"}.AssignBytes(nil)
}
func (_UpdateTask__ReprAssembler) AssignLink(ipld.Link) error {
	return mixins.MapAssembler{"tasks.UpdateTask.Repr"}.AssignLink(nil)
}
func (na *_UpdateTask__ReprAssembler) AssignNode(v ipld.Node) error {
	if v.IsNull() {
		return na.AssignNull()
	}
	if v2, ok := v.(*_UpdateTask); ok {
		switch *na.m {
		case schema.Maybe_Value, schema.Maybe_Null:
			panic("invalid state: cannot assign into assembler that's already finished")
		case midvalue:
			panic("invalid state: cannot assign null into an assembler that's already begun working on recursive structures!")
		}
		if na.w == nil {
			na.w = v2
			*na.m = schema.Maybe_Value
			return nil
		}
		*na.w = *v2
		*na.m = schema.Maybe_Value
		return nil
	}
	if v.Kind() != ipld.Kind_Map {
		return ipld.ErrWrongKind{TypeName: "tasks.UpdateTask.Repr", MethodName: "AssignNode", AppropriateKind: ipld.KindSet_JustMap, ActualKind: v.Kind()}
	}
	itr := v.MapIterator()
	for !itr.Done() {
		k, v, err := itr.Next()
		if err != nil {
			return err
		}
		if err := na.AssembleKey().AssignNode(k); err != nil {
			return err
		}
		if err := na.AssembleValue().AssignNode(v); err != nil {
			return err
		}
	}
	return na.Finish()
}
func (_UpdateTask__ReprAssembler) Prototype() ipld.NodePrototype {
	return _UpdateTask__ReprPrototype{}
}
func (ma *_UpdateTask__ReprAssembler) valueFinishTidy() bool {
	switch ma.f {
	case 0:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 1:
		switch ma.w.ErrorMessage.m {
		case schema.Maybe_Value:
			ma.w.ErrorMessage.v = ma.ca_ErrorMessage.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 2:
		switch ma.w.Stage.m {
		case schema.Maybe_Value:
			ma.w.Stage.v = ma.ca_Stage.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 3:
		switch ma.w.CurrentStageDetails.m {
		case schema.Maybe_Value:
			ma.w.CurrentStageDetails.v = ma.ca_CurrentStageDetails.w
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 4:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	case 5:
		switch ma.cm {
		case schema.Maybe_Value:ma.cm = schema.Maybe_Absent
			ma.state = maState_initial
			return true
		default:
			return false
		}
	default:
		panic("unreachable")
	}
}
func (ma *_UpdateTask__ReprAssembler) AssembleEntry(k string) (ipld.NodeAssembler, error) {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleEntry cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleEntry cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleEntry cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleEntry cannot be called on an assembler that's already finished")
	}
	switch k {
	case "Status":
		if ma.s & fieldBit__UpdateTask_Status != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__UpdateTask_Status_serial}
		}
		ma.s += fieldBit__UpdateTask_Status
		ma.state = maState_midValue
		ma.f = 0
		ma.ca_Status.w = &ma.w.Status
		ma.ca_Status.m = &ma.cm
		return &ma.ca_Status, nil
	case "ErrorMessage":
		if ma.s & fieldBit__UpdateTask_ErrorMessage != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__UpdateTask_ErrorMessage_serial}
		}
		ma.s += fieldBit__UpdateTask_ErrorMessage
		ma.state = maState_midValue
		ma.f = 1
		ma.ca_ErrorMessage.w = ma.w.ErrorMessage.v
		ma.ca_ErrorMessage.m = &ma.w.ErrorMessage.m
		
		return &ma.ca_ErrorMessage, nil
	case "Stage":
		if ma.s & fieldBit__UpdateTask_Stage != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__UpdateTask_Stage_serial}
		}
		ma.s += fieldBit__UpdateTask_Stage
		ma.state = maState_midValue
		ma.f = 2
		ma.ca_Stage.w = ma.w.Stage.v
		ma.ca_Stage.m = &ma.w.Stage.m
		
		return &ma.ca_Stage, nil
	case "CurrentStageDetails":
		if ma.s & fieldBit__UpdateTask_CurrentStageDetails != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__UpdateTask_CurrentStageDetails_serial}
		}
		ma.s += fieldBit__UpdateTask_CurrentStageDetails
		ma.state = maState_midValue
		ma.f = 3
		ma.ca_CurrentStageDetails.w = ma.w.CurrentStageDetails.v
		ma.ca_CurrentStageDetails.m = &ma.w.CurrentStageDetails.m
		
		return &ma.ca_CurrentStageDetails, nil
	case "WorkedBy":
		if ma.s & fieldBit__UpdateTask_WorkedBy != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__UpdateTask_WorkedBy_serial}
		}
		ma.s += fieldBit__UpdateTask_WorkedBy
		ma.state = maState_midValue
		ma.f = 4
		ma.ca_WorkedBy.w = &ma.w.WorkedBy
		ma.ca_WorkedBy.m = &ma.cm
		return &ma.ca_WorkedBy, nil
	case "RunCount":
		if ma.s & fieldBit__UpdateTask_RunCount != 0 {
			return nil, ipld.ErrRepeatedMapKey{&fieldName__UpdateTask_RunCount_serial}
		}
		ma.s += fieldBit__UpdateTask_RunCount
		ma.state = maState_midValue
		ma.f = 5
		ma.ca_RunCount.w = &ma.w.RunCount
		ma.ca_RunCount.m = &ma.cm
		return &ma.ca_RunCount, nil
	default:
		return nil, ipld.ErrInvalidKey{TypeName:"tasks.UpdateTask.Repr", Key:&_String{k}}
	}
}
func (ma *_UpdateTask__ReprAssembler) AssembleKey() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: AssembleKey cannot be called when in the middle of assembling another key")
	case maState_expectValue:
		panic("invalid state: AssembleKey cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: AssembleKey cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: AssembleKey cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midKey
	return (*_UpdateTask__ReprKeyAssembler)(ma)
}
func (ma *_UpdateTask__ReprAssembler) AssembleValue() ipld.NodeAssembler {
	switch ma.state {
	case maState_initial:
		panic("invalid state: AssembleValue cannot be called when no key is primed")
	case maState_midKey:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		// carry on
	case maState_midValue:
		panic("invalid state: AssembleValue cannot be called when in the middle of assembling another value")
	case maState_finished:
		panic("invalid state: AssembleValue cannot be called on an assembler that's already finished")
	}
	ma.state = maState_midValue
	switch ma.f {
	case 0:
		ma.ca_Status.w = &ma.w.Status
		ma.ca_Status.m = &ma.cm
		return &ma.ca_Status
	case 1:
		ma.ca_ErrorMessage.w = ma.w.ErrorMessage.v
		ma.ca_ErrorMessage.m = &ma.w.ErrorMessage.m
		
		return &ma.ca_ErrorMessage
	case 2:
		ma.ca_Stage.w = ma.w.Stage.v
		ma.ca_Stage.m = &ma.w.Stage.m
		
		return &ma.ca_Stage
	case 3:
		ma.ca_CurrentStageDetails.w = ma.w.CurrentStageDetails.v
		ma.ca_CurrentStageDetails.m = &ma.w.CurrentStageDetails.m
		
		return &ma.ca_CurrentStageDetails
	case 4:
		ma.ca_WorkedBy.w = &ma.w.WorkedBy
		ma.ca_WorkedBy.m = &ma.cm
		return &ma.ca_WorkedBy
	case 5:
		ma.ca_RunCount.w = &ma.w.RunCount
		ma.ca_RunCount.m = &ma.cm
		return &ma.ca_RunCount
	default:
		panic("unreachable")
	}
}
func (ma *_UpdateTask__ReprAssembler) Finish() error {
	switch ma.state {
	case maState_initial:
		// carry on
	case maState_midKey:
		panic("invalid state: Finish cannot be called when in the middle of assembling a key")
	case maState_expectValue:
		panic("invalid state: Finish cannot be called when expecting start of value assembly")
	case maState_midValue:
		if !ma.valueFinishTidy() {
			panic("invalid state: Finish cannot be called when in the middle of assembling a value")
		} // if tidy success: carry on
	case maState_finished:
		panic("invalid state: Finish cannot be called on an assembler that's already finished")
	}
	if ma.s & fieldBits__UpdateTask_sufficient != fieldBits__UpdateTask_sufficient {
		err := ipld.ErrMissingRequiredField{Missing: make([]string, 0)}
		if ma.s & fieldBit__UpdateTask_Status == 0 {
			err.Missing = append(err.Missing, "Status")
		}
		if ma.s & fieldBit__UpdateTask_WorkedBy == 0 {
			err.Missing = append(err.Missing, "WorkedBy")
		}
		if ma.s & fieldBit__UpdateTask_RunCount == 0 {
			err.Missing = append(err.Missing, "RunCount")
		}
		return err
	}
	ma.state = maState_finished
	*ma.m = schema.Maybe_Value
	return nil
}
func (ma *_UpdateTask__ReprAssembler) KeyPrototype() ipld.NodePrototype {
	return _String__Prototype{}
}
func (ma *_UpdateTask__ReprAssembler) ValuePrototype(k string) ipld.NodePrototype {
	panic("todo structbuilder mapassembler repr valueprototype")
}
type _UpdateTask__ReprKeyAssembler _UpdateTask__ReprAssembler
func (_UpdateTask__ReprKeyAssembler) BeginMap(sizeHint int64) (ipld.MapAssembler, error) {
	return mixins.StringAssembler{"tasks.UpdateTask.Repr.KeyAssembler"}.BeginMap(0)
}
func (_UpdateTask__ReprKeyAssembler) BeginList(sizeHint int64) (ipld.ListAssembler, error) {
	return mixins.StringAssembler{"tasks.UpdateTask.Repr.KeyAssembler"}.BeginList(0)
}
func (na *_UpdateTask__ReprKeyAssembler) AssignNull() error {
	return mixins.StringAssembler{"tasks.UpdateTask.Repr.KeyAssembler"}.AssignNull()
}
func (_UpdateTask__ReprKeyAssembler) AssignBool(bool) error {
	return mixins.StringAssembler{"tasks.UpdateTask.Repr.KeyAssembler"}.AssignBool(false)
}
func (_UpdateTask__ReprKeyAssembler) AssignInt(int64) error {
	return mixins.StringAssembler{"tasks.UpdateTask.Repr.KeyAssembler"}.AssignInt(0)
}
func (_UpdateTask__ReprKeyAssembler) AssignFloat(float64) error {
	return mixins.StringAssembler{"tasks.UpdateTask.Repr.KeyAssembler"}.AssignFloat(0)
}
func (ka *_UpdateTask__ReprKeyAssembler) AssignString(k string) error {
	if ka.state != maState_midKey {
		panic("misuse: KeyAssembler held beyond its valid lifetime")
	}
	switch k {
	case "Status":
		if ka.s & fieldBit__UpdateTask_Status != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__UpdateTask_Status_serial}
		}
		ka.s += fieldBit__UpdateTask_Status
		ka.state = maState_expectValue
		ka.f = 0
	case "ErrorMessage":
		if ka.s & fieldBit__UpdateTask_ErrorMessage != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__UpdateTask_ErrorMessage_serial}
		}
		ka.s += fieldBit__UpdateTask_ErrorMessage
		ka.state = maState_expectValue
		ka.f = 1
	case "Stage":
		if ka.s & fieldBit__UpdateTask_Stage != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__UpdateTask_Stage_serial}
		}
		ka.s += fieldBit__UpdateTask_Stage
		ka.state = maState_expectValue
		ka.f = 2
	case "CurrentStageDetails":
		if ka.s & fieldBit__UpdateTask_CurrentStageDetails != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__UpdateTask_CurrentStageDetails_serial}
		}
		ka.s += fieldBit__UpdateTask_CurrentStageDetails
		ka.state = maState_expectValue
		ka.f = 3
	case "WorkedBy":
		if ka.s & fieldBit__UpdateTask_WorkedBy != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__UpdateTask_WorkedBy_serial}
		}
		ka.s += fieldBit__UpdateTask_WorkedBy
		ka.state = maState_expectValue
		ka.f = 4
	case "RunCount":
		if ka.s & fieldBit__UpdateTask_RunCount != 0 {
			return ipld.ErrRepeatedMapKey{&fieldName__UpdateTask_RunCount_serial}
		}
		ka.s += fieldBit__UpdateTask_RunCount
		ka.state = maState_expectValue
		ka.f = 5
	default:
		return ipld.ErrInvalidKey{TypeName:"tasks.UpdateTask.Repr", Key:&_String{k}}
	}
	return nil
}
func (_UpdateTask__ReprKeyAssembler) AssignBytes([]byte) error {
	return mixins.StringAssembler{"tasks.UpdateTask.Repr.KeyAssembler"}.AssignBytes(nil)
}
func (_UpdateTask__ReprKeyAssembler) AssignLink(ipld.Link) error {
	return mixins.StringAssembler{"tasks.UpdateTask.Repr.KeyAssembler"}.AssignLink(nil)
}
func (ka *_UpdateTask__ReprKeyAssembler) AssignNode(v ipld.Node) error {
	if v2, err := v.AsString(); err != nil {
		return err
	} else {
		return ka.AssignString(v2)
	}
}
func (_UpdateTask__ReprKeyAssembler) Prototype() ipld.NodePrototype {
	return _String__Prototype{}
}

